{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/core-js/modules/_a-function.js","node_modules/core-js/modules/_add-to-unscopables.js","node_modules/core-js/modules/_an-instance.js","node_modules/core-js/modules/_an-object.js","node_modules/core-js/modules/_array-copy-within.js","node_modules/core-js/modules/_array-fill.js","node_modules/core-js/modules/_array-includes.js","node_modules/core-js/modules/_array-methods.js","node_modules/core-js/modules/_array-species-constructor.js","node_modules/core-js/modules/_array-species-create.js","node_modules/core-js/modules/_bind.js","node_modules/core-js/modules/_classof.js","node_modules/core-js/modules/_cof.js","node_modules/core-js/modules/_collection-strong.js","node_modules/core-js/modules/_collection-weak.js","node_modules/core-js/modules/_collection.js","node_modules/core-js/modules/_core.js","node_modules/core-js/modules/_create-property.js","node_modules/core-js/modules/_ctx.js","node_modules/core-js/modules/_defined.js","node_modules/core-js/modules/_descriptors.js","node_modules/core-js/modules/_dom-create.js","node_modules/core-js/modules/_enum-bug-keys.js","node_modules/core-js/modules/_enum-keys.js","node_modules/core-js/modules/_export.js","node_modules/core-js/modules/_fails-is-regexp.js","node_modules/core-js/modules/_fails.js","node_modules/core-js/modules/_fix-re-wks.js","node_modules/core-js/modules/_flags.js","node_modules/core-js/modules/_for-of.js","node_modules/core-js/modules/_global.js","node_modules/core-js/modules/_has.js","node_modules/core-js/modules/_hide.js","node_modules/core-js/modules/_html.js","node_modules/core-js/modules/_ie8-dom-define.js","node_modules/core-js/modules/_inherit-if-required.js","node_modules/core-js/modules/_invoke.js","node_modules/core-js/modules/_iobject.js","node_modules/core-js/modules/_is-array-iter.js","node_modules/core-js/modules/_is-array.js","node_modules/core-js/modules/_is-integer.js","node_modules/core-js/modules/_is-object.js","node_modules/core-js/modules/_is-regexp.js","node_modules/core-js/modules/_iter-call.js","node_modules/core-js/modules/_iter-create.js","node_modules/core-js/modules/_iter-define.js","node_modules/core-js/modules/_iter-detect.js","node_modules/core-js/modules/_iter-step.js","node_modules/core-js/modules/_iterators.js","node_modules/core-js/modules/_library.js","node_modules/core-js/modules/_math-expm1.js","node_modules/core-js/modules/_math-fround.js","node_modules/core-js/modules/_math-log1p.js","node_modules/core-js/modules/_math-sign.js","node_modules/core-js/modules/_meta.js","node_modules/core-js/modules/_microtask.js","node_modules/core-js/modules/_new-promise-capability.js","node_modules/core-js/modules/_object-assign.js","node_modules/core-js/modules/_object-create.js","node_modules/core-js/modules/_object-dp.js","node_modules/core-js/modules/_object-dps.js","node_modules/core-js/modules/_object-gopd.js","node_modules/core-js/modules/_object-gopn-ext.js","node_modules/core-js/modules/_object-gopn.js","node_modules/core-js/modules/_object-gops.js","node_modules/core-js/modules/_object-gpo.js","node_modules/core-js/modules/_object-keys-internal.js","node_modules/core-js/modules/_object-keys.js","node_modules/core-js/modules/_object-pie.js","node_modules/core-js/modules/_object-sap.js","node_modules/core-js/modules/_object-to-array.js","node_modules/core-js/modules/_own-keys.js","node_modules/core-js/modules/_perform.js","node_modules/core-js/modules/_promise-resolve.js","node_modules/core-js/modules/_property-desc.js","node_modules/core-js/modules/_redefine-all.js","node_modules/core-js/modules/_redefine.js","node_modules/core-js/modules/_same-value.js","node_modules/core-js/modules/_set-proto.js","node_modules/core-js/modules/_set-species.js","node_modules/core-js/modules/_set-to-string-tag.js","node_modules/core-js/modules/_shared-key.js","node_modules/core-js/modules/_shared.js","node_modules/core-js/modules/_species-constructor.js","node_modules/core-js/modules/_string-at.js","node_modules/core-js/modules/_string-context.js","node_modules/core-js/modules/_string-pad.js","node_modules/core-js/modules/_string-repeat.js","node_modules/core-js/modules/_task.js","node_modules/core-js/modules/_to-absolute-index.js","node_modules/core-js/modules/_to-index.js","node_modules/core-js/modules/_to-integer.js","node_modules/core-js/modules/_to-iobject.js","node_modules/core-js/modules/_to-length.js","node_modules/core-js/modules/_to-object.js","node_modules/core-js/modules/_to-primitive.js","node_modules/core-js/modules/_typed-array.js","node_modules/core-js/modules/_typed-buffer.js","node_modules/core-js/modules/_typed.js","node_modules/core-js/modules/_uid.js","node_modules/core-js/modules/_user-agent.js","node_modules/core-js/modules/_validate-collection.js","node_modules/core-js/modules/_wks-define.js","node_modules/core-js/modules/_wks-ext.js","node_modules/core-js/modules/_wks.js","node_modules/core-js/modules/core.get-iterator-method.js","node_modules/core-js/modules/es6.array.copy-within.js","node_modules/core-js/modules/es6.array.fill.js","node_modules/core-js/modules/es6.array.find-index.js","node_modules/core-js/modules/es6.array.find.js","node_modules/core-js/modules/es6.array.from.js","node_modules/core-js/modules/es6.array.iterator.js","node_modules/core-js/modules/es6.array.of.js","node_modules/core-js/modules/es6.function.name.js","node_modules/core-js/modules/es6.map.js","node_modules/core-js/modules/es6.math.acosh.js","node_modules/core-js/modules/es6.math.asinh.js","node_modules/core-js/modules/es6.math.atanh.js","node_modules/core-js/modules/es6.math.cbrt.js","node_modules/core-js/modules/es6.math.clz32.js","node_modules/core-js/modules/es6.math.cosh.js","node_modules/core-js/modules/es6.math.expm1.js","node_modules/core-js/modules/es6.math.fround.js","node_modules/core-js/modules/es6.math.hypot.js","node_modules/core-js/modules/es6.math.imul.js","node_modules/core-js/modules/es6.math.log10.js","node_modules/core-js/modules/es6.math.log1p.js","node_modules/core-js/modules/es6.math.log2.js","node_modules/core-js/modules/es6.math.sign.js","node_modules/core-js/modules/es6.math.sinh.js","node_modules/core-js/modules/es6.math.tanh.js","node_modules/core-js/modules/es6.math.trunc.js","node_modules/core-js/modules/es6.number.epsilon.js","node_modules/core-js/modules/es6.number.is-finite.js","node_modules/core-js/modules/es6.number.is-integer.js","node_modules/core-js/modules/es6.number.is-nan.js","node_modules/core-js/modules/es6.number.is-safe-integer.js","node_modules/core-js/modules/es6.number.max-safe-integer.js","node_modules/core-js/modules/es6.number.min-safe-integer.js","node_modules/core-js/modules/es6.object.assign.js","node_modules/core-js/modules/es6.object.freeze.js","node_modules/core-js/modules/es6.object.get-own-property-descriptor.js","node_modules/core-js/modules/es6.object.get-own-property-names.js","node_modules/core-js/modules/es6.object.get-prototype-of.js","node_modules/core-js/modules/es6.object.is-extensible.js","node_modules/core-js/modules/es6.object.is-frozen.js","node_modules/core-js/modules/es6.object.is-sealed.js","node_modules/core-js/modules/es6.object.is.js","node_modules/core-js/modules/es6.object.keys.js","node_modules/core-js/modules/es6.object.prevent-extensions.js","node_modules/core-js/modules/es6.object.seal.js","node_modules/core-js/modules/es6.object.set-prototype-of.js","node_modules/core-js/modules/es6.promise.js","node_modules/core-js/modules/es6.reflect.apply.js","node_modules/core-js/modules/es6.reflect.construct.js","node_modules/core-js/modules/es6.reflect.define-property.js","node_modules/core-js/modules/es6.reflect.delete-property.js","node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js","node_modules/core-js/modules/es6.reflect.get-prototype-of.js","node_modules/core-js/modules/es6.reflect.get.js","node_modules/core-js/modules/es6.reflect.has.js","node_modules/core-js/modules/es6.reflect.is-extensible.js","node_modules/core-js/modules/es6.reflect.own-keys.js","node_modules/core-js/modules/es6.reflect.prevent-extensions.js","node_modules/core-js/modules/es6.reflect.set-prototype-of.js","node_modules/core-js/modules/es6.reflect.set.js","node_modules/core-js/modules/es6.regexp.flags.js","node_modules/core-js/modules/es6.regexp.match.js","node_modules/core-js/modules/es6.regexp.replace.js","node_modules/core-js/modules/es6.regexp.search.js","node_modules/core-js/modules/es6.regexp.split.js","node_modules/core-js/modules/es6.set.js","node_modules/core-js/modules/es6.string.code-point-at.js","node_modules/core-js/modules/es6.string.ends-with.js","node_modules/core-js/modules/es6.string.from-code-point.js","node_modules/core-js/modules/es6.string.includes.js","node_modules/core-js/modules/es6.string.raw.js","node_modules/core-js/modules/es6.string.repeat.js","node_modules/core-js/modules/es6.string.starts-with.js","node_modules/core-js/modules/es6.symbol.js","node_modules/core-js/modules/es6.typed.array-buffer.js","node_modules/core-js/modules/es6.typed.float32-array.js","node_modules/core-js/modules/es6.typed.float64-array.js","node_modules/core-js/modules/es6.typed.int16-array.js","node_modules/core-js/modules/es6.typed.int32-array.js","node_modules/core-js/modules/es6.typed.int8-array.js","node_modules/core-js/modules/es6.typed.uint16-array.js","node_modules/core-js/modules/es6.typed.uint32-array.js","node_modules/core-js/modules/es6.typed.uint8-array.js","node_modules/core-js/modules/es6.typed.uint8-clamped-array.js","node_modules/core-js/modules/es6.weak-map.js","node_modules/core-js/modules/es6.weak-set.js","node_modules/core-js/modules/es7.array.includes.js","node_modules/core-js/modules/es7.object.entries.js","node_modules/core-js/modules/es7.object.get-own-property-descriptors.js","node_modules/core-js/modules/es7.object.values.js","node_modules/core-js/modules/es7.string.pad-end.js","node_modules/core-js/modules/es7.string.pad-start.js","node_modules/core-js/modules/web.dom.iterable.js","node_modules/core-js/modules/web.immediate.js","node_modules/core-js/modules/web.timers.js","node_modules/regenerator-runtime/runtime.js","src/docs/assets/scripts/xtend.js","src/scripts/xtend-utils.js","src/scripts/xtend.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;;ACFA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;;ACHA;AACA;;ACDA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACheA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACntBA;;;ACJA;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;;AAEA;AACA;AACA;;AAEA,IAAM,S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","file":"xtend.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","module.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n","// 22.1.3.31 Array.prototype[@@unscopables]\nvar UNSCOPABLES = require('./_wks')('unscopables');\nvar ArrayProto = Array.prototype;\nif (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});\nmodule.exports = function (key) {\n  ArrayProto[UNSCOPABLES][key] = true;\n};\n","module.exports = function (it, Constructor, name, forbiddenField) {\n  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {\n    throw TypeError(name + ': incorrect invocation!');\n  } return it;\n};\n","var isObject = require('./_is-object');\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n","// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)\n'use strict';\nvar toObject = require('./_to-object');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nvar toLength = require('./_to-length');\n\nmodule.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {\n  var O = toObject(this);\n  var len = toLength(O.length);\n  var to = toAbsoluteIndex(target, len);\n  var from = toAbsoluteIndex(start, len);\n  var end = arguments.length > 2 ? arguments[2] : undefined;\n  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);\n  var inc = 1;\n  if (from < to && to < from + count) {\n    inc = -1;\n    from += count - 1;\n    to += count - 1;\n  }\n  while (count-- > 0) {\n    if (from in O) O[to] = O[from];\n    else delete O[to];\n    to += inc;\n    from += inc;\n  } return O;\n};\n","// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\n'use strict';\nvar toObject = require('./_to-object');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nvar toLength = require('./_to-length');\nmodule.exports = function fill(value /* , start = 0, end = @length */) {\n  var O = toObject(this);\n  var length = toLength(O.length);\n  var aLen = arguments.length;\n  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);\n  var end = aLen > 2 ? arguments[2] : undefined;\n  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);\n  while (endPos > index) O[index++] = value;\n  return O;\n};\n","// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./_to-iobject');\nvar toLength = require('./_to-length');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n","// 0 -> Array#forEach\n// 1 -> Array#map\n// 2 -> Array#filter\n// 3 -> Array#some\n// 4 -> Array#every\n// 5 -> Array#find\n// 6 -> Array#findIndex\nvar ctx = require('./_ctx');\nvar IObject = require('./_iobject');\nvar toObject = require('./_to-object');\nvar toLength = require('./_to-length');\nvar asc = require('./_array-species-create');\nmodule.exports = function (TYPE, $create) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  var create = $create || asc;\n  return function ($this, callbackfn, that) {\n    var O = toObject($this);\n    var self = IObject(O);\n    var f = ctx(callbackfn, that, 3);\n    var length = toLength(self.length);\n    var index = 0;\n    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;\n    var val, res;\n    for (;length > index; index++) if (NO_HOLES || index in self) {\n      val = self[index];\n      res = f(val, index, O);\n      if (TYPE) {\n        if (IS_MAP) result[index] = res;   // map\n        else if (res) switch (TYPE) {\n          case 3: return true;             // some\n          case 5: return val;              // find\n          case 6: return index;            // findIndex\n          case 2: result.push(val);        // filter\n        } else if (IS_EVERY) return false; // every\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;\n  };\n};\n","var isObject = require('./_is-object');\nvar isArray = require('./_is-array');\nvar SPECIES = require('./_wks')('species');\n\nmodule.exports = function (original) {\n  var C;\n  if (isArray(original)) {\n    C = original.constructor;\n    // cross-realm fallback\n    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;\n    if (isObject(C)) {\n      C = C[SPECIES];\n      if (C === null) C = undefined;\n    }\n  } return C === undefined ? Array : C;\n};\n","// 9.4.2.3 ArraySpeciesCreate(originalArray, length)\nvar speciesConstructor = require('./_array-species-constructor');\n\nmodule.exports = function (original, length) {\n  return new (speciesConstructor(original))(length);\n};\n","'use strict';\nvar aFunction = require('./_a-function');\nvar isObject = require('./_is-object');\nvar invoke = require('./_invoke');\nvar arraySlice = [].slice;\nvar factories = {};\n\nvar construct = function (F, len, args) {\n  if (!(len in factories)) {\n    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';\n    // eslint-disable-next-line no-new-func\n    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');\n  } return factories[len](F, args);\n};\n\nmodule.exports = Function.bind || function bind(that /* , ...args */) {\n  var fn = aFunction(this);\n  var partArgs = arraySlice.call(arguments, 1);\n  var bound = function (/* args... */) {\n    var args = partArgs.concat(arraySlice.call(arguments));\n    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);\n  };\n  if (isObject(fn.prototype)) bound.prototype = fn.prototype;\n  return bound;\n};\n","// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = require('./_cof');\nvar TAG = require('./_wks')('toStringTag');\n// ES3 wrong here\nvar ARG = cof(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (e) { /* empty */ }\n};\n\nmodule.exports = function (it) {\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n","var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n","'use strict';\nvar dP = require('./_object-dp').f;\nvar create = require('./_object-create');\nvar redefineAll = require('./_redefine-all');\nvar ctx = require('./_ctx');\nvar anInstance = require('./_an-instance');\nvar forOf = require('./_for-of');\nvar $iterDefine = require('./_iter-define');\nvar step = require('./_iter-step');\nvar setSpecies = require('./_set-species');\nvar DESCRIPTORS = require('./_descriptors');\nvar fastKey = require('./_meta').fastKey;\nvar validate = require('./_validate-collection');\nvar SIZE = DESCRIPTORS ? '_s' : 'size';\n\nvar getEntry = function (that, key) {\n  // fast case\n  var index = fastKey(key);\n  var entry;\n  if (index !== 'F') return that._i[index];\n  // frozen object case\n  for (entry = that._f; entry; entry = entry.n) {\n    if (entry.k == key) return entry;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {\n    var C = wrapper(function (that, iterable) {\n      anInstance(that, C, NAME, '_i');\n      that._t = NAME;         // collection type\n      that._i = create(null); // index\n      that._f = undefined;    // first entry\n      that._l = undefined;    // last entry\n      that[SIZE] = 0;         // size\n      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.1.3.1 Map.prototype.clear()\n      // 23.2.3.2 Set.prototype.clear()\n      clear: function clear() {\n        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {\n          entry.r = true;\n          if (entry.p) entry.p = entry.p.n = undefined;\n          delete data[entry.i];\n        }\n        that._f = that._l = undefined;\n        that[SIZE] = 0;\n      },\n      // 23.1.3.3 Map.prototype.delete(key)\n      // 23.2.3.4 Set.prototype.delete(value)\n      'delete': function (key) {\n        var that = validate(this, NAME);\n        var entry = getEntry(that, key);\n        if (entry) {\n          var next = entry.n;\n          var prev = entry.p;\n          delete that._i[entry.i];\n          entry.r = true;\n          if (prev) prev.n = next;\n          if (next) next.p = prev;\n          if (that._f == entry) that._f = next;\n          if (that._l == entry) that._l = prev;\n          that[SIZE]--;\n        } return !!entry;\n      },\n      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\n      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\n      forEach: function forEach(callbackfn /* , that = undefined */) {\n        validate(this, NAME);\n        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n        var entry;\n        while (entry = entry ? entry.n : this._f) {\n          f(entry.v, entry.k, this);\n          // revert to the last existing entry\n          while (entry && entry.r) entry = entry.p;\n        }\n      },\n      // 23.1.3.7 Map.prototype.has(key)\n      // 23.2.3.7 Set.prototype.has(value)\n      has: function has(key) {\n        return !!getEntry(validate(this, NAME), key);\n      }\n    });\n    if (DESCRIPTORS) dP(C.prototype, 'size', {\n      get: function () {\n        return validate(this, NAME)[SIZE];\n      }\n    });\n    return C;\n  },\n  def: function (that, key, value) {\n    var entry = getEntry(that, key);\n    var prev, index;\n    // change existing entry\n    if (entry) {\n      entry.v = value;\n    // create new entry\n    } else {\n      that._l = entry = {\n        i: index = fastKey(key, true), // <- index\n        k: key,                        // <- key\n        v: value,                      // <- value\n        p: prev = that._l,             // <- previous entry\n        n: undefined,                  // <- next entry\n        r: false                       // <- removed\n      };\n      if (!that._f) that._f = entry;\n      if (prev) prev.n = entry;\n      that[SIZE]++;\n      // add to index\n      if (index !== 'F') that._i[index] = entry;\n    } return that;\n  },\n  getEntry: getEntry,\n  setStrong: function (C, NAME, IS_MAP) {\n    // add .keys, .values, .entries, [@@iterator]\n    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\n    $iterDefine(C, NAME, function (iterated, kind) {\n      this._t = validate(iterated, NAME); // target\n      this._k = kind;                     // kind\n      this._l = undefined;                // previous\n    }, function () {\n      var that = this;\n      var kind = that._k;\n      var entry = that._l;\n      // revert to the last existing entry\n      while (entry && entry.r) entry = entry.p;\n      // get next entry\n      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {\n        // or finish the iteration\n        that._t = undefined;\n        return step(1);\n      }\n      // return step by kind\n      if (kind == 'keys') return step(0, entry.k);\n      if (kind == 'values') return step(0, entry.v);\n      return step(0, [entry.k, entry.v]);\n    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);\n\n    // add [@@species], 23.1.2.2, 23.2.2.2\n    setSpecies(NAME);\n  }\n};\n","'use strict';\nvar redefineAll = require('./_redefine-all');\nvar getWeak = require('./_meta').getWeak;\nvar anObject = require('./_an-object');\nvar isObject = require('./_is-object');\nvar anInstance = require('./_an-instance');\nvar forOf = require('./_for-of');\nvar createArrayMethod = require('./_array-methods');\nvar $has = require('./_has');\nvar validate = require('./_validate-collection');\nvar arrayFind = createArrayMethod(5);\nvar arrayFindIndex = createArrayMethod(6);\nvar id = 0;\n\n// fallback for uncaught frozen keys\nvar uncaughtFrozenStore = function (that) {\n  return that._l || (that._l = new UncaughtFrozenStore());\n};\nvar UncaughtFrozenStore = function () {\n  this.a = [];\n};\nvar findUncaughtFrozen = function (store, key) {\n  return arrayFind(store.a, function (it) {\n    return it[0] === key;\n  });\n};\nUncaughtFrozenStore.prototype = {\n  get: function (key) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) return entry[1];\n  },\n  has: function (key) {\n    return !!findUncaughtFrozen(this, key);\n  },\n  set: function (key, value) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) entry[1] = value;\n    else this.a.push([key, value]);\n  },\n  'delete': function (key) {\n    var index = arrayFindIndex(this.a, function (it) {\n      return it[0] === key;\n    });\n    if (~index) this.a.splice(index, 1);\n    return !!~index;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {\n    var C = wrapper(function (that, iterable) {\n      anInstance(that, C, NAME, '_i');\n      that._t = NAME;      // collection type\n      that._i = id++;      // collection id\n      that._l = undefined; // leak store for uncaught frozen objects\n      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.3.3.2 WeakMap.prototype.delete(key)\n      // 23.4.3.3 WeakSet.prototype.delete(value)\n      'delete': function (key) {\n        if (!isObject(key)) return false;\n        var data = getWeak(key);\n        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);\n        return data && $has(data, this._i) && delete data[this._i];\n      },\n      // 23.3.3.4 WeakMap.prototype.has(key)\n      // 23.4.3.4 WeakSet.prototype.has(value)\n      has: function has(key) {\n        if (!isObject(key)) return false;\n        var data = getWeak(key);\n        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);\n        return data && $has(data, this._i);\n      }\n    });\n    return C;\n  },\n  def: function (that, key, value) {\n    var data = getWeak(anObject(key), true);\n    if (data === true) uncaughtFrozenStore(that).set(key, value);\n    else data[that._i] = value;\n    return that;\n  },\n  ufstore: uncaughtFrozenStore\n};\n","'use strict';\nvar global = require('./_global');\nvar $export = require('./_export');\nvar redefine = require('./_redefine');\nvar redefineAll = require('./_redefine-all');\nvar meta = require('./_meta');\nvar forOf = require('./_for-of');\nvar anInstance = require('./_an-instance');\nvar isObject = require('./_is-object');\nvar fails = require('./_fails');\nvar $iterDetect = require('./_iter-detect');\nvar setToStringTag = require('./_set-to-string-tag');\nvar inheritIfRequired = require('./_inherit-if-required');\n\nmodule.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {\n  var Base = global[NAME];\n  var C = Base;\n  var ADDER = IS_MAP ? 'set' : 'add';\n  var proto = C && C.prototype;\n  var O = {};\n  var fixMethod = function (KEY) {\n    var fn = proto[KEY];\n    redefine(proto, KEY,\n      KEY == 'delete' ? function (a) {\n        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'has' ? function has(a) {\n        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'get' ? function get(a) {\n        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }\n        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }\n    );\n  };\n  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {\n    new C().entries().next();\n  }))) {\n    // create collection constructor\n    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);\n    redefineAll(C.prototype, methods);\n    meta.NEED = true;\n  } else {\n    var instance = new C();\n    // early implementations not supports chaining\n    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;\n    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false\n    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });\n    // most early implementations doesn't supports iterables, most modern - not close it correctly\n    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new\n    // for early implementations -0 and +0 not the same\n    var BUGGY_ZERO = !IS_WEAK && fails(function () {\n      // V8 ~ Chromium 42- fails only with 5+ elements\n      var $instance = new C();\n      var index = 5;\n      while (index--) $instance[ADDER](index, index);\n      return !$instance.has(-0);\n    });\n    if (!ACCEPT_ITERABLES) {\n      C = wrapper(function (target, iterable) {\n        anInstance(target, C, NAME);\n        var that = inheritIfRequired(new Base(), target, C);\n        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\n        return that;\n      });\n      C.prototype = proto;\n      proto.constructor = C;\n    }\n    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {\n      fixMethod('delete');\n      fixMethod('has');\n      IS_MAP && fixMethod('get');\n    }\n    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);\n    // weak collections should not contains .clear method\n    if (IS_WEAK && proto.clear) delete proto.clear;\n  }\n\n  setToStringTag(C, NAME);\n\n  O[NAME] = C;\n  $export($export.G + $export.W + $export.F * (C != Base), O);\n\n  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);\n\n  return C;\n};\n","var core = module.exports = { version: '2.5.7' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n","'use strict';\nvar $defineProperty = require('./_object-dp');\nvar createDesc = require('./_property-desc');\n\nmodule.exports = function (object, index, value) {\n  if (index in object) $defineProperty.f(object, index, createDesc(0, value));\n  else object[index] = value;\n};\n","// optional / simple context binding\nvar aFunction = require('./_a-function');\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./_fails')(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n","var isObject = require('./_is-object');\nvar document = require('./_global').document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n","// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n","// all enumerable object keys, includes symbols\nvar getKeys = require('./_object-keys');\nvar gOPS = require('./_object-gops');\nvar pIE = require('./_object-pie');\nmodule.exports = function (it) {\n  var result = getKeys(it);\n  var getSymbols = gOPS.f;\n  if (getSymbols) {\n    var symbols = getSymbols(it);\n    var isEnum = pIE.f;\n    var i = 0;\n    var key;\n    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);\n  } return result;\n};\n","var global = require('./_global');\nvar core = require('./_core');\nvar hide = require('./_hide');\nvar redefine = require('./_redefine');\nvar ctx = require('./_ctx');\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n  var key, own, out, exp;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    // export native or passed\n    out = (own ? target : source)[key];\n    // bind timers to global for call from export context\n    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // extend global\n    if (target) redefine(target, key, out, type & $export.U);\n    // export\n    if (exports[key] != out) hide(exports, key, exp);\n    if (IS_PROTO && expProto[key] != out) expProto[key] = out;\n  }\n};\nglobal.core = core;\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n","var MATCH = require('./_wks')('match');\nmodule.exports = function (KEY) {\n  var re = /./;\n  try {\n    '/./'[KEY](re);\n  } catch (e) {\n    try {\n      re[MATCH] = false;\n      return !'/./'[KEY](re);\n    } catch (f) { /* empty */ }\n  } return true;\n};\n","module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n","'use strict';\nvar hide = require('./_hide');\nvar redefine = require('./_redefine');\nvar fails = require('./_fails');\nvar defined = require('./_defined');\nvar wks = require('./_wks');\n\nmodule.exports = function (KEY, length, exec) {\n  var SYMBOL = wks(KEY);\n  var fns = exec(defined, SYMBOL, ''[KEY]);\n  var strfn = fns[0];\n  var rxfn = fns[1];\n  if (fails(function () {\n    var O = {};\n    O[SYMBOL] = function () { return 7; };\n    return ''[KEY](O) != 7;\n  })) {\n    redefine(String.prototype, KEY, strfn);\n    hide(RegExp.prototype, SYMBOL, length == 2\n      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)\n      // 21.2.5.11 RegExp.prototype[@@split](string, limit)\n      ? function (string, arg) { return rxfn.call(string, this, arg); }\n      // 21.2.5.6 RegExp.prototype[@@match](string)\n      // 21.2.5.9 RegExp.prototype[@@search](string)\n      : function (string) { return rxfn.call(string, this); }\n    );\n  }\n};\n","'use strict';\n// 21.2.5.3 get RegExp.prototype.flags\nvar anObject = require('./_an-object');\nmodule.exports = function () {\n  var that = anObject(this);\n  var result = '';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.unicode) result += 'u';\n  if (that.sticky) result += 'y';\n  return result;\n};\n","var ctx = require('./_ctx');\nvar call = require('./_iter-call');\nvar isArrayIter = require('./_is-array-iter');\nvar anObject = require('./_an-object');\nvar toLength = require('./_to-length');\nvar getIterFn = require('./core.get-iterator-method');\nvar BREAK = {};\nvar RETURN = {};\nvar exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {\n  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);\n  var f = ctx(fn, that, entries ? 2 : 1);\n  var index = 0;\n  var length, step, iterator, result;\n  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {\n    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n    if (result === BREAK || result === RETURN) return result;\n  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {\n    result = call(iterator, f, step.value, entries);\n    if (result === BREAK || result === RETURN) return result;\n  }\n};\nexports.BREAK = BREAK;\nexports.RETURN = RETURN;\n","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n","var dP = require('./_object-dp');\nvar createDesc = require('./_property-desc');\nmodule.exports = require('./_descriptors') ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n","var document = require('./_global').document;\nmodule.exports = document && document.documentElement;\n","module.exports = !require('./_descriptors') && !require('./_fails')(function () {\n  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n","var isObject = require('./_is-object');\nvar setPrototypeOf = require('./_set-proto').set;\nmodule.exports = function (that, target, C) {\n  var S = target.constructor;\n  var P;\n  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {\n    setPrototypeOf(that, P);\n  } return that;\n};\n","// fast apply, http://jsperf.lnkit.com/fast-apply/5\nmodule.exports = function (fn, args, that) {\n  var un = that === undefined;\n  switch (args.length) {\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n  } return fn.apply(that, args);\n};\n","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./_cof');\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n","// check on default Array iterator\nvar Iterators = require('./_iterators');\nvar ITERATOR = require('./_wks')('iterator');\nvar ArrayProto = Array.prototype;\n\nmodule.exports = function (it) {\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};\n","// 7.2.2 IsArray(argument)\nvar cof = require('./_cof');\nmodule.exports = Array.isArray || function isArray(arg) {\n  return cof(arg) == 'Array';\n};\n","// 20.1.2.3 Number.isInteger(number)\nvar isObject = require('./_is-object');\nvar floor = Math.floor;\nmodule.exports = function isInteger(it) {\n  return !isObject(it) && isFinite(it) && floor(it) === it;\n};\n","module.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n","// 7.2.8 IsRegExp(argument)\nvar isObject = require('./_is-object');\nvar cof = require('./_cof');\nvar MATCH = require('./_wks')('match');\nmodule.exports = function (it) {\n  var isRegExp;\n  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');\n};\n","// call something on iterator step with safe closing on error\nvar anObject = require('./_an-object');\nmodule.exports = function (iterator, fn, value, entries) {\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch (e) {\n    var ret = iterator['return'];\n    if (ret !== undefined) anObject(ret.call(iterator));\n    throw e;\n  }\n};\n","'use strict';\nvar create = require('./_object-create');\nvar descriptor = require('./_property-desc');\nvar setToStringTag = require('./_set-to-string-tag');\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nrequire('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });\n\nmodule.exports = function (Constructor, NAME, next) {\n  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n","'use strict';\nvar LIBRARY = require('./_library');\nvar $export = require('./_export');\nvar redefine = require('./_redefine');\nvar hide = require('./_hide');\nvar Iterators = require('./_iterators');\nvar $iterCreate = require('./_iter-create');\nvar setToStringTag = require('./_set-to-string-tag');\nvar getPrototypeOf = require('./_object-gpo');\nvar ITERATOR = require('./_wks')('iterator');\nvar BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\nvar FF_ITERATOR = '@@iterator';\nvar KEYS = 'keys';\nvar VALUES = 'values';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function (kind) {\n    if (!BUGGY && kind in proto) return proto[kind];\n    switch (kind) {\n      case KEYS: return function keys() { return new Constructor(this, kind); };\n      case VALUES: return function values() { return new Constructor(this, kind); };\n    } return function entries() { return new Constructor(this, kind); };\n  };\n  var TAG = NAME + ' Iterator';\n  var DEF_VALUES = DEFAULT == VALUES;\n  var VALUES_BUG = false;\n  var proto = Base.prototype;\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n  var $default = $native || getMethod(DEFAULT);\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n  var methods, key, IteratorPrototype;\n  // Fix native\n  if ($anyNative) {\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\n    VALUES_BUG = true;\n    $default = function values() { return $native.call(this); };\n  }\n  // Define iterator\n  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG] = returnThis;\n  if (DEFAULT) {\n    methods = {\n      values: DEF_VALUES ? $default : getMethod(VALUES),\n      keys: IS_SET ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if (FORCED) for (key in methods) {\n      if (!(key in proto)) redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n","var ITERATOR = require('./_wks')('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR]();\n  riter['return'] = function () { SAFE_CLOSING = true; };\n  // eslint-disable-next-line no-throw-literal\n  Array.from(riter, function () { throw 2; });\n} catch (e) { /* empty */ }\n\nmodule.exports = function (exec, skipClosing) {\n  if (!skipClosing && !SAFE_CLOSING) return false;\n  var safe = false;\n  try {\n    var arr = [7];\n    var iter = arr[ITERATOR]();\n    iter.next = function () { return { done: safe = true }; };\n    arr[ITERATOR] = function () { return iter; };\n    exec(arr);\n  } catch (e) { /* empty */ }\n  return safe;\n};\n","module.exports = function (done, value) {\n  return { value: value, done: !!done };\n};\n","module.exports = {};\n","module.exports = false;\n","// 20.2.2.14 Math.expm1(x)\nvar $expm1 = Math.expm1;\nmodule.exports = (!$expm1\n  // Old FF bug\n  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168\n  // Tor Browser bug\n  || $expm1(-2e-17) != -2e-17\n) ? function expm1(x) {\n  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;\n} : $expm1;\n","// 20.2.2.16 Math.fround(x)\nvar sign = require('./_math-sign');\nvar pow = Math.pow;\nvar EPSILON = pow(2, -52);\nvar EPSILON32 = pow(2, -23);\nvar MAX32 = pow(2, 127) * (2 - EPSILON32);\nvar MIN32 = pow(2, -126);\n\nvar roundTiesToEven = function (n) {\n  return n + 1 / EPSILON - 1 / EPSILON;\n};\n\nmodule.exports = Math.fround || function fround(x) {\n  var $abs = Math.abs(x);\n  var $sign = sign(x);\n  var a, result;\n  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;\n  a = (1 + EPSILON32 / EPSILON) * $abs;\n  result = a - (a - $abs);\n  // eslint-disable-next-line no-self-compare\n  if (result > MAX32 || result != result) return $sign * Infinity;\n  return $sign * result;\n};\n","// 20.2.2.20 Math.log1p(x)\nmodule.exports = Math.log1p || function log1p(x) {\n  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);\n};\n","// 20.2.2.28 Math.sign(x)\nmodule.exports = Math.sign || function sign(x) {\n  // eslint-disable-next-line no-self-compare\n  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;\n};\n","var META = require('./_uid')('meta');\nvar isObject = require('./_is-object');\nvar has = require('./_has');\nvar setDesc = require('./_object-dp').f;\nvar id = 0;\nvar isExtensible = Object.isExtensible || function () {\n  return true;\n};\nvar FREEZE = !require('./_fails')(function () {\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function (it) {\n  setDesc(it, META, { value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  } });\n};\nvar fastKey = function (it, create) {\n  // return primitive with prefix\n  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return 'F';\n    // not necessary to add metadata\n    if (!create) return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function (it, create) {\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return true;\n    // not necessary to add metadata\n    if (!create) return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function (it) {\n  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY: META,\n  NEED: false,\n  fastKey: fastKey,\n  getWeak: getWeak,\n  onFreeze: onFreeze\n};\n","var global = require('./_global');\nvar macrotask = require('./_task').set;\nvar Observer = global.MutationObserver || global.WebKitMutationObserver;\nvar process = global.process;\nvar Promise = global.Promise;\nvar isNode = require('./_cof')(process) == 'process';\n\nmodule.exports = function () {\n  var head, last, notify;\n\n  var flush = function () {\n    var parent, fn;\n    if (isNode && (parent = process.domain)) parent.exit();\n    while (head) {\n      fn = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch (e) {\n        if (head) notify();\n        else last = undefined;\n        throw e;\n      }\n    } last = undefined;\n    if (parent) parent.enter();\n  };\n\n  // Node.js\n  if (isNode) {\n    notify = function () {\n      process.nextTick(flush);\n    };\n  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339\n  } else if (Observer && !(global.navigator && global.navigator.standalone)) {\n    var toggle = true;\n    var node = document.createTextNode('');\n    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new\n    notify = function () {\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if (Promise && Promise.resolve) {\n    // Promise.resolve without an argument throws an error in LG WebOS 2\n    var promise = Promise.resolve(undefined);\n    notify = function () {\n      promise.then(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessag\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    notify = function () {\n      // strange IE + webpack dev server bug - use .call(global)\n      macrotask.call(global, flush);\n    };\n  }\n\n  return function (fn) {\n    var task = { fn: fn, next: undefined };\n    if (last) last.next = task;\n    if (!head) {\n      head = task;\n      notify();\n    } last = task;\n  };\n};\n","'use strict';\n// 25.4.1.5 NewPromiseCapability(C)\nvar aFunction = require('./_a-function');\n\nfunction PromiseCapability(C) {\n  var resolve, reject;\n  this.promise = new C(function ($$resolve, $$reject) {\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject = $$reject;\n  });\n  this.resolve = aFunction(resolve);\n  this.reject = aFunction(reject);\n}\n\nmodule.exports.f = function (C) {\n  return new PromiseCapability(C);\n};\n","'use strict';\n// 19.1.2.1 Object.assign(target, source, ...)\nvar getKeys = require('./_object-keys');\nvar gOPS = require('./_object-gops');\nvar pIE = require('./_object-pie');\nvar toObject = require('./_to-object');\nvar IObject = require('./_iobject');\nvar $assign = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nmodule.exports = !$assign || require('./_fails')(function () {\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line no-undef\n  var S = Symbol();\n  var K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function (k) { B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars\n  var T = toObject(target);\n  var aLen = arguments.length;\n  var index = 1;\n  var getSymbols = gOPS.f;\n  var isEnum = pIE.f;\n  while (aLen > index) {\n    var S = IObject(arguments[index++]);\n    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];\n  } return T;\n} : $assign;\n","// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject = require('./_an-object');\nvar dPs = require('./_object-dps');\nvar enumBugKeys = require('./_enum-bug-keys');\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\nvar Empty = function () { /* empty */ };\nvar PROTOTYPE = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = require('./_dom-create')('iframe');\n  var i = enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  require('./_html').appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n","var anObject = require('./_an-object');\nvar IE8_DOM_DEFINE = require('./_ie8-dom-define');\nvar toPrimitive = require('./_to-primitive');\nvar dP = Object.defineProperty;\n\nexports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n","var dP = require('./_object-dp');\nvar anObject = require('./_an-object');\nvar getKeys = require('./_object-keys');\n\nmodule.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = getKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n","var pIE = require('./_object-pie');\nvar createDesc = require('./_property-desc');\nvar toIObject = require('./_to-iobject');\nvar toPrimitive = require('./_to-primitive');\nvar has = require('./_has');\nvar IE8_DOM_DEFINE = require('./_ie8-dom-define');\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nexports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return gOPD(O, P);\n  } catch (e) { /* empty */ }\n  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);\n};\n","// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar toIObject = require('./_to-iobject');\nvar gOPN = require('./_object-gopn').f;\nvar toString = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function (it) {\n  try {\n    return gOPN(it);\n  } catch (e) {\n    return windowNames.slice();\n  }\n};\n\nmodule.exports.f = function getOwnPropertyNames(it) {\n  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n};\n","// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar $keys = require('./_object-keys-internal');\nvar hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return $keys(O, hiddenKeys);\n};\n","exports.f = Object.getOwnPropertySymbols;\n","// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has = require('./_has');\nvar toObject = require('./_to-object');\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n","var has = require('./_has');\nvar toIObject = require('./_to-iobject');\nvar arrayIndexOf = require('./_array-includes')(false);\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n","// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = require('./_object-keys-internal');\nvar enumBugKeys = require('./_enum-bug-keys');\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n","exports.f = {}.propertyIsEnumerable;\n","// most Object methods by ES6 should accept primitives\nvar $export = require('./_export');\nvar core = require('./_core');\nvar fails = require('./_fails');\nmodule.exports = function (KEY, exec) {\n  var fn = (core.Object || {})[KEY] || Object[KEY];\n  var exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);\n};\n","var getKeys = require('./_object-keys');\nvar toIObject = require('./_to-iobject');\nvar isEnum = require('./_object-pie').f;\nmodule.exports = function (isEntries) {\n  return function (it) {\n    var O = toIObject(it);\n    var keys = getKeys(O);\n    var length = keys.length;\n    var i = 0;\n    var result = [];\n    var key;\n    while (length > i) if (isEnum.call(O, key = keys[i++])) {\n      result.push(isEntries ? [key, O[key]] : O[key]);\n    } return result;\n  };\n};\n","// all object keys, includes non-enumerable and symbols\nvar gOPN = require('./_object-gopn');\nvar gOPS = require('./_object-gops');\nvar anObject = require('./_an-object');\nvar Reflect = require('./_global').Reflect;\nmodule.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {\n  var keys = gOPN.f(anObject(it));\n  var getSymbols = gOPS.f;\n  return getSymbols ? keys.concat(getSymbols(it)) : keys;\n};\n","module.exports = function (exec) {\n  try {\n    return { e: false, v: exec() };\n  } catch (e) {\n    return { e: true, v: e };\n  }\n};\n","var anObject = require('./_an-object');\nvar isObject = require('./_is-object');\nvar newPromiseCapability = require('./_new-promise-capability');\n\nmodule.exports = function (C, x) {\n  anObject(C);\n  if (isObject(x) && x.constructor === C) return x;\n  var promiseCapability = newPromiseCapability.f(C);\n  var resolve = promiseCapability.resolve;\n  resolve(x);\n  return promiseCapability.promise;\n};\n","module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n","var redefine = require('./_redefine');\nmodule.exports = function (target, src, safe) {\n  for (var key in src) redefine(target, key, src[key], safe);\n  return target;\n};\n","var global = require('./_global');\nvar hide = require('./_hide');\nvar has = require('./_has');\nvar SRC = require('./_uid')('src');\nvar TO_STRING = 'toString';\nvar $toString = Function[TO_STRING];\nvar TPL = ('' + $toString).split(TO_STRING);\n\nrequire('./_core').inspectSource = function (it) {\n  return $toString.call(it);\n};\n\n(module.exports = function (O, key, val, safe) {\n  var isFunction = typeof val == 'function';\n  if (isFunction) has(val, 'name') || hide(val, 'name', key);\n  if (O[key] === val) return;\n  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n  if (O === global) {\n    O[key] = val;\n  } else if (!safe) {\n    delete O[key];\n    hide(O, key, val);\n  } else if (O[key]) {\n    O[key] = val;\n  } else {\n    hide(O, key, val);\n  }\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, TO_STRING, function toString() {\n  return typeof this == 'function' && this[SRC] || $toString.call(this);\n});\n","// 7.2.9 SameValue(x, y)\nmodule.exports = Object.is || function is(x, y) {\n  // eslint-disable-next-line no-self-compare\n  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;\n};\n","// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\nvar isObject = require('./_is-object');\nvar anObject = require('./_an-object');\nvar check = function (O, proto) {\n  anObject(O);\n  if (!isObject(proto) && proto !== null) throw TypeError(proto + \": can't set as prototype!\");\n};\nmodule.exports = {\n  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n    function (test, buggy, set) {\n      try {\n        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);\n        set(test, []);\n        buggy = !(test instanceof Array);\n      } catch (e) { buggy = true; }\n      return function setPrototypeOf(O, proto) {\n        check(O, proto);\n        if (buggy) O.__proto__ = proto;\n        else set(O, proto);\n        return O;\n      };\n    }({}, false) : undefined),\n  check: check\n};\n","'use strict';\nvar global = require('./_global');\nvar dP = require('./_object-dp');\nvar DESCRIPTORS = require('./_descriptors');\nvar SPECIES = require('./_wks')('species');\n\nmodule.exports = function (KEY) {\n  var C = global[KEY];\n  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {\n    configurable: true,\n    get: function () { return this; }\n  });\n};\n","var def = require('./_object-dp').f;\nvar has = require('./_has');\nvar TAG = require('./_wks')('toStringTag');\n\nmodule.exports = function (it, tag, stat) {\n  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\n};\n","var shared = require('./_shared')('keys');\nvar uid = require('./_uid');\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n","var core = require('./_core');\nvar global = require('./_global');\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: core.version,\n  mode: require('./_library') ? 'pure' : 'global',\n  copyright: ' 2018 Denis Pushkarev (zloirock.ru)'\n});\n","// 7.3.20 SpeciesConstructor(O, defaultConstructor)\nvar anObject = require('./_an-object');\nvar aFunction = require('./_a-function');\nvar SPECIES = require('./_wks')('species');\nmodule.exports = function (O, D) {\n  var C = anObject(O).constructor;\n  var S;\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n};\n","var toInteger = require('./_to-integer');\nvar defined = require('./_defined');\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function (TO_STRING) {\n  return function (that, pos) {\n    var s = String(defined(that));\n    var i = toInteger(pos);\n    var l = s.length;\n    var a, b;\n    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n","// helper for String#{startsWith, endsWith, includes}\nvar isRegExp = require('./_is-regexp');\nvar defined = require('./_defined');\n\nmodule.exports = function (that, searchString, NAME) {\n  if (isRegExp(searchString)) throw TypeError('String#' + NAME + \" doesn't accept regex!\");\n  return String(defined(that));\n};\n","// https://github.com/tc39/proposal-string-pad-start-end\nvar toLength = require('./_to-length');\nvar repeat = require('./_string-repeat');\nvar defined = require('./_defined');\n\nmodule.exports = function (that, maxLength, fillString, left) {\n  var S = String(defined(that));\n  var stringLength = S.length;\n  var fillStr = fillString === undefined ? ' ' : String(fillString);\n  var intMaxLength = toLength(maxLength);\n  if (intMaxLength <= stringLength || fillStr == '') return S;\n  var fillLen = intMaxLength - stringLength;\n  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));\n  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);\n  return left ? stringFiller + S : S + stringFiller;\n};\n","'use strict';\nvar toInteger = require('./_to-integer');\nvar defined = require('./_defined');\n\nmodule.exports = function repeat(count) {\n  var str = String(defined(this));\n  var res = '';\n  var n = toInteger(count);\n  if (n < 0 || n == Infinity) throw RangeError(\"Count can't be negative\");\n  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;\n  return res;\n};\n","var ctx = require('./_ctx');\nvar invoke = require('./_invoke');\nvar html = require('./_html');\nvar cel = require('./_dom-create');\nvar global = require('./_global');\nvar process = global.process;\nvar setTask = global.setImmediate;\nvar clearTask = global.clearImmediate;\nvar MessageChannel = global.MessageChannel;\nvar Dispatch = global.Dispatch;\nvar counter = 0;\nvar queue = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar defer, channel, port;\nvar run = function () {\n  var id = +this;\n  // eslint-disable-next-line no-prototype-builtins\n  if (queue.hasOwnProperty(id)) {\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\nvar listener = function (event) {\n  run.call(event.data);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!setTask || !clearTask) {\n  setTask = function setImmediate(fn) {\n    var args = [];\n    var i = 1;\n    while (arguments.length > i) args.push(arguments[i++]);\n    queue[++counter] = function () {\n      // eslint-disable-next-line no-new-func\n      invoke(typeof fn == 'function' ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function clearImmediate(id) {\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if (require('./_cof')(process) == 'process') {\n    defer = function (id) {\n      process.nextTick(ctx(run, id, 1));\n    };\n  // Sphere (JS game engine) Dispatch API\n  } else if (Dispatch && Dispatch.now) {\n    defer = function (id) {\n      Dispatch.now(ctx(run, id, 1));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  } else if (MessageChannel) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = ctx(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {\n    defer = function (id) {\n      global.postMessage(id + '', '*');\n    };\n    global.addEventListener('message', listener, false);\n  // IE8-\n  } else if (ONREADYSTATECHANGE in cel('script')) {\n    defer = function (id) {\n      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {\n        html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function (id) {\n      setTimeout(ctx(run, id, 1), 0);\n    };\n  }\n}\nmodule.exports = {\n  set: setTask,\n  clear: clearTask\n};\n","var toInteger = require('./_to-integer');\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n","// https://tc39.github.io/ecma262/#sec-toindex\nvar toInteger = require('./_to-integer');\nvar toLength = require('./_to-length');\nmodule.exports = function (it) {\n  if (it === undefined) return 0;\n  var number = toInteger(it);\n  var length = toLength(number);\n  if (number !== length) throw RangeError('Wrong length!');\n  return length;\n};\n","// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./_iobject');\nvar defined = require('./_defined');\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n","// 7.1.15 ToLength\nvar toInteger = require('./_to-integer');\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n","// 7.1.13 ToObject(argument)\nvar defined = require('./_defined');\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n","// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('./_is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n","'use strict';\nif (require('./_descriptors')) {\n  var LIBRARY = require('./_library');\n  var global = require('./_global');\n  var fails = require('./_fails');\n  var $export = require('./_export');\n  var $typed = require('./_typed');\n  var $buffer = require('./_typed-buffer');\n  var ctx = require('./_ctx');\n  var anInstance = require('./_an-instance');\n  var propertyDesc = require('./_property-desc');\n  var hide = require('./_hide');\n  var redefineAll = require('./_redefine-all');\n  var toInteger = require('./_to-integer');\n  var toLength = require('./_to-length');\n  var toIndex = require('./_to-index');\n  var toAbsoluteIndex = require('./_to-absolute-index');\n  var toPrimitive = require('./_to-primitive');\n  var has = require('./_has');\n  var classof = require('./_classof');\n  var isObject = require('./_is-object');\n  var toObject = require('./_to-object');\n  var isArrayIter = require('./_is-array-iter');\n  var create = require('./_object-create');\n  var getPrototypeOf = require('./_object-gpo');\n  var gOPN = require('./_object-gopn').f;\n  var getIterFn = require('./core.get-iterator-method');\n  var uid = require('./_uid');\n  var wks = require('./_wks');\n  var createArrayMethod = require('./_array-methods');\n  var createArrayIncludes = require('./_array-includes');\n  var speciesConstructor = require('./_species-constructor');\n  var ArrayIterators = require('./es6.array.iterator');\n  var Iterators = require('./_iterators');\n  var $iterDetect = require('./_iter-detect');\n  var setSpecies = require('./_set-species');\n  var arrayFill = require('./_array-fill');\n  var arrayCopyWithin = require('./_array-copy-within');\n  var $DP = require('./_object-dp');\n  var $GOPD = require('./_object-gopd');\n  var dP = $DP.f;\n  var gOPD = $GOPD.f;\n  var RangeError = global.RangeError;\n  var TypeError = global.TypeError;\n  var Uint8Array = global.Uint8Array;\n  var ARRAY_BUFFER = 'ArrayBuffer';\n  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;\n  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';\n  var PROTOTYPE = 'prototype';\n  var ArrayProto = Array[PROTOTYPE];\n  var $ArrayBuffer = $buffer.ArrayBuffer;\n  var $DataView = $buffer.DataView;\n  var arrayForEach = createArrayMethod(0);\n  var arrayFilter = createArrayMethod(2);\n  var arraySome = createArrayMethod(3);\n  var arrayEvery = createArrayMethod(4);\n  var arrayFind = createArrayMethod(5);\n  var arrayFindIndex = createArrayMethod(6);\n  var arrayIncludes = createArrayIncludes(true);\n  var arrayIndexOf = createArrayIncludes(false);\n  var arrayValues = ArrayIterators.values;\n  var arrayKeys = ArrayIterators.keys;\n  var arrayEntries = ArrayIterators.entries;\n  var arrayLastIndexOf = ArrayProto.lastIndexOf;\n  var arrayReduce = ArrayProto.reduce;\n  var arrayReduceRight = ArrayProto.reduceRight;\n  var arrayJoin = ArrayProto.join;\n  var arraySort = ArrayProto.sort;\n  var arraySlice = ArrayProto.slice;\n  var arrayToString = ArrayProto.toString;\n  var arrayToLocaleString = ArrayProto.toLocaleString;\n  var ITERATOR = wks('iterator');\n  var TAG = wks('toStringTag');\n  var TYPED_CONSTRUCTOR = uid('typed_constructor');\n  var DEF_CONSTRUCTOR = uid('def_constructor');\n  var ALL_CONSTRUCTORS = $typed.CONSTR;\n  var TYPED_ARRAY = $typed.TYPED;\n  var VIEW = $typed.VIEW;\n  var WRONG_LENGTH = 'Wrong length!';\n\n  var $map = createArrayMethod(1, function (O, length) {\n    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);\n  });\n\n  var LITTLE_ENDIAN = fails(function () {\n    // eslint-disable-next-line no-undef\n    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;\n  });\n\n  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {\n    new Uint8Array(1).set({});\n  });\n\n  var toOffset = function (it, BYTES) {\n    var offset = toInteger(it);\n    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');\n    return offset;\n  };\n\n  var validate = function (it) {\n    if (isObject(it) && TYPED_ARRAY in it) return it;\n    throw TypeError(it + ' is not a typed array!');\n  };\n\n  var allocate = function (C, length) {\n    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {\n      throw TypeError('It is not a typed array constructor!');\n    } return new C(length);\n  };\n\n  var speciesFromList = function (O, list) {\n    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);\n  };\n\n  var fromList = function (C, list) {\n    var index = 0;\n    var length = list.length;\n    var result = allocate(C, length);\n    while (length > index) result[index] = list[index++];\n    return result;\n  };\n\n  var addGetter = function (it, key, internal) {\n    dP(it, key, { get: function () { return this._d[internal]; } });\n  };\n\n  var $from = function from(source /* , mapfn, thisArg */) {\n    var O = toObject(source);\n    var aLen = arguments.length;\n    var mapfn = aLen > 1 ? arguments[1] : undefined;\n    var mapping = mapfn !== undefined;\n    var iterFn = getIterFn(O);\n    var i, length, values, result, step, iterator;\n    if (iterFn != undefined && !isArrayIter(iterFn)) {\n      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {\n        values.push(step.value);\n      } O = values;\n    }\n    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);\n    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {\n      result[i] = mapping ? mapfn(O[i], i) : O[i];\n    }\n    return result;\n  };\n\n  var $of = function of(/* ...items */) {\n    var index = 0;\n    var length = arguments.length;\n    var result = allocate(this, length);\n    while (length > index) result[index] = arguments[index++];\n    return result;\n  };\n\n  // iOS Safari 6.x fails here\n  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });\n\n  var $toLocaleString = function toLocaleString() {\n    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);\n  };\n\n  var proto = {\n    copyWithin: function copyWithin(target, start /* , end */) {\n      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    every: function every(callbackfn /* , thisArg */) {\n      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars\n      return arrayFill.apply(validate(this), arguments);\n    },\n    filter: function filter(callbackfn /* , thisArg */) {\n      return speciesFromList(this, arrayFilter(validate(this), callbackfn,\n        arguments.length > 1 ? arguments[1] : undefined));\n    },\n    find: function find(predicate /* , thisArg */) {\n      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    findIndex: function findIndex(predicate /* , thisArg */) {\n      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    forEach: function forEach(callbackfn /* , thisArg */) {\n      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    indexOf: function indexOf(searchElement /* , fromIndex */) {\n      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    includes: function includes(searchElement /* , fromIndex */) {\n      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    join: function join(separator) { // eslint-disable-line no-unused-vars\n      return arrayJoin.apply(validate(this), arguments);\n    },\n    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars\n      return arrayLastIndexOf.apply(validate(this), arguments);\n    },\n    map: function map(mapfn /* , thisArg */) {\n      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars\n      return arrayReduce.apply(validate(this), arguments);\n    },\n    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars\n      return arrayReduceRight.apply(validate(this), arguments);\n    },\n    reverse: function reverse() {\n      var that = this;\n      var length = validate(that).length;\n      var middle = Math.floor(length / 2);\n      var index = 0;\n      var value;\n      while (index < middle) {\n        value = that[index];\n        that[index++] = that[--length];\n        that[length] = value;\n      } return that;\n    },\n    some: function some(callbackfn /* , thisArg */) {\n      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    sort: function sort(comparefn) {\n      return arraySort.call(validate(this), comparefn);\n    },\n    subarray: function subarray(begin, end) {\n      var O = validate(this);\n      var length = O.length;\n      var $begin = toAbsoluteIndex(begin, length);\n      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(\n        O.buffer,\n        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,\n        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)\n      );\n    }\n  };\n\n  var $slice = function slice(start, end) {\n    return speciesFromList(this, arraySlice.call(validate(this), start, end));\n  };\n\n  var $set = function set(arrayLike /* , offset */) {\n    validate(this);\n    var offset = toOffset(arguments[1], 1);\n    var length = this.length;\n    var src = toObject(arrayLike);\n    var len = toLength(src.length);\n    var index = 0;\n    if (len + offset > length) throw RangeError(WRONG_LENGTH);\n    while (index < len) this[offset + index] = src[index++];\n  };\n\n  var $iterators = {\n    entries: function entries() {\n      return arrayEntries.call(validate(this));\n    },\n    keys: function keys() {\n      return arrayKeys.call(validate(this));\n    },\n    values: function values() {\n      return arrayValues.call(validate(this));\n    }\n  };\n\n  var isTAIndex = function (target, key) {\n    return isObject(target)\n      && target[TYPED_ARRAY]\n      && typeof key != 'symbol'\n      && key in target\n      && String(+key) == String(key);\n  };\n  var $getDesc = function getOwnPropertyDescriptor(target, key) {\n    return isTAIndex(target, key = toPrimitive(key, true))\n      ? propertyDesc(2, target[key])\n      : gOPD(target, key);\n  };\n  var $setDesc = function defineProperty(target, key, desc) {\n    if (isTAIndex(target, key = toPrimitive(key, true))\n      && isObject(desc)\n      && has(desc, 'value')\n      && !has(desc, 'get')\n      && !has(desc, 'set')\n      // TODO: add validation descriptor w/o calling accessors\n      && !desc.configurable\n      && (!has(desc, 'writable') || desc.writable)\n      && (!has(desc, 'enumerable') || desc.enumerable)\n    ) {\n      target[key] = desc.value;\n      return target;\n    } return dP(target, key, desc);\n  };\n\n  if (!ALL_CONSTRUCTORS) {\n    $GOPD.f = $getDesc;\n    $DP.f = $setDesc;\n  }\n\n  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {\n    getOwnPropertyDescriptor: $getDesc,\n    defineProperty: $setDesc\n  });\n\n  if (fails(function () { arrayToString.call({}); })) {\n    arrayToString = arrayToLocaleString = function toString() {\n      return arrayJoin.call(this);\n    };\n  }\n\n  var $TypedArrayPrototype$ = redefineAll({}, proto);\n  redefineAll($TypedArrayPrototype$, $iterators);\n  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);\n  redefineAll($TypedArrayPrototype$, {\n    slice: $slice,\n    set: $set,\n    constructor: function () { /* noop */ },\n    toString: arrayToString,\n    toLocaleString: $toLocaleString\n  });\n  addGetter($TypedArrayPrototype$, 'buffer', 'b');\n  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');\n  addGetter($TypedArrayPrototype$, 'byteLength', 'l');\n  addGetter($TypedArrayPrototype$, 'length', 'e');\n  dP($TypedArrayPrototype$, TAG, {\n    get: function () { return this[TYPED_ARRAY]; }\n  });\n\n  // eslint-disable-next-line max-statements\n  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {\n    CLAMPED = !!CLAMPED;\n    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';\n    var GETTER = 'get' + KEY;\n    var SETTER = 'set' + KEY;\n    var TypedArray = global[NAME];\n    var Base = TypedArray || {};\n    var TAC = TypedArray && getPrototypeOf(TypedArray);\n    var FORCED = !TypedArray || !$typed.ABV;\n    var O = {};\n    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];\n    var getter = function (that, index) {\n      var data = that._d;\n      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);\n    };\n    var setter = function (that, index, value) {\n      var data = that._d;\n      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;\n      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);\n    };\n    var addElement = function (that, index) {\n      dP(that, index, {\n        get: function () {\n          return getter(this, index);\n        },\n        set: function (value) {\n          return setter(this, index, value);\n        },\n        enumerable: true\n      });\n    };\n    if (FORCED) {\n      TypedArray = wrapper(function (that, data, $offset, $length) {\n        anInstance(that, TypedArray, NAME, '_d');\n        var index = 0;\n        var offset = 0;\n        var buffer, byteLength, length, klass;\n        if (!isObject(data)) {\n          length = toIndex(data);\n          byteLength = length * BYTES;\n          buffer = new $ArrayBuffer(byteLength);\n        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {\n          buffer = data;\n          offset = toOffset($offset, BYTES);\n          var $len = data.byteLength;\n          if ($length === undefined) {\n            if ($len % BYTES) throw RangeError(WRONG_LENGTH);\n            byteLength = $len - offset;\n            if (byteLength < 0) throw RangeError(WRONG_LENGTH);\n          } else {\n            byteLength = toLength($length) * BYTES;\n            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);\n          }\n          length = byteLength / BYTES;\n        } else if (TYPED_ARRAY in data) {\n          return fromList(TypedArray, data);\n        } else {\n          return $from.call(TypedArray, data);\n        }\n        hide(that, '_d', {\n          b: buffer,\n          o: offset,\n          l: byteLength,\n          e: length,\n          v: new $DataView(buffer)\n        });\n        while (index < length) addElement(that, index++);\n      });\n      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);\n      hide(TypedArrayPrototype, 'constructor', TypedArray);\n    } else if (!fails(function () {\n      TypedArray(1);\n    }) || !fails(function () {\n      new TypedArray(-1); // eslint-disable-line no-new\n    }) || !$iterDetect(function (iter) {\n      new TypedArray(); // eslint-disable-line no-new\n      new TypedArray(null); // eslint-disable-line no-new\n      new TypedArray(1.5); // eslint-disable-line no-new\n      new TypedArray(iter); // eslint-disable-line no-new\n    }, true)) {\n      TypedArray = wrapper(function (that, data, $offset, $length) {\n        anInstance(that, TypedArray, NAME);\n        var klass;\n        // `ws` module bug, temporarily remove validation length for Uint8Array\n        // https://github.com/websockets/ws/pull/645\n        if (!isObject(data)) return new Base(toIndex(data));\n        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {\n          return $length !== undefined\n            ? new Base(data, toOffset($offset, BYTES), $length)\n            : $offset !== undefined\n              ? new Base(data, toOffset($offset, BYTES))\n              : new Base(data);\n        }\n        if (TYPED_ARRAY in data) return fromList(TypedArray, data);\n        return $from.call(TypedArray, data);\n      });\n      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {\n        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);\n      });\n      TypedArray[PROTOTYPE] = TypedArrayPrototype;\n      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;\n    }\n    var $nativeIterator = TypedArrayPrototype[ITERATOR];\n    var CORRECT_ITER_NAME = !!$nativeIterator\n      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);\n    var $iterator = $iterators.values;\n    hide(TypedArray, TYPED_CONSTRUCTOR, true);\n    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);\n    hide(TypedArrayPrototype, VIEW, true);\n    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);\n\n    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {\n      dP(TypedArrayPrototype, TAG, {\n        get: function () { return NAME; }\n      });\n    }\n\n    O[NAME] = TypedArray;\n\n    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);\n\n    $export($export.S, NAME, {\n      BYTES_PER_ELEMENT: BYTES\n    });\n\n    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {\n      from: $from,\n      of: $of\n    });\n\n    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);\n\n    $export($export.P, NAME, proto);\n\n    setSpecies(NAME);\n\n    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });\n\n    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);\n\n    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;\n\n    $export($export.P + $export.F * fails(function () {\n      new TypedArray(1).slice();\n    }), NAME, { slice: $slice });\n\n    $export($export.P + $export.F * (fails(function () {\n      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();\n    }) || !fails(function () {\n      TypedArrayPrototype.toLocaleString.call([1, 2]);\n    })), NAME, { toLocaleString: $toLocaleString });\n\n    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;\n    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);\n  };\n} else module.exports = function () { /* empty */ };\n","'use strict';\nvar global = require('./_global');\nvar DESCRIPTORS = require('./_descriptors');\nvar LIBRARY = require('./_library');\nvar $typed = require('./_typed');\nvar hide = require('./_hide');\nvar redefineAll = require('./_redefine-all');\nvar fails = require('./_fails');\nvar anInstance = require('./_an-instance');\nvar toInteger = require('./_to-integer');\nvar toLength = require('./_to-length');\nvar toIndex = require('./_to-index');\nvar gOPN = require('./_object-gopn').f;\nvar dP = require('./_object-dp').f;\nvar arrayFill = require('./_array-fill');\nvar setToStringTag = require('./_set-to-string-tag');\nvar ARRAY_BUFFER = 'ArrayBuffer';\nvar DATA_VIEW = 'DataView';\nvar PROTOTYPE = 'prototype';\nvar WRONG_LENGTH = 'Wrong length!';\nvar WRONG_INDEX = 'Wrong index!';\nvar $ArrayBuffer = global[ARRAY_BUFFER];\nvar $DataView = global[DATA_VIEW];\nvar Math = global.Math;\nvar RangeError = global.RangeError;\n// eslint-disable-next-line no-shadow-restricted-names\nvar Infinity = global.Infinity;\nvar BaseBuffer = $ArrayBuffer;\nvar abs = Math.abs;\nvar pow = Math.pow;\nvar floor = Math.floor;\nvar log = Math.log;\nvar LN2 = Math.LN2;\nvar BUFFER = 'buffer';\nvar BYTE_LENGTH = 'byteLength';\nvar BYTE_OFFSET = 'byteOffset';\nvar $BUFFER = DESCRIPTORS ? '_b' : BUFFER;\nvar $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;\nvar $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;\n\n// IEEE754 conversions based on https://github.com/feross/ieee754\nfunction packIEEE754(value, mLen, nBytes) {\n  var buffer = new Array(nBytes);\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;\n  var i = 0;\n  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n  var e, m, c;\n  value = abs(value);\n  // eslint-disable-next-line no-self-compare\n  if (value != value || value === Infinity) {\n    // eslint-disable-next-line no-self-compare\n    m = value != value ? 1 : 0;\n    e = eMax;\n  } else {\n    e = floor(log(value) / LN2);\n    if (value * (c = pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * pow(2, eBias - 1) * pow(2, mLen);\n      e = 0;\n    }\n  }\n  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);\n  e = e << mLen | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);\n  buffer[--i] |= s * 128;\n  return buffer;\n}\nfunction unpackIEEE754(buffer, mLen, nBytes) {\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = eLen - 7;\n  var i = nBytes - 1;\n  var s = buffer[i--];\n  var e = s & 127;\n  var m;\n  s >>= 7;\n  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);\n  m = e & (1 << -nBits) - 1;\n  e >>= -nBits;\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : s ? -Infinity : Infinity;\n  } else {\n    m = m + pow(2, mLen);\n    e = e - eBias;\n  } return (s ? -1 : 1) * m * pow(2, e - mLen);\n}\n\nfunction unpackI32(bytes) {\n  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];\n}\nfunction packI8(it) {\n  return [it & 0xff];\n}\nfunction packI16(it) {\n  return [it & 0xff, it >> 8 & 0xff];\n}\nfunction packI32(it) {\n  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];\n}\nfunction packF64(it) {\n  return packIEEE754(it, 52, 8);\n}\nfunction packF32(it) {\n  return packIEEE754(it, 23, 4);\n}\n\nfunction addGetter(C, key, internal) {\n  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });\n}\n\nfunction get(view, bytes, index, isLittleEndian) {\n  var numIndex = +index;\n  var intIndex = toIndex(numIndex);\n  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);\n  var store = view[$BUFFER]._b;\n  var start = intIndex + view[$OFFSET];\n  var pack = store.slice(start, start + bytes);\n  return isLittleEndian ? pack : pack.reverse();\n}\nfunction set(view, bytes, index, conversion, value, isLittleEndian) {\n  var numIndex = +index;\n  var intIndex = toIndex(numIndex);\n  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);\n  var store = view[$BUFFER]._b;\n  var start = intIndex + view[$OFFSET];\n  var pack = conversion(+value);\n  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];\n}\n\nif (!$typed.ABV) {\n  $ArrayBuffer = function ArrayBuffer(length) {\n    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);\n    var byteLength = toIndex(length);\n    this._b = arrayFill.call(new Array(byteLength), 0);\n    this[$LENGTH] = byteLength;\n  };\n\n  $DataView = function DataView(buffer, byteOffset, byteLength) {\n    anInstance(this, $DataView, DATA_VIEW);\n    anInstance(buffer, $ArrayBuffer, DATA_VIEW);\n    var bufferLength = buffer[$LENGTH];\n    var offset = toInteger(byteOffset);\n    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');\n    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);\n    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);\n    this[$BUFFER] = buffer;\n    this[$OFFSET] = offset;\n    this[$LENGTH] = byteLength;\n  };\n\n  if (DESCRIPTORS) {\n    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');\n    addGetter($DataView, BUFFER, '_b');\n    addGetter($DataView, BYTE_LENGTH, '_l');\n    addGetter($DataView, BYTE_OFFSET, '_o');\n  }\n\n  redefineAll($DataView[PROTOTYPE], {\n    getInt8: function getInt8(byteOffset) {\n      return get(this, 1, byteOffset)[0] << 24 >> 24;\n    },\n    getUint8: function getUint8(byteOffset) {\n      return get(this, 1, byteOffset)[0];\n    },\n    getInt16: function getInt16(byteOffset /* , littleEndian */) {\n      var bytes = get(this, 2, byteOffset, arguments[1]);\n      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;\n    },\n    getUint16: function getUint16(byteOffset /* , littleEndian */) {\n      var bytes = get(this, 2, byteOffset, arguments[1]);\n      return bytes[1] << 8 | bytes[0];\n    },\n    getInt32: function getInt32(byteOffset /* , littleEndian */) {\n      return unpackI32(get(this, 4, byteOffset, arguments[1]));\n    },\n    getUint32: function getUint32(byteOffset /* , littleEndian */) {\n      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;\n    },\n    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {\n      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);\n    },\n    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {\n      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);\n    },\n    setInt8: function setInt8(byteOffset, value) {\n      set(this, 1, byteOffset, packI8, value);\n    },\n    setUint8: function setUint8(byteOffset, value) {\n      set(this, 1, byteOffset, packI8, value);\n    },\n    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {\n      set(this, 2, byteOffset, packI16, value, arguments[2]);\n    },\n    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {\n      set(this, 2, byteOffset, packI16, value, arguments[2]);\n    },\n    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packI32, value, arguments[2]);\n    },\n    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packI32, value, arguments[2]);\n    },\n    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packF32, value, arguments[2]);\n    },\n    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {\n      set(this, 8, byteOffset, packF64, value, arguments[2]);\n    }\n  });\n} else {\n  if (!fails(function () {\n    $ArrayBuffer(1);\n  }) || !fails(function () {\n    new $ArrayBuffer(-1); // eslint-disable-line no-new\n  }) || fails(function () {\n    new $ArrayBuffer(); // eslint-disable-line no-new\n    new $ArrayBuffer(1.5); // eslint-disable-line no-new\n    new $ArrayBuffer(NaN); // eslint-disable-line no-new\n    return $ArrayBuffer.name != ARRAY_BUFFER;\n  })) {\n    $ArrayBuffer = function ArrayBuffer(length) {\n      anInstance(this, $ArrayBuffer);\n      return new BaseBuffer(toIndex(length));\n    };\n    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];\n    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {\n      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);\n    }\n    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;\n  }\n  // iOS Safari 7.x bug\n  var view = new $DataView(new $ArrayBuffer(2));\n  var $setInt8 = $DataView[PROTOTYPE].setInt8;\n  view.setInt8(0, 2147483648);\n  view.setInt8(1, 2147483649);\n  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {\n    setInt8: function setInt8(byteOffset, value) {\n      $setInt8.call(this, byteOffset, value << 24 >> 24);\n    },\n    setUint8: function setUint8(byteOffset, value) {\n      $setInt8.call(this, byteOffset, value << 24 >> 24);\n    }\n  }, true);\n}\nsetToStringTag($ArrayBuffer, ARRAY_BUFFER);\nsetToStringTag($DataView, DATA_VIEW);\nhide($DataView[PROTOTYPE], $typed.VIEW, true);\nexports[ARRAY_BUFFER] = $ArrayBuffer;\nexports[DATA_VIEW] = $DataView;\n","var global = require('./_global');\nvar hide = require('./_hide');\nvar uid = require('./_uid');\nvar TYPED = uid('typed_array');\nvar VIEW = uid('view');\nvar ABV = !!(global.ArrayBuffer && global.DataView);\nvar CONSTR = ABV;\nvar i = 0;\nvar l = 9;\nvar Typed;\n\nvar TypedArrayConstructors = (\n  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'\n).split(',');\n\nwhile (i < l) {\n  if (Typed = global[TypedArrayConstructors[i++]]) {\n    hide(Typed.prototype, TYPED, true);\n    hide(Typed.prototype, VIEW, true);\n  } else CONSTR = false;\n}\n\nmodule.exports = {\n  ABV: ABV,\n  CONSTR: CONSTR,\n  TYPED: TYPED,\n  VIEW: VIEW\n};\n","var id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n","var global = require('./_global');\nvar navigator = global.navigator;\n\nmodule.exports = navigator && navigator.userAgent || '';\n","var isObject = require('./_is-object');\nmodule.exports = function (it, TYPE) {\n  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');\n  return it;\n};\n","var global = require('./_global');\nvar core = require('./_core');\nvar LIBRARY = require('./_library');\nvar wksExt = require('./_wks-ext');\nvar defineProperty = require('./_object-dp').f;\nmodule.exports = function (name) {\n  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });\n};\n","exports.f = require('./_wks');\n","var store = require('./_shared')('wks');\nvar uid = require('./_uid');\nvar Symbol = require('./_global').Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n","var classof = require('./_classof');\nvar ITERATOR = require('./_wks')('iterator');\nvar Iterators = require('./_iterators');\nmodule.exports = require('./_core').getIteratorMethod = function (it) {\n  if (it != undefined) return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n","// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)\nvar $export = require('./_export');\n\n$export($export.P, 'Array', { copyWithin: require('./_array-copy-within') });\n\nrequire('./_add-to-unscopables')('copyWithin');\n","// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\nvar $export = require('./_export');\n\n$export($export.P, 'Array', { fill: require('./_array-fill') });\n\nrequire('./_add-to-unscopables')('fill');\n","'use strict';\n// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)\nvar $export = require('./_export');\nvar $find = require('./_array-methods')(6);\nvar KEY = 'findIndex';\nvar forced = true;\n// Shouldn't skip holes\nif (KEY in []) Array(1)[KEY](function () { forced = false; });\n$export($export.P + $export.F * forced, 'Array', {\n  findIndex: function findIndex(callbackfn /* , that = undefined */) {\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\nrequire('./_add-to-unscopables')(KEY);\n","'use strict';\n// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)\nvar $export = require('./_export');\nvar $find = require('./_array-methods')(5);\nvar KEY = 'find';\nvar forced = true;\n// Shouldn't skip holes\nif (KEY in []) Array(1)[KEY](function () { forced = false; });\n$export($export.P + $export.F * forced, 'Array', {\n  find: function find(callbackfn /* , that = undefined */) {\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\nrequire('./_add-to-unscopables')(KEY);\n","'use strict';\nvar ctx = require('./_ctx');\nvar $export = require('./_export');\nvar toObject = require('./_to-object');\nvar call = require('./_iter-call');\nvar isArrayIter = require('./_is-array-iter');\nvar toLength = require('./_to-length');\nvar createProperty = require('./_create-property');\nvar getIterFn = require('./core.get-iterator-method');\n\n$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {\n  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n    var O = toObject(arrayLike);\n    var C = typeof this == 'function' ? this : Array;\n    var aLen = arguments.length;\n    var mapfn = aLen > 1 ? arguments[1] : undefined;\n    var mapping = mapfn !== undefined;\n    var index = 0;\n    var iterFn = getIterFn(O);\n    var length, result, step, iterator;\n    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n    // if object isn't iterable or it's array with default iterator - use simple case\n    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {\n      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {\n        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);\n      }\n    } else {\n      length = toLength(O.length);\n      for (result = new C(length); length > index; index++) {\n        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n      }\n    }\n    result.length = index;\n    return result;\n  }\n});\n","'use strict';\nvar addToUnscopables = require('./_add-to-unscopables');\nvar step = require('./_iter-step');\nvar Iterators = require('./_iterators');\nvar toIObject = require('./_to-iobject');\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var kind = this._k;\n  var index = this._i++;\n  if (!O || index >= O.length) {\n    this._t = undefined;\n    return step(1);\n  }\n  if (kind == 'keys') return step(0, index);\n  if (kind == 'values') return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n","'use strict';\nvar $export = require('./_export');\nvar createProperty = require('./_create-property');\n\n// WebKit Array.of isn't generic\n$export($export.S + $export.F * require('./_fails')(function () {\n  function F() { /* empty */ }\n  return !(Array.of.call(F) instanceof F);\n}), 'Array', {\n  // 22.1.2.3 Array.of( ...items)\n  of: function of(/* ...args */) {\n    var index = 0;\n    var aLen = arguments.length;\n    var result = new (typeof this == 'function' ? this : Array)(aLen);\n    while (aLen > index) createProperty(result, index, arguments[index++]);\n    result.length = aLen;\n    return result;\n  }\n});\n","var dP = require('./_object-dp').f;\nvar FProto = Function.prototype;\nvar nameRE = /^\\s*function ([^ (]*)/;\nvar NAME = 'name';\n\n// 19.2.4.2 name\nNAME in FProto || require('./_descriptors') && dP(FProto, NAME, {\n  configurable: true,\n  get: function () {\n    try {\n      return ('' + this).match(nameRE)[1];\n    } catch (e) {\n      return '';\n    }\n  }\n});\n","'use strict';\nvar strong = require('./_collection-strong');\nvar validate = require('./_validate-collection');\nvar MAP = 'Map';\n\n// 23.1 Map Objects\nmodule.exports = require('./_collection')(MAP, function (get) {\n  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.1.3.6 Map.prototype.get(key)\n  get: function get(key) {\n    var entry = strong.getEntry(validate(this, MAP), key);\n    return entry && entry.v;\n  },\n  // 23.1.3.9 Map.prototype.set(key, value)\n  set: function set(key, value) {\n    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);\n  }\n}, strong, true);\n","// 20.2.2.3 Math.acosh(x)\nvar $export = require('./_export');\nvar log1p = require('./_math-log1p');\nvar sqrt = Math.sqrt;\nvar $acosh = Math.acosh;\n\n$export($export.S + $export.F * !($acosh\n  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509\n  && Math.floor($acosh(Number.MAX_VALUE)) == 710\n  // Tor Browser bug: Math.acosh(Infinity) -> NaN\n  && $acosh(Infinity) == Infinity\n), 'Math', {\n  acosh: function acosh(x) {\n    return (x = +x) < 1 ? NaN : x > 94906265.62425156\n      ? Math.log(x) + Math.LN2\n      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));\n  }\n});\n","// 20.2.2.5 Math.asinh(x)\nvar $export = require('./_export');\nvar $asinh = Math.asinh;\n\nfunction asinh(x) {\n  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));\n}\n\n// Tor Browser bug: Math.asinh(0) -> -0\n$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });\n","// 20.2.2.7 Math.atanh(x)\nvar $export = require('./_export');\nvar $atanh = Math.atanh;\n\n// Tor Browser bug: Math.atanh(-0) -> 0\n$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {\n  atanh: function atanh(x) {\n    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;\n  }\n});\n","// 20.2.2.9 Math.cbrt(x)\nvar $export = require('./_export');\nvar sign = require('./_math-sign');\n\n$export($export.S, 'Math', {\n  cbrt: function cbrt(x) {\n    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);\n  }\n});\n","// 20.2.2.11 Math.clz32(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  clz32: function clz32(x) {\n    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;\n  }\n});\n","// 20.2.2.12 Math.cosh(x)\nvar $export = require('./_export');\nvar exp = Math.exp;\n\n$export($export.S, 'Math', {\n  cosh: function cosh(x) {\n    return (exp(x = +x) + exp(-x)) / 2;\n  }\n});\n","// 20.2.2.14 Math.expm1(x)\nvar $export = require('./_export');\nvar $expm1 = require('./_math-expm1');\n\n$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });\n","// 20.2.2.16 Math.fround(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', { fround: require('./_math-fround') });\n","// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])\nvar $export = require('./_export');\nvar abs = Math.abs;\n\n$export($export.S, 'Math', {\n  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars\n    var sum = 0;\n    var i = 0;\n    var aLen = arguments.length;\n    var larg = 0;\n    var arg, div;\n    while (i < aLen) {\n      arg = abs(arguments[i++]);\n      if (larg < arg) {\n        div = larg / arg;\n        sum = sum * div * div + 1;\n        larg = arg;\n      } else if (arg > 0) {\n        div = arg / larg;\n        sum += div * div;\n      } else sum += arg;\n    }\n    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);\n  }\n});\n","// 20.2.2.18 Math.imul(x, y)\nvar $export = require('./_export');\nvar $imul = Math.imul;\n\n// some WebKit versions fails with big numbers, some has wrong arity\n$export($export.S + $export.F * require('./_fails')(function () {\n  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;\n}), 'Math', {\n  imul: function imul(x, y) {\n    var UINT16 = 0xffff;\n    var xn = +x;\n    var yn = +y;\n    var xl = UINT16 & xn;\n    var yl = UINT16 & yn;\n    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);\n  }\n});\n","// 20.2.2.21 Math.log10(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  log10: function log10(x) {\n    return Math.log(x) * Math.LOG10E;\n  }\n});\n","// 20.2.2.20 Math.log1p(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', { log1p: require('./_math-log1p') });\n","// 20.2.2.22 Math.log2(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  log2: function log2(x) {\n    return Math.log(x) / Math.LN2;\n  }\n});\n","// 20.2.2.28 Math.sign(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', { sign: require('./_math-sign') });\n","// 20.2.2.30 Math.sinh(x)\nvar $export = require('./_export');\nvar expm1 = require('./_math-expm1');\nvar exp = Math.exp;\n\n// V8 near Chromium 38 has a problem with very small numbers\n$export($export.S + $export.F * require('./_fails')(function () {\n  return !Math.sinh(-2e-17) != -2e-17;\n}), 'Math', {\n  sinh: function sinh(x) {\n    return Math.abs(x = +x) < 1\n      ? (expm1(x) - expm1(-x)) / 2\n      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);\n  }\n});\n","// 20.2.2.33 Math.tanh(x)\nvar $export = require('./_export');\nvar expm1 = require('./_math-expm1');\nvar exp = Math.exp;\n\n$export($export.S, 'Math', {\n  tanh: function tanh(x) {\n    var a = expm1(x = +x);\n    var b = expm1(-x);\n    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));\n  }\n});\n","// 20.2.2.34 Math.trunc(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  trunc: function trunc(it) {\n    return (it > 0 ? Math.floor : Math.ceil)(it);\n  }\n});\n","// 20.1.2.1 Number.EPSILON\nvar $export = require('./_export');\n\n$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });\n","// 20.1.2.2 Number.isFinite(number)\nvar $export = require('./_export');\nvar _isFinite = require('./_global').isFinite;\n\n$export($export.S, 'Number', {\n  isFinite: function isFinite(it) {\n    return typeof it == 'number' && _isFinite(it);\n  }\n});\n","// 20.1.2.3 Number.isInteger(number)\nvar $export = require('./_export');\n\n$export($export.S, 'Number', { isInteger: require('./_is-integer') });\n","// 20.1.2.4 Number.isNaN(number)\nvar $export = require('./_export');\n\n$export($export.S, 'Number', {\n  isNaN: function isNaN(number) {\n    // eslint-disable-next-line no-self-compare\n    return number != number;\n  }\n});\n","// 20.1.2.5 Number.isSafeInteger(number)\nvar $export = require('./_export');\nvar isInteger = require('./_is-integer');\nvar abs = Math.abs;\n\n$export($export.S, 'Number', {\n  isSafeInteger: function isSafeInteger(number) {\n    return isInteger(number) && abs(number) <= 0x1fffffffffffff;\n  }\n});\n","// 20.1.2.6 Number.MAX_SAFE_INTEGER\nvar $export = require('./_export');\n\n$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });\n","// 20.1.2.10 Number.MIN_SAFE_INTEGER\nvar $export = require('./_export');\n\n$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });\n","// 19.1.3.1 Object.assign(target, source)\nvar $export = require('./_export');\n\n$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });\n","// 19.1.2.5 Object.freeze(O)\nvar isObject = require('./_is-object');\nvar meta = require('./_meta').onFreeze;\n\nrequire('./_object-sap')('freeze', function ($freeze) {\n  return function freeze(it) {\n    return $freeze && isObject(it) ? $freeze(meta(it)) : it;\n  };\n});\n","// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\nvar toIObject = require('./_to-iobject');\nvar $getOwnPropertyDescriptor = require('./_object-gopd').f;\n\nrequire('./_object-sap')('getOwnPropertyDescriptor', function () {\n  return function getOwnPropertyDescriptor(it, key) {\n    return $getOwnPropertyDescriptor(toIObject(it), key);\n  };\n});\n","// 19.1.2.7 Object.getOwnPropertyNames(O)\nrequire('./_object-sap')('getOwnPropertyNames', function () {\n  return require('./_object-gopn-ext').f;\n});\n","// 19.1.2.9 Object.getPrototypeOf(O)\nvar toObject = require('./_to-object');\nvar $getPrototypeOf = require('./_object-gpo');\n\nrequire('./_object-sap')('getPrototypeOf', function () {\n  return function getPrototypeOf(it) {\n    return $getPrototypeOf(toObject(it));\n  };\n});\n","// 19.1.2.11 Object.isExtensible(O)\nvar isObject = require('./_is-object');\n\nrequire('./_object-sap')('isExtensible', function ($isExtensible) {\n  return function isExtensible(it) {\n    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;\n  };\n});\n","// 19.1.2.12 Object.isFrozen(O)\nvar isObject = require('./_is-object');\n\nrequire('./_object-sap')('isFrozen', function ($isFrozen) {\n  return function isFrozen(it) {\n    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;\n  };\n});\n","// 19.1.2.13 Object.isSealed(O)\nvar isObject = require('./_is-object');\n\nrequire('./_object-sap')('isSealed', function ($isSealed) {\n  return function isSealed(it) {\n    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;\n  };\n});\n","// 19.1.3.10 Object.is(value1, value2)\nvar $export = require('./_export');\n$export($export.S, 'Object', { is: require('./_same-value') });\n","// 19.1.2.14 Object.keys(O)\nvar toObject = require('./_to-object');\nvar $keys = require('./_object-keys');\n\nrequire('./_object-sap')('keys', function () {\n  return function keys(it) {\n    return $keys(toObject(it));\n  };\n});\n","// 19.1.2.15 Object.preventExtensions(O)\nvar isObject = require('./_is-object');\nvar meta = require('./_meta').onFreeze;\n\nrequire('./_object-sap')('preventExtensions', function ($preventExtensions) {\n  return function preventExtensions(it) {\n    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;\n  };\n});\n","// 19.1.2.17 Object.seal(O)\nvar isObject = require('./_is-object');\nvar meta = require('./_meta').onFreeze;\n\nrequire('./_object-sap')('seal', function ($seal) {\n  return function seal(it) {\n    return $seal && isObject(it) ? $seal(meta(it)) : it;\n  };\n});\n","// 19.1.3.19 Object.setPrototypeOf(O, proto)\nvar $export = require('./_export');\n$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });\n","'use strict';\nvar LIBRARY = require('./_library');\nvar global = require('./_global');\nvar ctx = require('./_ctx');\nvar classof = require('./_classof');\nvar $export = require('./_export');\nvar isObject = require('./_is-object');\nvar aFunction = require('./_a-function');\nvar anInstance = require('./_an-instance');\nvar forOf = require('./_for-of');\nvar speciesConstructor = require('./_species-constructor');\nvar task = require('./_task').set;\nvar microtask = require('./_microtask')();\nvar newPromiseCapabilityModule = require('./_new-promise-capability');\nvar perform = require('./_perform');\nvar userAgent = require('./_user-agent');\nvar promiseResolve = require('./_promise-resolve');\nvar PROMISE = 'Promise';\nvar TypeError = global.TypeError;\nvar process = global.process;\nvar versions = process && process.versions;\nvar v8 = versions && versions.v8 || '';\nvar $Promise = global[PROMISE];\nvar isNode = classof(process) == 'process';\nvar empty = function () { /* empty */ };\nvar Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;\nvar newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;\n\nvar USE_NATIVE = !!function () {\n  try {\n    // correct subclassing with @@species support\n    var promise = $Promise.resolve(1);\n    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {\n      exec(empty, empty);\n    };\n    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n    return (isNode || typeof PromiseRejectionEvent == 'function')\n      && promise.then(empty) instanceof FakePromise\n      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\n      // we can't detect it synchronously, so just check versions\n      && v8.indexOf('6.6') !== 0\n      && userAgent.indexOf('Chrome/66') === -1;\n  } catch (e) { /* empty */ }\n}();\n\n// helpers\nvar isThenable = function (it) {\n  var then;\n  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\nvar notify = function (promise, isReject) {\n  if (promise._n) return;\n  promise._n = true;\n  var chain = promise._c;\n  microtask(function () {\n    var value = promise._v;\n    var ok = promise._s == 1;\n    var i = 0;\n    var run = function (reaction) {\n      var handler = ok ? reaction.ok : reaction.fail;\n      var resolve = reaction.resolve;\n      var reject = reaction.reject;\n      var domain = reaction.domain;\n      var result, then, exited;\n      try {\n        if (handler) {\n          if (!ok) {\n            if (promise._h == 2) onHandleUnhandled(promise);\n            promise._h = 1;\n          }\n          if (handler === true) result = value;\n          else {\n            if (domain) domain.enter();\n            result = handler(value); // may throw\n            if (domain) {\n              domain.exit();\n              exited = true;\n            }\n          }\n          if (result === reaction.promise) {\n            reject(TypeError('Promise-chain cycle'));\n          } else if (then = isThenable(result)) {\n            then.call(result, resolve, reject);\n          } else resolve(result);\n        } else reject(value);\n      } catch (e) {\n        if (domain && !exited) domain.exit();\n        reject(e);\n      }\n    };\n    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach\n    promise._c = [];\n    promise._n = false;\n    if (isReject && !promise._h) onUnhandled(promise);\n  });\n};\nvar onUnhandled = function (promise) {\n  task.call(global, function () {\n    var value = promise._v;\n    var unhandled = isUnhandled(promise);\n    var result, handler, console;\n    if (unhandled) {\n      result = perform(function () {\n        if (isNode) {\n          process.emit('unhandledRejection', value, promise);\n        } else if (handler = global.onunhandledrejection) {\n          handler({ promise: promise, reason: value });\n        } else if ((console = global.console) && console.error) {\n          console.error('Unhandled promise rejection', value);\n        }\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      promise._h = isNode || isUnhandled(promise) ? 2 : 1;\n    } promise._a = undefined;\n    if (unhandled && result.e) throw result.v;\n  });\n};\nvar isUnhandled = function (promise) {\n  return promise._h !== 1 && (promise._a || promise._c).length === 0;\n};\nvar onHandleUnhandled = function (promise) {\n  task.call(global, function () {\n    var handler;\n    if (isNode) {\n      process.emit('rejectionHandled', promise);\n    } else if (handler = global.onrejectionhandled) {\n      handler({ promise: promise, reason: promise._v });\n    }\n  });\n};\nvar $reject = function (value) {\n  var promise = this;\n  if (promise._d) return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  promise._v = value;\n  promise._s = 2;\n  if (!promise._a) promise._a = promise._c.slice();\n  notify(promise, true);\n};\nvar $resolve = function (value) {\n  var promise = this;\n  var then;\n  if (promise._d) return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  try {\n    if (promise === value) throw TypeError(\"Promise can't be resolved itself\");\n    if (then = isThenable(value)) {\n      microtask(function () {\n        var wrapper = { _w: promise, _d: false }; // wrap\n        try {\n          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\n        } catch (e) {\n          $reject.call(wrapper, e);\n        }\n      });\n    } else {\n      promise._v = value;\n      promise._s = 1;\n      notify(promise, false);\n    }\n  } catch (e) {\n    $reject.call({ _w: promise, _d: false }, e); // wrap\n  }\n};\n\n// constructor polyfill\nif (!USE_NATIVE) {\n  // 25.4.3.1 Promise(executor)\n  $Promise = function Promise(executor) {\n    anInstance(this, $Promise, PROMISE, '_h');\n    aFunction(executor);\n    Internal.call(this);\n    try {\n      executor(ctx($resolve, this, 1), ctx($reject, this, 1));\n    } catch (err) {\n      $reject.call(this, err);\n    }\n  };\n  // eslint-disable-next-line no-unused-vars\n  Internal = function Promise(executor) {\n    this._c = [];             // <- awaiting reactions\n    this._a = undefined;      // <- checked in isUnhandled reactions\n    this._s = 0;              // <- state\n    this._d = false;          // <- done\n    this._v = undefined;      // <- value\n    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\n    this._n = false;          // <- notify\n  };\n  Internal.prototype = require('./_redefine-all')($Promise.prototype, {\n    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n    then: function then(onFulfilled, onRejected) {\n      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));\n      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;\n      reaction.fail = typeof onRejected == 'function' && onRejected;\n      reaction.domain = isNode ? process.domain : undefined;\n      this._c.push(reaction);\n      if (this._a) this._a.push(reaction);\n      if (this._s) notify(this, false);\n      return reaction.promise;\n    },\n    // 25.4.5.1 Promise.prototype.catch(onRejected)\n    'catch': function (onRejected) {\n      return this.then(undefined, onRejected);\n    }\n  });\n  OwnPromiseCapability = function () {\n    var promise = new Internal();\n    this.promise = promise;\n    this.resolve = ctx($resolve, promise, 1);\n    this.reject = ctx($reject, promise, 1);\n  };\n  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {\n    return C === $Promise || C === Wrapper\n      ? new OwnPromiseCapability(C)\n      : newGenericPromiseCapability(C);\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });\nrequire('./_set-to-string-tag')($Promise, PROMISE);\nrequire('./_set-species')(PROMISE);\nWrapper = require('./_core')[PROMISE];\n\n// statics\n$export($export.S + $export.F * !USE_NATIVE, PROMISE, {\n  // 25.4.4.5 Promise.reject(r)\n  reject: function reject(r) {\n    var capability = newPromiseCapability(this);\n    var $$reject = capability.reject;\n    $$reject(r);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {\n  // 25.4.4.6 Promise.resolve(x)\n  resolve: function resolve(x) {\n    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);\n  }\n});\n$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {\n  $Promise.all(iter)['catch'](empty);\n})), PROMISE, {\n  // 25.4.4.1 Promise.all(iterable)\n  all: function all(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var resolve = capability.resolve;\n    var reject = capability.reject;\n    var result = perform(function () {\n      var values = [];\n      var index = 0;\n      var remaining = 1;\n      forOf(iterable, false, function (promise) {\n        var $index = index++;\n        var alreadyCalled = false;\n        values.push(undefined);\n        remaining++;\n        C.resolve(promise).then(function (value) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          values[$index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if (result.e) reject(result.v);\n    return capability.promise;\n  },\n  // 25.4.4.4 Promise.race(iterable)\n  race: function race(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var reject = capability.reject;\n    var result = perform(function () {\n      forOf(iterable, false, function (promise) {\n        C.resolve(promise).then(capability.resolve, reject);\n      });\n    });\n    if (result.e) reject(result.v);\n    return capability.promise;\n  }\n});\n","// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)\nvar $export = require('./_export');\nvar aFunction = require('./_a-function');\nvar anObject = require('./_an-object');\nvar rApply = (require('./_global').Reflect || {}).apply;\nvar fApply = Function.apply;\n// MS Edge argumentsList argument is optional\n$export($export.S + $export.F * !require('./_fails')(function () {\n  rApply(function () { /* empty */ });\n}), 'Reflect', {\n  apply: function apply(target, thisArgument, argumentsList) {\n    var T = aFunction(target);\n    var L = anObject(argumentsList);\n    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);\n  }\n});\n","// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])\nvar $export = require('./_export');\nvar create = require('./_object-create');\nvar aFunction = require('./_a-function');\nvar anObject = require('./_an-object');\nvar isObject = require('./_is-object');\nvar fails = require('./_fails');\nvar bind = require('./_bind');\nvar rConstruct = (require('./_global').Reflect || {}).construct;\n\n// MS Edge supports only 2 arguments and argumentsList argument is optional\n// FF Nightly sets third argument as `new.target`, but does not create `this` from it\nvar NEW_TARGET_BUG = fails(function () {\n  function F() { /* empty */ }\n  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);\n});\nvar ARGS_BUG = !fails(function () {\n  rConstruct(function () { /* empty */ });\n});\n\n$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {\n  construct: function construct(Target, args /* , newTarget */) {\n    aFunction(Target);\n    anObject(args);\n    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);\n    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);\n    if (Target == newTarget) {\n      // w/o altered newTarget, optimization for 0-4 arguments\n      switch (args.length) {\n        case 0: return new Target();\n        case 1: return new Target(args[0]);\n        case 2: return new Target(args[0], args[1]);\n        case 3: return new Target(args[0], args[1], args[2]);\n        case 4: return new Target(args[0], args[1], args[2], args[3]);\n      }\n      // w/o altered newTarget, lot of arguments case\n      var $args = [null];\n      $args.push.apply($args, args);\n      return new (bind.apply(Target, $args))();\n    }\n    // with altered newTarget, not support built-in constructors\n    var proto = newTarget.prototype;\n    var instance = create(isObject(proto) ? proto : Object.prototype);\n    var result = Function.apply.call(Target, instance, args);\n    return isObject(result) ? result : instance;\n  }\n});\n","// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)\nvar dP = require('./_object-dp');\nvar $export = require('./_export');\nvar anObject = require('./_an-object');\nvar toPrimitive = require('./_to-primitive');\n\n// MS Edge has broken Reflect.defineProperty - throwing instead of returning false\n$export($export.S + $export.F * require('./_fails')(function () {\n  // eslint-disable-next-line no-undef\n  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });\n}), 'Reflect', {\n  defineProperty: function defineProperty(target, propertyKey, attributes) {\n    anObject(target);\n    propertyKey = toPrimitive(propertyKey, true);\n    anObject(attributes);\n    try {\n      dP.f(target, propertyKey, attributes);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n});\n","// 26.1.4 Reflect.deleteProperty(target, propertyKey)\nvar $export = require('./_export');\nvar gOPD = require('./_object-gopd').f;\nvar anObject = require('./_an-object');\n\n$export($export.S, 'Reflect', {\n  deleteProperty: function deleteProperty(target, propertyKey) {\n    var desc = gOPD(anObject(target), propertyKey);\n    return desc && !desc.configurable ? false : delete target[propertyKey];\n  }\n});\n","// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)\nvar gOPD = require('./_object-gopd');\nvar $export = require('./_export');\nvar anObject = require('./_an-object');\n\n$export($export.S, 'Reflect', {\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {\n    return gOPD.f(anObject(target), propertyKey);\n  }\n});\n","// 26.1.8 Reflect.getPrototypeOf(target)\nvar $export = require('./_export');\nvar getProto = require('./_object-gpo');\nvar anObject = require('./_an-object');\n\n$export($export.S, 'Reflect', {\n  getPrototypeOf: function getPrototypeOf(target) {\n    return getProto(anObject(target));\n  }\n});\n","// 26.1.6 Reflect.get(target, propertyKey [, receiver])\nvar gOPD = require('./_object-gopd');\nvar getPrototypeOf = require('./_object-gpo');\nvar has = require('./_has');\nvar $export = require('./_export');\nvar isObject = require('./_is-object');\nvar anObject = require('./_an-object');\n\nfunction get(target, propertyKey /* , receiver */) {\n  var receiver = arguments.length < 3 ? target : arguments[2];\n  var desc, proto;\n  if (anObject(target) === receiver) return target[propertyKey];\n  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')\n    ? desc.value\n    : desc.get !== undefined\n      ? desc.get.call(receiver)\n      : undefined;\n  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);\n}\n\n$export($export.S, 'Reflect', { get: get });\n","// 26.1.9 Reflect.has(target, propertyKey)\nvar $export = require('./_export');\n\n$export($export.S, 'Reflect', {\n  has: function has(target, propertyKey) {\n    return propertyKey in target;\n  }\n});\n","// 26.1.10 Reflect.isExtensible(target)\nvar $export = require('./_export');\nvar anObject = require('./_an-object');\nvar $isExtensible = Object.isExtensible;\n\n$export($export.S, 'Reflect', {\n  isExtensible: function isExtensible(target) {\n    anObject(target);\n    return $isExtensible ? $isExtensible(target) : true;\n  }\n});\n","// 26.1.11 Reflect.ownKeys(target)\nvar $export = require('./_export');\n\n$export($export.S, 'Reflect', { ownKeys: require('./_own-keys') });\n","// 26.1.12 Reflect.preventExtensions(target)\nvar $export = require('./_export');\nvar anObject = require('./_an-object');\nvar $preventExtensions = Object.preventExtensions;\n\n$export($export.S, 'Reflect', {\n  preventExtensions: function preventExtensions(target) {\n    anObject(target);\n    try {\n      if ($preventExtensions) $preventExtensions(target);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n});\n","// 26.1.14 Reflect.setPrototypeOf(target, proto)\nvar $export = require('./_export');\nvar setProto = require('./_set-proto');\n\nif (setProto) $export($export.S, 'Reflect', {\n  setPrototypeOf: function setPrototypeOf(target, proto) {\n    setProto.check(target, proto);\n    try {\n      setProto.set(target, proto);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n});\n","// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])\nvar dP = require('./_object-dp');\nvar gOPD = require('./_object-gopd');\nvar getPrototypeOf = require('./_object-gpo');\nvar has = require('./_has');\nvar $export = require('./_export');\nvar createDesc = require('./_property-desc');\nvar anObject = require('./_an-object');\nvar isObject = require('./_is-object');\n\nfunction set(target, propertyKey, V /* , receiver */) {\n  var receiver = arguments.length < 4 ? target : arguments[3];\n  var ownDesc = gOPD.f(anObject(target), propertyKey);\n  var existingDescriptor, proto;\n  if (!ownDesc) {\n    if (isObject(proto = getPrototypeOf(target))) {\n      return set(proto, propertyKey, V, receiver);\n    }\n    ownDesc = createDesc(0);\n  }\n  if (has(ownDesc, 'value')) {\n    if (ownDesc.writable === false || !isObject(receiver)) return false;\n    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {\n      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;\n      existingDescriptor.value = V;\n      dP.f(receiver, propertyKey, existingDescriptor);\n    } else dP.f(receiver, propertyKey, createDesc(0, V));\n    return true;\n  }\n  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);\n}\n\n$export($export.S, 'Reflect', { set: set });\n","// 21.2.5.3 get RegExp.prototype.flags()\nif (require('./_descriptors') && /./g.flags != 'g') require('./_object-dp').f(RegExp.prototype, 'flags', {\n  configurable: true,\n  get: require('./_flags')\n});\n","// @@match logic\nrequire('./_fix-re-wks')('match', 1, function (defined, MATCH, $match) {\n  // 21.1.3.11 String.prototype.match(regexp)\n  return [function match(regexp) {\n    'use strict';\n    var O = defined(this);\n    var fn = regexp == undefined ? undefined : regexp[MATCH];\n    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));\n  }, $match];\n});\n","// @@replace logic\nrequire('./_fix-re-wks')('replace', 2, function (defined, REPLACE, $replace) {\n  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)\n  return [function replace(searchValue, replaceValue) {\n    'use strict';\n    var O = defined(this);\n    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];\n    return fn !== undefined\n      ? fn.call(searchValue, O, replaceValue)\n      : $replace.call(String(O), searchValue, replaceValue);\n  }, $replace];\n});\n","// @@search logic\nrequire('./_fix-re-wks')('search', 1, function (defined, SEARCH, $search) {\n  // 21.1.3.15 String.prototype.search(regexp)\n  return [function search(regexp) {\n    'use strict';\n    var O = defined(this);\n    var fn = regexp == undefined ? undefined : regexp[SEARCH];\n    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));\n  }, $search];\n});\n","// @@split logic\nrequire('./_fix-re-wks')('split', 2, function (defined, SPLIT, $split) {\n  'use strict';\n  var isRegExp = require('./_is-regexp');\n  var _split = $split;\n  var $push = [].push;\n  var $SPLIT = 'split';\n  var LENGTH = 'length';\n  var LAST_INDEX = 'lastIndex';\n  if (\n    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||\n    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||\n    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||\n    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||\n    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||\n    ''[$SPLIT](/.?/)[LENGTH]\n  ) {\n    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group\n    // based on es5-shim implementation, need to rework it\n    $split = function (separator, limit) {\n      var string = String(this);\n      if (separator === undefined && limit === 0) return [];\n      // If `separator` is not a regex, use native split\n      if (!isRegExp(separator)) return _split.call(string, separator, limit);\n      var output = [];\n      var flags = (separator.ignoreCase ? 'i' : '') +\n                  (separator.multiline ? 'm' : '') +\n                  (separator.unicode ? 'u' : '') +\n                  (separator.sticky ? 'y' : '');\n      var lastLastIndex = 0;\n      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      var separatorCopy = new RegExp(separator.source, flags + 'g');\n      var separator2, match, lastIndex, lastLength, i;\n      // Doesn't need flags gy, but they don't hurt\n      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\\\s)', flags);\n      while (match = separatorCopy.exec(string)) {\n        // `separatorCopy.lastIndex` is not reliable cross-browser\n        lastIndex = match.index + match[0][LENGTH];\n        if (lastIndex > lastLastIndex) {\n          output.push(string.slice(lastLastIndex, match.index));\n          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG\n          // eslint-disable-next-line no-loop-func\n          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {\n            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;\n          });\n          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));\n          lastLength = match[0][LENGTH];\n          lastLastIndex = lastIndex;\n          if (output[LENGTH] >= splitLimit) break;\n        }\n        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop\n      }\n      if (lastLastIndex === string[LENGTH]) {\n        if (lastLength || !separatorCopy.test('')) output.push('');\n      } else output.push(string.slice(lastLastIndex));\n      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;\n    };\n  // Chakra, V8\n  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {\n    $split = function (separator, limit) {\n      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);\n    };\n  }\n  // 21.1.3.17 String.prototype.split(separator, limit)\n  return [function split(separator, limit) {\n    var O = defined(this);\n    var fn = separator == undefined ? undefined : separator[SPLIT];\n    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);\n  }, $split];\n});\n","'use strict';\nvar strong = require('./_collection-strong');\nvar validate = require('./_validate-collection');\nvar SET = 'Set';\n\n// 23.2 Set Objects\nmodule.exports = require('./_collection')(SET, function (get) {\n  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.2.3.1 Set.prototype.add(value)\n  add: function add(value) {\n    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);\n  }\n}, strong);\n","'use strict';\nvar $export = require('./_export');\nvar $at = require('./_string-at')(false);\n$export($export.P, 'String', {\n  // 21.1.3.3 String.prototype.codePointAt(pos)\n  codePointAt: function codePointAt(pos) {\n    return $at(this, pos);\n  }\n});\n","// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])\n'use strict';\nvar $export = require('./_export');\nvar toLength = require('./_to-length');\nvar context = require('./_string-context');\nvar ENDS_WITH = 'endsWith';\nvar $endsWith = ''[ENDS_WITH];\n\n$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {\n  endsWith: function endsWith(searchString /* , endPosition = @length */) {\n    var that = context(this, searchString, ENDS_WITH);\n    var endPosition = arguments.length > 1 ? arguments[1] : undefined;\n    var len = toLength(that.length);\n    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);\n    var search = String(searchString);\n    return $endsWith\n      ? $endsWith.call(that, search, end)\n      : that.slice(end - search.length, end) === search;\n  }\n});\n","var $export = require('./_export');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nvar fromCharCode = String.fromCharCode;\nvar $fromCodePoint = String.fromCodePoint;\n\n// length should be 1, old FF problem\n$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {\n  // 21.1.2.2 String.fromCodePoint(...codePoints)\n  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars\n    var res = [];\n    var aLen = arguments.length;\n    var i = 0;\n    var code;\n    while (aLen > i) {\n      code = +arguments[i++];\n      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');\n      res.push(code < 0x10000\n        ? fromCharCode(code)\n        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)\n      );\n    } return res.join('');\n  }\n});\n","// 21.1.3.7 String.prototype.includes(searchString, position = 0)\n'use strict';\nvar $export = require('./_export');\nvar context = require('./_string-context');\nvar INCLUDES = 'includes';\n\n$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {\n  includes: function includes(searchString /* , position = 0 */) {\n    return !!~context(this, searchString, INCLUDES)\n      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n","var $export = require('./_export');\nvar toIObject = require('./_to-iobject');\nvar toLength = require('./_to-length');\n\n$export($export.S, 'String', {\n  // 21.1.2.4 String.raw(callSite, ...substitutions)\n  raw: function raw(callSite) {\n    var tpl = toIObject(callSite.raw);\n    var len = toLength(tpl.length);\n    var aLen = arguments.length;\n    var res = [];\n    var i = 0;\n    while (len > i) {\n      res.push(String(tpl[i++]));\n      if (i < aLen) res.push(String(arguments[i]));\n    } return res.join('');\n  }\n});\n","var $export = require('./_export');\n\n$export($export.P, 'String', {\n  // 21.1.3.13 String.prototype.repeat(count)\n  repeat: require('./_string-repeat')\n});\n","// 21.1.3.18 String.prototype.startsWith(searchString [, position ])\n'use strict';\nvar $export = require('./_export');\nvar toLength = require('./_to-length');\nvar context = require('./_string-context');\nvar STARTS_WITH = 'startsWith';\nvar $startsWith = ''[STARTS_WITH];\n\n$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {\n  startsWith: function startsWith(searchString /* , position = 0 */) {\n    var that = context(this, searchString, STARTS_WITH);\n    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));\n    var search = String(searchString);\n    return $startsWith\n      ? $startsWith.call(that, search, index)\n      : that.slice(index, index + search.length) === search;\n  }\n});\n","'use strict';\n// ECMAScript 6 symbols shim\nvar global = require('./_global');\nvar has = require('./_has');\nvar DESCRIPTORS = require('./_descriptors');\nvar $export = require('./_export');\nvar redefine = require('./_redefine');\nvar META = require('./_meta').KEY;\nvar $fails = require('./_fails');\nvar shared = require('./_shared');\nvar setToStringTag = require('./_set-to-string-tag');\nvar uid = require('./_uid');\nvar wks = require('./_wks');\nvar wksExt = require('./_wks-ext');\nvar wksDefine = require('./_wks-define');\nvar enumKeys = require('./_enum-keys');\nvar isArray = require('./_is-array');\nvar anObject = require('./_an-object');\nvar isObject = require('./_is-object');\nvar toIObject = require('./_to-iobject');\nvar toPrimitive = require('./_to-primitive');\nvar createDesc = require('./_property-desc');\nvar _create = require('./_object-create');\nvar gOPNExt = require('./_object-gopn-ext');\nvar $GOPD = require('./_object-gopd');\nvar $DP = require('./_object-dp');\nvar $keys = require('./_object-keys');\nvar gOPD = $GOPD.f;\nvar dP = $DP.f;\nvar gOPN = gOPNExt.f;\nvar $Symbol = global.Symbol;\nvar $JSON = global.JSON;\nvar _stringify = $JSON && $JSON.stringify;\nvar PROTOTYPE = 'prototype';\nvar HIDDEN = wks('_hidden');\nvar TO_PRIMITIVE = wks('toPrimitive');\nvar isEnum = {}.propertyIsEnumerable;\nvar SymbolRegistry = shared('symbol-registry');\nvar AllSymbols = shared('symbols');\nvar OPSymbols = shared('op-symbols');\nvar ObjectProto = Object[PROTOTYPE];\nvar USE_NATIVE = typeof $Symbol == 'function';\nvar QObject = global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = DESCRIPTORS && $fails(function () {\n  return _create(dP({}, 'a', {\n    get: function () { return dP(this, 'a', { value: 7 }).a; }\n  })).a != 7;\n}) ? function (it, key, D) {\n  var protoDesc = gOPD(ObjectProto, key);\n  if (protoDesc) delete ObjectProto[key];\n  dP(it, key, D);\n  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);\n} : dP;\n\nvar wrap = function (tag) {\n  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n  sym._k = tag;\n  return sym;\n};\n\nvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  return it instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(it, key, D) {\n  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);\n  anObject(it);\n  key = toPrimitive(key, true);\n  anObject(D);\n  if (has(AllSymbols, key)) {\n    if (!D.enumerable) {\n      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;\n      D = _create(D, { enumerable: createDesc(0, false) });\n    } return setSymbolDesc(it, key, D);\n  } return dP(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P) {\n  anObject(it);\n  var keys = enumKeys(P = toIObject(P));\n  var i = 0;\n  var l = keys.length;\n  var key;\n  while (l > i) $defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P) {\n  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key) {\n  var E = isEnum.call(this, key = toPrimitive(key, true));\n  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;\n  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {\n  it = toIObject(it);\n  key = toPrimitive(key, true);\n  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;\n  var D = gOPD(it, key);\n  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it) {\n  var names = gOPN(toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);\n  } return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it) {\n  var IS_OP = it === ObjectProto;\n  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);\n  } return result;\n};\n\n// 19.4.1.1 Symbol([description])\nif (!USE_NATIVE) {\n  $Symbol = function Symbol() {\n    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');\n    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n    var $set = function (value) {\n      if (this === ObjectProto) $set.call(OPSymbols, value);\n      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, createDesc(1, value));\n    };\n    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });\n    return wrap(tag);\n  };\n  redefine($Symbol[PROTOTYPE], 'toString', function toString() {\n    return this._k;\n  });\n\n  $GOPD.f = $getOwnPropertyDescriptor;\n  $DP.f = $defineProperty;\n  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;\n  require('./_object-pie').f = $propertyIsEnumerable;\n  require('./_object-gops').f = $getOwnPropertySymbols;\n\n  if (DESCRIPTORS && !require('./_library')) {\n    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n\n  wksExt.f = function (name) {\n    return wrap(wks(name));\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });\n\nfor (var es6Symbols = (\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);\n\nfor (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);\n\n$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function (key) {\n    return has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(sym) {\n    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');\n    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;\n  },\n  useSetter: function () { setter = true; },\n  useSimple: function () { setter = false; }\n});\n\n$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';\n})), 'JSON', {\n  stringify: function stringify(it) {\n    var args = [it];\n    var i = 1;\n    var replacer, $replacer;\n    while (arguments.length > i) args.push(arguments[i++]);\n    $replacer = replacer = args[1];\n    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\n    if (!isArray(replacer)) replacer = function (key, value) {\n      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);\n      if (!isSymbol(value)) return value;\n    };\n    args[1] = replacer;\n    return _stringify.apply($JSON, args);\n  }\n});\n\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\nsetToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\nsetToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\nsetToStringTag(global.JSON, 'JSON', true);\n","'use strict';\nvar $export = require('./_export');\nvar $typed = require('./_typed');\nvar buffer = require('./_typed-buffer');\nvar anObject = require('./_an-object');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nvar toLength = require('./_to-length');\nvar isObject = require('./_is-object');\nvar ArrayBuffer = require('./_global').ArrayBuffer;\nvar speciesConstructor = require('./_species-constructor');\nvar $ArrayBuffer = buffer.ArrayBuffer;\nvar $DataView = buffer.DataView;\nvar $isView = $typed.ABV && ArrayBuffer.isView;\nvar $slice = $ArrayBuffer.prototype.slice;\nvar VIEW = $typed.VIEW;\nvar ARRAY_BUFFER = 'ArrayBuffer';\n\n$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });\n\n$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {\n  // 24.1.3.1 ArrayBuffer.isView(arg)\n  isView: function isView(it) {\n    return $isView && $isView(it) || isObject(it) && VIEW in it;\n  }\n});\n\n$export($export.P + $export.U + $export.F * require('./_fails')(function () {\n  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;\n}), ARRAY_BUFFER, {\n  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)\n  slice: function slice(start, end) {\n    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix\n    var len = anObject(this).byteLength;\n    var first = toAbsoluteIndex(start, len);\n    var fin = toAbsoluteIndex(end === undefined ? len : end, len);\n    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));\n    var viewS = new $DataView(this);\n    var viewT = new $DataView(result);\n    var index = 0;\n    while (first < fin) {\n      viewT.setUint8(index++, viewS.getUint8(first++));\n    } return result;\n  }\n});\n\nrequire('./_set-species')(ARRAY_BUFFER);\n","require('./_typed-array')('Float32', 4, function (init) {\n  return function Float32Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","require('./_typed-array')('Float64', 8, function (init) {\n  return function Float64Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","require('./_typed-array')('Int16', 2, function (init) {\n  return function Int16Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","require('./_typed-array')('Int32', 4, function (init) {\n  return function Int32Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","require('./_typed-array')('Int8', 1, function (init) {\n  return function Int8Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","require('./_typed-array')('Uint16', 2, function (init) {\n  return function Uint16Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","require('./_typed-array')('Uint32', 4, function (init) {\n  return function Uint32Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","require('./_typed-array')('Uint8', 1, function (init) {\n  return function Uint8Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","require('./_typed-array')('Uint8', 1, function (init) {\n  return function Uint8ClampedArray(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n}, true);\n","'use strict';\nvar each = require('./_array-methods')(0);\nvar redefine = require('./_redefine');\nvar meta = require('./_meta');\nvar assign = require('./_object-assign');\nvar weak = require('./_collection-weak');\nvar isObject = require('./_is-object');\nvar fails = require('./_fails');\nvar validate = require('./_validate-collection');\nvar WEAK_MAP = 'WeakMap';\nvar getWeak = meta.getWeak;\nvar isExtensible = Object.isExtensible;\nvar uncaughtFrozenStore = weak.ufstore;\nvar tmp = {};\nvar InternalMap;\n\nvar wrapper = function (get) {\n  return function WeakMap() {\n    return get(this, arguments.length > 0 ? arguments[0] : undefined);\n  };\n};\n\nvar methods = {\n  // 23.3.3.3 WeakMap.prototype.get(key)\n  get: function get(key) {\n    if (isObject(key)) {\n      var data = getWeak(key);\n      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);\n      return data ? data[this._i] : undefined;\n    }\n  },\n  // 23.3.3.5 WeakMap.prototype.set(key, value)\n  set: function set(key, value) {\n    return weak.def(validate(this, WEAK_MAP), key, value);\n  }\n};\n\n// 23.3 WeakMap Objects\nvar $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);\n\n// IE11 WeakMap frozen keys fix\nif (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {\n  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);\n  assign(InternalMap.prototype, methods);\n  meta.NEED = true;\n  each(['delete', 'has', 'get', 'set'], function (key) {\n    var proto = $WeakMap.prototype;\n    var method = proto[key];\n    redefine(proto, key, function (a, b) {\n      // store frozen objects on internal weakmap shim\n      if (isObject(a) && !isExtensible(a)) {\n        if (!this._f) this._f = new InternalMap();\n        var result = this._f[key](a, b);\n        return key == 'set' ? this : result;\n      // store all the rest on native weakmap\n      } return method.call(this, a, b);\n    });\n  });\n}\n","'use strict';\nvar weak = require('./_collection-weak');\nvar validate = require('./_validate-collection');\nvar WEAK_SET = 'WeakSet';\n\n// 23.4 WeakSet Objects\nrequire('./_collection')(WEAK_SET, function (get) {\n  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.4.3.1 WeakSet.prototype.add(value)\n  add: function add(value) {\n    return weak.def(validate(this, WEAK_SET), value, true);\n  }\n}, weak, false, true);\n","'use strict';\n// https://github.com/tc39/Array.prototype.includes\nvar $export = require('./_export');\nvar $includes = require('./_array-includes')(true);\n\n$export($export.P, 'Array', {\n  includes: function includes(el /* , fromIndex = 0 */) {\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nrequire('./_add-to-unscopables')('includes');\n","// https://github.com/tc39/proposal-object-values-entries\nvar $export = require('./_export');\nvar $entries = require('./_object-to-array')(true);\n\n$export($export.S, 'Object', {\n  entries: function entries(it) {\n    return $entries(it);\n  }\n});\n","// https://github.com/tc39/proposal-object-getownpropertydescriptors\nvar $export = require('./_export');\nvar ownKeys = require('./_own-keys');\nvar toIObject = require('./_to-iobject');\nvar gOPD = require('./_object-gopd');\nvar createProperty = require('./_create-property');\n\n$export($export.S, 'Object', {\n  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {\n    var O = toIObject(object);\n    var getDesc = gOPD.f;\n    var keys = ownKeys(O);\n    var result = {};\n    var i = 0;\n    var key, desc;\n    while (keys.length > i) {\n      desc = getDesc(O, key = keys[i++]);\n      if (desc !== undefined) createProperty(result, key, desc);\n    }\n    return result;\n  }\n});\n","// https://github.com/tc39/proposal-object-values-entries\nvar $export = require('./_export');\nvar $values = require('./_object-to-array')(false);\n\n$export($export.S, 'Object', {\n  values: function values(it) {\n    return $values(it);\n  }\n});\n","'use strict';\n// https://github.com/tc39/proposal-string-pad-start-end\nvar $export = require('./_export');\nvar $pad = require('./_string-pad');\nvar userAgent = require('./_user-agent');\n\n// https://github.com/zloirock/core-js/issues/280\n$export($export.P + $export.F * /Version\\/10\\.\\d+(\\.\\d+)? Safari\\//.test(userAgent), 'String', {\n  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {\n    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);\n  }\n});\n","'use strict';\n// https://github.com/tc39/proposal-string-pad-start-end\nvar $export = require('./_export');\nvar $pad = require('./_string-pad');\nvar userAgent = require('./_user-agent');\n\n// https://github.com/zloirock/core-js/issues/280\n$export($export.P + $export.F * /Version\\/10\\.\\d+(\\.\\d+)? Safari\\//.test(userAgent), 'String', {\n  padStart: function padStart(maxLength /* , fillString = ' ' */) {\n    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);\n  }\n});\n","var $iterators = require('./es6.array.iterator');\nvar getKeys = require('./_object-keys');\nvar redefine = require('./_redefine');\nvar global = require('./_global');\nvar hide = require('./_hide');\nvar Iterators = require('./_iterators');\nvar wks = require('./_wks');\nvar ITERATOR = wks('iterator');\nvar TO_STRING_TAG = wks('toStringTag');\nvar ArrayValues = Iterators.Array;\n\nvar DOMIterables = {\n  CSSRuleList: true, // TODO: Not spec compliant, should be false.\n  CSSStyleDeclaration: false,\n  CSSValueList: false,\n  ClientRectList: false,\n  DOMRectList: false,\n  DOMStringList: false,\n  DOMTokenList: true,\n  DataTransferItemList: false,\n  FileList: false,\n  HTMLAllCollection: false,\n  HTMLCollection: false,\n  HTMLFormElement: false,\n  HTMLSelectElement: false,\n  MediaList: true, // TODO: Not spec compliant, should be false.\n  MimeTypeArray: false,\n  NamedNodeMap: false,\n  NodeList: true,\n  PaintRequestList: false,\n  Plugin: false,\n  PluginArray: false,\n  SVGLengthList: false,\n  SVGNumberList: false,\n  SVGPathSegList: false,\n  SVGPointList: false,\n  SVGStringList: false,\n  SVGTransformList: false,\n  SourceBufferList: false,\n  StyleSheetList: true, // TODO: Not spec compliant, should be false.\n  TextTrackCueList: false,\n  TextTrackList: false,\n  TouchList: false\n};\n\nfor (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {\n  var NAME = collections[i];\n  var explicit = DOMIterables[NAME];\n  var Collection = global[NAME];\n  var proto = Collection && Collection.prototype;\n  var key;\n  if (proto) {\n    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);\n    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\n    Iterators[NAME] = ArrayValues;\n    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);\n  }\n}\n","var $export = require('./_export');\nvar $task = require('./_task');\n$export($export.G + $export.B, {\n  setImmediate: $task.set,\n  clearImmediate: $task.clear\n});\n","// ie9- setTimeout & setInterval additional parameters fix\nvar global = require('./_global');\nvar $export = require('./_export');\nvar userAgent = require('./_user-agent');\nvar slice = [].slice;\nvar MSIE = /MSIE .\\./.test(userAgent); // <- dirty ie9- check\nvar wrap = function (set) {\n  return function (fn, time /* , ...args */) {\n    var boundArgs = arguments.length > 2;\n    var args = boundArgs ? slice.call(arguments, 2) : false;\n    return set(boundArgs ? function () {\n      // eslint-disable-next-line no-new-func\n      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);\n    } : fn, time);\n  };\n};\n$export($export.G + $export.B + $export.F * MSIE, {\n  setTimeout: wrap(global.setTimeout),\n  setInterval: wrap(global.setInterval)\n});\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n","//////////////////////\n// xtend\n//////////////////////\n\nimport {XtUtil} from '../../../scripts/xtend-utils';\n","/*! xtend (https://getxtend.com/)\n@copyright (c) 2017 - 2018 Riccardo Caroli\n@license MIT (https://github.com/minimit/xtend-library/blob/master/LICENSE) */\n\n'use strict';\n\nimport 'babel-polyfill';\n\nimport {XtToggle, XtDrop, XtOverlay, XtFade, XtSticky} from './xtend';\n\n//////////////////////\n// constructor\n//////////////////////\n\nconst XtUtil = {};\n\n//////////////////////\n// properties\n//////////////////////\n\n// Xt currents based on namespace (so shared between Xt objects)\n\nXtUtil.currents = {};\n\n//////////////////////\n// methods\n//////////////////////\n\n/**\n * init all data-xt classes\n */\nXtUtil.initAll = function (container = document) {\n  // xt-toggle\n  Array.from(container.querySelectorAll('[data-xt-toggle]')).forEach(function (el) {\n    new XtToggle(el);\n  });\n  Array.from(container.querySelectorAll('[data-xt-drop]')).forEach(function (el) {\n    new XtDrop(el);\n  });\n  Array.from(container.querySelectorAll('[data-xt-overlay]')).forEach(function (el) {\n    new XtOverlay(el);\n  });\n  Array.from(container.querySelectorAll('[data-xt-fade]')).forEach(function (el) {\n    new XtFade(el);\n  });\n  Array.from(container.querySelectorAll('[data-xt-sticky]')).forEach(function (el) {\n    new XtSticky(el);\n  });\n};\n\n/**\n * request animation frame\n * @returns {Number} animationFrameID\n * USAGE: let animationFrame = XtUtil.requestAnimationFrame.call(window, function () {});\n */\nXtUtil.requestAnimationFrame = function () {\n  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) {\n    window.setTimeout(callback, 1000 / 60);\n  };\n}();\n\n/**\n * cancel animation frame\n * USAGE: XtUtil.cancelAnimationFrame.call(window, animationFrameID);\n */\nXtUtil.cancelAnimationFrame = function () {\n  return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function (callback) {\n    window.clearTimeout(id);\n  };\n}();\n\n/**\n * Check if event target is inside elements\n * @param {Event} e Event to check target\n * @param {NodeList|Array} targets Elements to check inside\n * @return {Boolean}\n */\nXtUtil.checkInside = function (e, targets) {\n  let result = false;\n  for (let t of targets) {\n    if (e.target === t || t.contains(e.target)) {\n      result = true;\n    }\n  }\n  return result;\n};\n\n/**\n * Check if event target is outside elements\n * @param {Event} e Event to check target\n * @param {NodeList|Array} targets Elements to check Outside\n * @return {Boolean}\n */\nXtUtil.checkOutside = function (e, targets) {\n  let result = true;\n  for (let t of targets) {\n    if (e.target === t || t.contains(e.target)) {\n      result = false;\n    }\n  }\n  return result;\n};\n\n/**\n * Get scrollbar width of document\n * @returns {Number} Scrollbar width\n */\nXtUtil.scrollbarWidth = function () {\n  // add outer\n  let outer = document.createElement('div');\n  outer.style.visibility = 'hidden';\n  outer.style.width = '100px';\n  outer.style.msOverflowStyle = 'scrollbar'; // needed for WinJS apps\n  document.body.appendChild(outer);\n  let widthNoScroll = outer.offsetWidth;\n  // force scrollbars\n  outer.style.overflow = 'scroll';\n  // add inner\n  let inner = document.createElement('div');\n  inner.style.width = '100%';\n  outer.appendChild(inner);\n  let widthWithScroll = inner.offsetWidth;\n  // remove\n  outer.parentNode.removeChild(outer);\n  return widthNoScroll - widthWithScroll;\n};\n\n/**\n * Get unique id\n * @returns {String} Unique id\n */\nXtUtil.getUniqueID = function () {\n  XtUtil.uid = XtUtil.uid !== undefined ? XtUtil.uid : 0;\n  return 'unique-id-' + (XtUtil.uid++);\n};\n\n/**\n * Get unique number\n * @returns {Number} Unique number\n */\nXtUtil.getUniqueNum = function () {\n  XtUtil.unumber = XtUtil.unumber !== undefined ? XtUtil.unumber : 0;\n  return XtUtil.unumber++;\n};\n\n/**\n * Merge objects\n * @param {Array} arr Array of objects to merge\n * @returns {Object} Merged object\n */\nXtUtil.merge = function (arr) {\n  let final = {};\n  for (let obj of arr) {\n    for (let [key, value] of Object.entries(obj)) {\n      final[key] = value;\n    }\n  }\n  return final;\n};\n\n/**\n * Make an array when element is only one\n * @param {Object|Array} element\n * @returns {Array}\n */\nXtUtil.arrSingle = function (element) {\n  if (element.length === undefined) {\n    let arr = new Array(1);\n    arr[0] = element;\n    return arr;\n  } else {\n    return element;\n  }\n};\n\n/**\n * Create DOM element from html string\n * @param {String} str Html string (only 1 root html tag)\n * @return {Node|HTMLElement} DOM element\n */\nXtUtil.createElement = function (str) {\n  let div = document.createElement('div');\n  div.innerHTML = str.trim();\n  return div.firstChild;\n};\n\n/**\n * Query element's parents\n * @param {Node|HTMLElement} element Child element\n * @param {String} query Query parents\n * @return {Array} Parents elements by query\n */\nXtUtil.parents = function (element, query) {\n  let parents = [];\n  while (element = element.parentElement.closest(query)) {\n    parents.push(element);\n  }\n  return parents;\n};\n\n/**\n * dataStorage\n * https://stackoverflow.com/questions/29222027/vanilla-alternative-to-jquery-data-function-any-native-javascript-alternati\n * USAGE: XtUtil.dataStorage.put(element, 'key', value);\n */\nXtUtil.dataStorage = {\n  _storage: new WeakMap(),\n  put: function (element, key, obj) {\n    if (!this._storage.has(key)) {\n      this._storage.set(element, new Map());\n    }\n    this._storage.get(element).set(key, obj);\n    return this._storage.get(element).get(key);\n  },\n  get: function (element, key) {\n    return this._storage.get(element).get(key);\n  },\n  has: function (element, key) {\n    return this._storage.get(element).has(key);\n  },\n  remove: function (element, key) {\n    let ret = this._storage.get(element).delete(key);\n    if (!this._storage.get(key).size === false) {\n      this._storage.delete(element);\n    }\n    return ret;\n  }\n};\n\n//////////////////////\n// api\n//////////////////////\n\nwindow.XtUtil = XtUtil;\nexport {XtUtil};\n\n//////////////////////\n// closest polyfill\n// https://github.com/jonathantneal/closest\n// USAGE: element.closest(query);\n//////////////////////\n\n(function (ElementProto) {\n  if (typeof ElementProto.matches !== 'function') {\n    ElementProto.matches = ElementProto.msMatchesSelector || ElementProto.mozMatchesSelector || ElementProto.webkitMatchesSelector || function matches(selector) {\n      var element = this;\n      var elements = (element.document || element.ownerDocument).querySelectorAll(selector);\n      var index = 0;\n      while (elements[index] && elements[index] !== element) {\n        ++index;\n      }\n      return Boolean(elements[index]);\n    };\n  }\n  if (typeof ElementProto.closest !== 'function') {\n    ElementProto.closest = function closest(selector) {\n      var element = this;\n      while (element && element.nodeType === 1) {\n        if (element.matches(selector)) {\n          return element;\n        }\n        element = element.parentNode;\n      }\n      return null;\n    };\n  }\n})(window.Element.prototype);\n\n//////////////////////\n// scope polyfill\n// https://github.com/jonathantneal/element-qsa-scope\n// USAGE: querySelectorAll(':scope > .selector');\n//////////////////////\n\n(function (ElementPrototype) {\n  try {\n    // test for scope support\n    document.querySelector(':scope *');\n  } catch (error) {\n    // scope regex\n    let scope = /:scope(?![\\w-])/gi;\n    // polyfill Element#querySelector\n    let querySelectorWithScope = polyfill(ElementPrototype.querySelector);\n    ElementPrototype.querySelector = function querySelector(selectors) {\n      return querySelectorWithScope.apply(this, arguments);\n    };\n    // polyfill Element#querySelectorAll\n    let querySelectorAllWithScope = polyfill(ElementPrototype.querySelectorAll);\n    ElementPrototype.querySelectorAll = function querySelectorAll(selectors) {\n      return querySelectorAllWithScope.apply(this, arguments);\n    };\n    // polyfill Element#matches\n    if (ElementPrototype.matches) {\n      let matchesWithScope = polyfill(ElementPrototype.matches);\n      ElementPrototype.matches = function matches(selectors) {\n        return matchesWithScope.apply(this, arguments);\n      };\n    }\n    // polyfill Element#closest\n    if (ElementPrototype.closest) {\n      let closestWithScope = polyfill(ElementPrototype.closest);\n      ElementPrototype.closest = function closest(selectors) {\n        return closestWithScope.apply(this, arguments);\n      };\n    }\n    function polyfill(qsa) {\n      return function (selectors) {\n        // whether the selectors contain :scope\n        let hasScope = selectors && scope.test(selectors);\n        if (hasScope) {\n          // fallback attribute\n          let attr = 'q' + Math.floor(Math.random() * 9000000) + 1000000;\n          // replace :scope with the fallback attribute\n          arguments[0] = selectors.replace(scope, '[' + attr + ']');\n          // add the fallback attribute\n          this.setAttribute(attr, '');\n          // results of the qsa\n          let elementOrNodeList = qsa.apply(this, arguments);\n          // remove the fallback attribute\n          this.removeAttribute(attr);\n          // return the results of the qsa\n          return elementOrNodeList;\n        } else {\n          // return the results of the qsa\n          return qsa.apply(this, arguments);\n        }\n      };\n    }\n  }\n})(Element.prototype);\n\n//////////////////////\n// CustomEvent polyfill\n// https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent\n//////////////////////\n\n(function () {\n  if (typeof window.CustomEvent === \"function\") {\n    return false;\n  }\n\n  function CustomEvent(event, params) {\n    params = params || {bubbles: false, cancelable: false, detail: undefined};\n    let evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n    return evt;\n  }\n\n  CustomEvent.prototype = window.Event.prototype;\n  window.CustomEvent = CustomEvent;\n})();\n\n//////////////////////\n// scrollingElement polyfill\n// https://github.com/yangg/scrolling-element\n//////////////////////\n\n(function () {\n  if (document.scrollingElement) {\n    return;\n  }\n  let element = null;\n\n  function scrollingElement() {\n    if (element) {\n      return element;\n    } else if (document.body.scrollTop) {\n      // speed up if scrollTop > 0\n      return (element = document.body);\n    }\n    let iframe = document.createElement('iframe');\n    iframe.style.height = '1px';\n    document.documentElement.appendChild(iframe);\n    let doc = iframe.contentWindow.document;\n    doc.write('<!DOCTYPE html><div style=\"height:9999em\">x</div>');\n    doc.close();\n    let isCompliant = doc.documentElement.scrollHeight > doc.body.scrollHeight;\n    iframe.parentNode.removeChild(iframe);\n    return (element = isCompliant ? document.documentElement : document.body);\n  }\n\n  Object.defineProperty(document, 'scrollingElement', {\n    get: scrollingElement\n  })\n})();\n\n//////////////////////\n// append polyfill\n// https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/append\n//////////////////////\n\n(function (arr) {\n  arr.forEach(function (item) {\n    if (item.hasOwnProperty('append')) {\n      return;\n    }\n    Object.defineProperty(item, 'append', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: function append() {\n        let argArr = Array.prototype.slice.call(arguments),\n          docFrag = document.createDocumentFragment();\n\n        argArr.forEach(function (argItem) {\n          let isNode = argItem instanceof Node;\n          docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));\n        });\n\n        this.appendChild(docFrag);\n      }\n    });\n  });\n})([Element.prototype, Document.prototype, DocumentFragment.prototype]);\n\n//////////////////////\n// before polyfill\n// https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/before\n//////////////////////\n\n(function (arr) {\n  arr.forEach(function (item) {\n    if (item.hasOwnProperty('before')) {\n      return;\n    }\n    Object.defineProperty(item, 'before', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: function before() {\n        let argArr = Array.prototype.slice.call(arguments),\n          docFrag = document.createDocumentFragment();\n\n        argArr.forEach(function (argItem) {\n          let isNode = argItem instanceof Node;\n          docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));\n        });\n\n        this.parentNode.insertBefore(docFrag, this);\n      }\n    });\n  });\n})([Element.prototype, CharacterData.prototype, DocumentType.prototype]);\n\n//////////////////////\n// entries polyfill\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\n//////////////////////\n\n(function (obj) {\n  if (!obj.entries) {\n    obj.entries = function (obj) {\n      let ownProps = Object.keys(obj),\n        i = ownProps.length,\n        resArray = new Array(i); // preallocate the Array\n      while (i--)\n        resArray[i] = [ownProps[i], obj[ownProps[i]]];\n\n      return resArray;\n    };\n  }\n})(Object);\n\n//////////////////////\n// Array.from polyfill\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\n//////////////////////\n\n(function (arr) {\n  if (!arr.from) {\n    arr.from = (function () {\n      var toStr = Object.prototype.toString;\n      var isCallable = function (fn) {\n        return typeof fn === 'function' || toStr.call(fn) === '[object Function]';\n      };\n      var toInteger = function (value) {\n        var number = Number(value);\n        if (isNaN(number)) {\n          return 0;\n        }\n        if (number === 0 || !isFinite(number)) {\n          return number;\n        }\n        return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));\n      };\n      var maxSafeInteger = Math.pow(2, 53) - 1;\n      var toLength = function (value) {\n        var len = toInteger(value);\n        return Math.min(Math.max(len, 0), maxSafeInteger);\n      };\n\n      // The length property of the from method is 1.\n      return function from(arrayLike/*, mapFn, thisArg */) {\n        // 1. Let C be the this value.\n        var C = this;\n\n        // 2. Let items be ToObject(arrayLike).\n        var items = Object(arrayLike);\n\n        // 3. ReturnIfAbrupt(items).\n        if (arrayLike == null) {\n          throw new TypeError('Array.from requires an array-like object - not null or undefined');\n        }\n\n        // 4. If mapfn is undefined, then let mapping be false.\n        var mapFn = arguments.length > 1 ? arguments[1] : void undefined;\n        var T;\n        if (typeof mapFn !== 'undefined') {\n          // 5. else\n          // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.\n          if (!isCallable(mapFn)) {\n            throw new TypeError('Array.from: when provided, the second argument must be a function');\n          }\n\n          // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.\n          if (arguments.length > 2) {\n            T = arguments[2];\n          }\n        }\n\n        // 10. Let lenValue be Get(items, \"length\").\n        // 11. Let len be ToLength(lenValue).\n        var len = toLength(items.length);\n\n        // 13. If IsConstructor(C) is true, then\n        // 13. a. Let A be the result of calling the [[Construct]] internal method\n        // of C with an argument list containing the single item len.\n        // 14. a. Else, Let A be ArrayCreate(len).\n        var A = isCallable(C) ? Object(new C(len)) : new Array(len);\n\n        // 16. Let k be 0.\n        var k = 0;\n        // 17. Repeat, while k < len (also steps a - h)\n        var kValue;\n        while (k < len) {\n          kValue = items[k];\n          if (mapFn) {\n            A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);\n          } else {\n            A[k] = kValue;\n          }\n          k += 1;\n        }\n        // 18. Let putStatus be Put(A, \"length\", len, true).\n        A.length = len;\n        // 20. Return A.\n        return A;\n      };\n    }());\n  }\n})(Array);\n","/* xtend (https://getxtend.com/)\n@copyright (c) 2017 - 2018 Riccardo Caroli\n@license MIT (https://github.com/minimit/xtend-library/blob/master/LICENSE) */\n\n'use strict';\n\nimport 'babel-polyfill';\n\nimport {XtUtil} from './xtend-utils';\n\n//////////////////////\n// Xt\n//////////////////////\n\nclass Xt {\n\n  /**\n   * constructor\n   * @param {Node|HTMLElement} object Base node\n   * @param {Object} jsOptions User options\n   * @param {String} attr Attribute name with json options\n   * @constructor\n   */\n  constructor(object, jsOptions = {}, attr) {\n    this.object = object;\n    if (this.object) {\n      this.defaults = this.constructor.defaults;\n      // js options\n      this.options = XtUtil.merge([this.defaults, jsOptions]);\n      // markup options\n      let markupOptions = this.object.getAttribute(attr);\n      this.options = XtUtil.merge([this.options, markupOptions ? JSON.parse(markupOptions) : {}]);\n      // classes\n      if (this.options.class) {\n        this.options.classes = [...this.options.class.split(' ')];\n      }\n      // init\n      this.initSetup();\n      this.initScope();\n      this.initEvents();\n      this.initAria();\n    }\n  }\n\n  //////////////////////\n  // init\n  //////////////////////\n\n  /**\n   * setup namespace, container and options\n   */\n  initSetup() {\n    let self = this;\n    let options = self.options;\n    // setup (based on xtend mode)\n    if (options.targets && options.targets.indexOf('#') !== -1) {\n      // xtend all mode\n      this.mode = 'all';\n      this.container = document.documentElement;\n      options.max = Infinity;\n      this.namespace = options.targets.toString() + '-' + options.classes.toString();\n    } else {\n      // xtend unique mode\n      this.mode = 'unique';\n      this.container = this.object;\n      this.namespace = XtUtil.getUniqueID();\n    }\n    // final namespace\n    this.namespace = this.namespace.replace(/\\W+/g, '');\n    // currents array based on namespace (so shared between Xt objects)\n    if (!this.getCurrents()) {\n      this.setCurrents([]);\n    }\n  }\n\n  /**\n   * init elements, targets and currents\n   */\n  initScope() {\n    let self = this;\n    let options = self.options;\n    // elements\n    this.elements = [];\n    if (options.elements) {\n      this.elements = XtUtil.arrSingle(this.container.querySelectorAll(options.elements));\n    }\n    if (!this.elements.length) {\n      this.elements = XtUtil.arrSingle(this.object);\n      // @FIX on next frame set all elements querying the namespace\n      XtUtil.requestAnimationFrame.call(window, function () {\n        let namespaceQuery = '[data-xt-id=' + self.namespace + ']';\n        self.elements = XtUtil.arrSingle(document.querySelectorAll(namespaceQuery));\n      });\n    }\n    // targets\n    if (options.targets) {\n      let arr = Array.from(this.container.querySelectorAll(options.targets));\n      arr = arr.filter(x => !XtUtil.parents(x, options.targets).length); // filter out parent\n      this.targets = arr;\n    }\n    // appendTo\n    if (options.appendTo) {\n      let appendToTarget = document.querySelectorAll(options.appendTo);\n      if (appendToTarget.length) {\n        this.targets.forEach(function (el) {\n          appendToTarget[0].appendChild(el);\n        });\n      }\n    }\n    // @FIX set namespace for next frame\n    for (let el of this.elements) {\n      el.setAttribute('data-xt-id', self.namespace);\n    }\n    // currents\n    XtUtil.requestAnimationFrame.call(window, function () {\n      if (self.elements.length) {\n        // activate options.class\n        for (let el of self.elements) {\n          if (el.classList.contains(...options.classes)) {\n            el.classList.remove(...options.classes); // remove to activate also targets\n            self.eventOn(el);\n          }\n        }\n        // if currents < min\n        let todo = options.min - self.getCurrents().length;\n        if (todo) {\n          for (let i = 0; i < todo; i++) {\n            self.eventOn(self.elements[i]);\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * init aria\n   */\n  initAria() {\n    if (this.targets) {\n      for (let tr of this.targets) {\n        // aria-label\n        let headers = tr.querySelectorAll('h1, h2, h3, h4, h5, h6');\n        let label = headers.length ? headers : this.getElementsFromTarget(tr);\n        if (label.length) {\n          label = label[0].innerText.replace(/\\s+/g, ' ').trim();\n          tr.setAttribute('aria-label', label);\n        }\n      }\n    }\n  }\n\n  /**\n   * init events\n   */\n  initEvents() {\n    let self = this;\n    let options = self.options;\n    // events\n    for (let el of this.elements) {\n      if (options.on) {\n        // handler\n        let xtOnHandler = XtUtil.dataStorage.put(el, 'xtOnHandler', self.eventOnHandler.bind(self).bind(self, el));\n        // event\n        let events = [...options.on.split(' ')];\n        for (let event of events) {\n          el.removeEventListener(event, xtOnHandler);\n          el.addEventListener(event, xtOnHandler);\n        }\n        // listener\n        el.addEventListener('on.trigger', xtOnHandler);\n      }\n      if (options.off) {\n        // handler\n        let xtOffHandler = XtUtil.dataStorage.put(el, 'xtOffHandler', self.eventOffHandler.bind(self).bind(self, el));\n        // event\n        let events = [...options.off.split(' ')];\n        for (let event of events) {\n          el.removeEventListener(event, xtOffHandler);\n          el.addEventListener(event, xtOffHandler);\n        }\n        // listener\n        el.addEventListener('off.trigger', xtOffHandler);\n      }\n    }\n    // listener\n    for (let tr of this.targets) {\n      let el = this.getElementsFromTarget(tr)[0];\n      if (el) {\n        // handler\n        let xtOnHandler = XtUtil.dataStorage.put(el, 'xtOnHandler', self.eventOnHandler.bind(self).bind(self, el));\n        let xtOffHandler = XtUtil.dataStorage.put(el, 'xtOffHandler', self.eventOffHandler.bind(self).bind(self, el));\n        // listener\n        tr.addEventListener('on.trigger', xtOnHandler);\n        tr.addEventListener('off.trigger', xtOffHandler);\n      }\n    }\n    // auto\n    if (options.auto) {\n      this.auto();\n      // focus and blur\n      window.addEventListener('focus', function () {\n        self.auto();\n      });\n      window.addEventListener('blur', function () {\n        self.autoStop();\n      });\n    }\n  }\n\n  /**\n   * element on handler\n   * @param {Node|HTMLElement} element\n   * @param {Event} e\n   */\n  eventOnHandler(element, e) {\n    let eventLimit = this.container.querySelectorAll('.event-limit');\n    if (eventLimit.length) {\n      if (XtUtil.checkOutside(e, eventLimit)) {\n        this.eventOn(element);\n      }\n    } else {\n      this.eventOn(element);\n    }\n    // auto\n    if (this.options.autoPause) {\n      this.autoPause();\n    } else if (this.options.auto) {\n      this.auto();\n    }\n  }\n\n  /**\n   * element off handler\n   * @param {Node|HTMLElement} element\n   * @param {Event} e\n   */\n  eventOffHandler(element, e) {\n    let eventLimit = this.container.querySelectorAll('.event-limit');\n    if (eventLimit.length) {\n      if (XtUtil.checkOutside(e, eventLimit)) {\n        this.eventOff(element);\n      }\n    } else {\n      this.eventOff(element);\n    }\n  }\n\n  /**\n   * set auto change\n   * @param {Boolean} instant\n   */\n  auto(instant = false) {\n    let self = this;\n    let options = self.options;\n    // auto\n    this.autoStop();\n    let time = !instant ? options.auto : 0;\n    self.autoInterval = setInterval(function () {\n      if (!options.autoAlways && self.object.offsetParent === null) { // if not :visible don't change\n        return false;\n      }\n      self.autoCurrent = self.autoCurrent !== undefined ? self.autoCurrent + 1 : 0;\n      self.autoCurrent = self.autoCurrent >= self.elements.length ? 0 : self.autoCurrent;\n      self.eventOn(self.elements[self.autoCurrent]);\n    }, time);\n  }\n\n  /**\n   * set autoPause change\n   * @param {Boolean} instant\n   */\n  autoPause(instant = false) {\n    let self = this;\n    let options = self.options;\n    // autoPause\n    this.autoStop();\n    let time = !instant ? options.autoPause : 0;\n    if (time !== 'stop') {\n      self.autoPauseTimeout = setTimeout(function () {\n        self.auto(true);\n        self.auto();\n      }, time);\n    }\n  }\n\n  /**\n   * stop auto change\n   */\n  autoStop() {\n    clearInterval(this.autoInterval);\n    clearTimeout(this.autoPauseTimeout);\n  }\n\n  //////////////////////\n  // utils\n  //////////////////////\n\n  /**\n   * choose which elements to activate/deactivate (based on xtend mode and containers)\n   * @param {Node|HTMLElement} element Element that triggered interaction\n   * @returns {Object} object.all and object.single\n   */\n  getElements(element) {\n    if (!this.elements || !this.elements.length) {\n      return {all: [], single: null};\n    }\n    if (this.mode === 'all') {\n      // choose all elements\n      return {all: this.elements, single: this.elements[0]};\n    } else if (this.mode === 'unique') {\n      // choose element by group\n      let group = element.getAttribute('data-group');\n      if (group) {\n        // all group elements if group\n        let groupElements = Array.from(this.elements).filter(x => x.getAttribute('data-group') === group);\n        let final = XtUtil.arrSingle(groupElements);\n        return {all: final, single: final[0]};\n      } else {\n        // element if not group\n        let final = element;\n        return {all: XtUtil.arrSingle(final), single: final};\n      }\n    }\n  }\n\n  /**\n   * choose which targets to activate/deactivate (based on xtend mode and containers)\n   * @param {Node|HTMLElement} element Element that triggered interaction\n   * @returns {Array}\n   */\n  getTargets(element) {\n    if (!this.targets || !this.targets.length) {\n      return [];\n    }\n    if (this.mode === 'all') {\n      // choose all targets\n      return this.targets;\n    } else if (this.mode === 'unique') {\n      // choose only target by group\n      let group = element.getAttribute('data-group');\n      let groupElements = Array.from(this.elements).filter(x => x.getAttribute('data-group') === group);\n      let groupTargets = Array.from(this.targets).filter(x => x.getAttribute('data-group') === group);\n      let final;\n      if (group) {\n        // all group targets if group\n        final = groupTargets;\n        return XtUtil.arrSingle(final);\n      } else {\n        // not group targets by index if not group\n        let index = groupElements.findIndex(x => x === element);\n        final = groupTargets[index];\n        return XtUtil.arrSingle(final);\n      }\n    }\n  }\n\n  /**\n   * choose which elements to activate/deactivate from target (based on xtend mode and containers)\n   * @param {Node|HTMLElement} element Target to trigger interaction on\n   * @returns {Array}\n   */\n  getElementsFromTarget(target) {\n    if (!this.elements || !this.elements.length) {\n      return [];\n    }\n    // choose only target by group\n    let group = target.getAttribute('data-group');\n    let groupElements = Array.from(this.elements).filter(x => x.getAttribute('data-group') === group);\n    let groupTargets = Array.from(this.targets).filter(x => x.getAttribute('data-group') === group);\n    let final;\n    if (group) {\n      // all group targets if group\n      final = groupElements;\n      return XtUtil.arrSingle(final);\n    } else {\n      // not group targets by index if not group\n      let index = groupTargets.findIndex(x => x === target);\n      final = groupElements[index];\n      return XtUtil.arrSingle(final);\n    }\n  }\n\n  /**\n   * additional elements to activate/deactivate\n   * @returns {NodeList|Array}\n   */\n  getAdditional() {\n    if (!this.options.additional) {\n      return [];\n    } else {\n      return this.object.querySelectorAll(this.options.additional);\n    }\n  }\n\n  /**\n   * get currents based on namespace (so shared between Xt objects)\n   * @returns {Array}\n   */\n  getCurrents() {\n    return XtUtil.currents[this.namespace];\n  }\n\n  /**\n   * set currents based on namespace (so shared between Xt objects)\n   * @param {Array} arr\n   */\n  setCurrents(arr) {\n    XtUtil.currents[this.namespace] = arr;\n  }\n\n  /**\n   * add current based on namespace (so shared between Xt objects)\n   * @param {Node|HTMLElement} element To be added\n   */\n  addCurrent(element) {\n    let arr = XtUtil.currents[this.namespace];\n    arr.push(element);\n  }\n\n  /**\n   * remove currents based on namespace (so shared between Xt objects)\n   * @param {Node|HTMLElement} element To be removed\n   */\n  removeCurrent(element) {\n    XtUtil.currents[this.namespace] = XtUtil.currents[this.namespace].filter(x => x !== element);\n  }\n\n  //////////////////////\n  // events\n  //////////////////////\n\n  /**\n   * check element on\n   * @param {Node|HTMLElement} element To be activated\n   * @returns {Boolean} If eventOn changes activation\n   */\n  checkOn(element) {\n    if ((!element.classList.contains(...this.options.classes) || element.classList.contains('off-block')) && !element.classList.contains('on-block')) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * check element off\n   * @param {Node|HTMLElement} element To be activated\n   * @returns {Boolean} If eventOff changes activation\n   */\n  checkOff(element) {\n    // if currents < min\n    let todo = this.options.min - this.getCurrents().length;\n    if (!todo) {\n      return false;\n    }\n    if ((element.classList.contains(...this.options.classes) || element.classList.contains('on-block')) && !element.classList.contains('off-block')) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * element on\n   * @param {Node|HTMLElement} element To be activated\n   */\n  eventOn(element) {\n    let self = this;\n    let options = self.options;\n    // activate or deactivate\n    if (this.checkOn(element)) {\n      let fElements = this.getElements(element);\n      this.addCurrent(fElements.single);\n      let targets = this.getTargets(element);\n      let additional = this.getAdditional();\n      let activationDelay = {\n        elements: function () {\n          self.activationOn(fElements.all, fElements, 'elements');\n        },\n        targets: function () {\n          self.activationOn(targets, fElements, 'targets');\n        },\n        additional: function () {\n          self.activationOn(additional, fElements, 'additional');\n        },\n      };\n      // set autoCurrent\n      if (options.auto) {\n        let index = 0;\n        for (let [i, el] of self.elements.entries()) {\n          if (el === element) {\n            index = i;\n            break;\n          }\n        }\n        self.autoCurrent = index;\n      }\n      // if currents > max\n      let currents = this.getCurrents();\n      if (currents.length > options.max) {\n        this.eventOff(currents[0], activationDelay);\n      } else {\n        activationDelay.elements();\n        activationDelay.targets();\n        activationDelay.additional();\n      }\n    } else if (options.toggle) {\n      // toggle\n      this.eventOff(element);\n    }\n  }\n\n  /**\n   * element off\n   * @param {Node|HTMLElement} element To be deactivated\n   * @param {Object} activationDelay Object with delayed activations\n   */\n  eventOff(element, activationDelay = null) {\n    // deactivate\n    if (this.checkOff(element)) {\n      let fElements = this.getElements(element);\n      this.removeCurrent(fElements.single);\n      this.activationOff(fElements.all, fElements, 'elements', activationDelay);\n      let targets = this.getTargets(element);\n      this.activationOff(targets, fElements, 'targets', activationDelay);\n      let additional = this.getAdditional();\n      this.activationOff(additional, fElements, 'additional', activationDelay);\n    }\n  }\n\n  /**\n   * element on activation\n   * @param {NodeList|Array} els Elements to be activated\n   * @param {Object} fElements Additional elements\n   * @param {String} type Type of elements\n   */\n  activationOn(els, fElements, type) {\n    let self = this;\n    let options = self.options;\n    // activate\n    let activate = function (self, el, fElements, type) {\n      el.classList.add(...options.classes);\n      el.classList.remove('out');\n      self.activationOnAnimate(el, type);\n      // specials\n      if (type === 'targets') {\n        self.specialClassHtmlOn();\n        self.specialBackdrop(el);\n        self.specialCenterOn(el);\n        self.specialMiddleOn(el);\n        self.specialCollapseOn(el);\n        self.specialCloseOn(el, fElements.single);\n        self.specialScrollbarOn();\n      }\n      // dispatch\n      el.dispatchEvent(new CustomEvent('on'));\n    };\n    // delay\n    for (let el of els) {\n      el.classList.remove('off-block');\n      clearTimeout(el.dataset.xtDelayTimeout);\n      clearTimeout(el.dataset.xtAnimTimeout);\n      let delay = el.dataset.xtOnDelay;\n      if (delay) {\n        el.classList.add('on-block');\n        el.dataset.xtDelayTimeout = setTimeout(function (self, el, fElements, type) {\n          el.classList.remove('on-block');\n          activate(self, el, fElements, type);\n        }, parseFloat(delay), self, el, fElements, type).toString();\n      } else {\n        activate(self, el, fElements, type);\n      }\n    }\n  }\n\n  /**\n   * element off activation\n   * @param {NodeList|Array} els Elements to be deactivated\n   * @param {Object} fElements Additional elements\n   * @param {String} type Type of elements\n   * @param {Object} activationDelay Object with delayed activations\n   */\n  activationOff(els, fElements, type, activationDelay) {\n    let self = this;\n    let options = self.options;\n    // deactivate\n    let deactivate = function (self, el, fElements, type, activationDelay) {\n      el.classList.remove(...options.classes);\n      el.classList.add('out');\n      self.activationOffAnimate(el, type, activationDelay);\n      // activationDelay\n      if (activationDelay && activationDelay[type] && !activationDelay[type + 'done']) {\n        if (options.instant && options.instant[type]) {\n          activationDelay[type]();\n          activationDelay[type + 'done'] = true;\n        }\n      }\n      // specials\n      if (type === 'targets') {\n        self.specialClassHtmlOff();\n        self.specialCollapseOff(el);\n        self.specialCloseOff(el);\n      }\n      // dispatch\n      el.dispatchEvent(new CustomEvent('off'));\n    };\n    // delay\n    for (let el of els) {\n      el.classList.remove('on-block');\n      clearTimeout(el.dataset.xtDelayTimeout);\n      clearTimeout(el.dataset.xtAnimTimeout);\n      let delay = el.dataset.xtOffDelay;\n      if (delay) {\n        el.classList.add('off-block');\n        el.dataset.xtDelayTimeout = setTimeout(function (self, el, fElements, type, activationDelay) {\n          el.classList.remove('off-block');\n          deactivate(self, el, fElements, type, activationDelay);\n        }, parseFloat(delay), self, el, fElements, type, activationDelay).toString();\n      } else {\n        deactivate(self, el, fElements, type, activationDelay);\n      }\n    }\n  }\n\n  /**\n   * element on animation\n   * @param {Node|HTMLElement} el Element to be animated\n   * @param {String} type Type of element\n   */\n  activationOnAnimate(el, type) {\n    // onDone\n    let onDone = function (el, type) {\n      // collapse-width and collapse-height\n      if (el.classList.contains('collapse-height')) {\n        el.style.height = 'auto';\n      }\n      if (el.classList.contains('collapse-width')) {\n        el.style.width = 'auto';\n      }\n    };\n    // delay onDone\n    let timing = this.activationTiming(el);\n    clearTimeout(el.dataset.xtAnimTimeout);\n    if (!timing) {\n      onDone(el, type);\n    } else {\n      el.dataset.xtAnimTimeout = setTimeout(function (el, type) {\n        onDone(el, type);\n      }, timing, el, type).toString();\n    }\n  }\n\n  /**\n   * element off animation\n   * @param {Node|HTMLElement} el Element to be animated\n   * @param {String} type Type of element\n   * @param {Object} activationDelay Object with delayed activations\n   */\n  activationOffAnimate(el, type, activationDelay) {\n    let self = this;\n    let options = self.options;\n    // onDone\n    let onDone = function (el, type) {\n      el.classList.remove('out');\n      // specials\n      if (type === 'targets') {\n        self.specialScrollbarOff();\n      }\n      // activationDelay\n      if (activationDelay && activationDelay[type] && !activationDelay[type + 'done']) {\n        if (!options.instant || !options.instant[type]) {\n          activationDelay[type]();\n          activationDelay[type + 'done'] = true;\n        }\n      }\n    };\n    // delay onDone\n    let timing = this.activationTiming(el);\n    clearTimeout(el.dataset.xtAnimTimeout);\n    if (!timing) {\n      onDone(el, type);\n    } else {\n      el.dataset.xtAnimTimeout = setTimeout(function (el, type) {\n        onDone(el, type);\n      }, timing, el, type).toString();\n    }\n  }\n\n  /**\n   * get transition or animation timing\n   * @param {Node|HTMLElement} el To be animated\n   * @returns {Number} Time in milliseconds\n   */\n  activationTiming(el) {\n    let self = this;\n    let options = self.options;\n    // timing\n    let timing = options.timing;\n    if (timing !== undefined) {\n      return timing;\n    } else {\n      let style = getComputedStyle(el);\n      let transition = parseFloat(style.transitionDuration) + parseFloat(style.transitionDelay);\n      let animation = parseFloat(style.animationDuration) + parseFloat(style.animationDelay);\n      if (transition || animation) {\n        timing = Math.max(transition, animation);\n      }\n      return timing * 1000;\n    }\n  }\n\n  //////////////////////\n  // activation specials\n  //////////////////////\n\n  /**\n   * add html class\n   */\n  specialClassHtmlOn() {\n    let self = this;\n    let options = self.options;\n    //\n    if (options.classHtml) {\n      let container = document.documentElement;\n      container.classList.add(...options.classHtml.split(' '));\n    }\n  }\n\n  /**\n   * remove html class\n   */\n  specialClassHtmlOff() {\n    let self = this;\n    let options = self.options;\n    //\n    if (options.classHtml) {\n      let container = document.documentElement;\n      container.classList.remove(...options.classHtml.split(' '));\n    }\n  }\n\n  /**\n   * backdrop append to element\n   * @param {Node|HTMLElement} el Element\n   */\n  specialBackdrop(el) {\n    let self = this;\n    let options = self.options;\n    //\n    if (options.backdrop) {\n      let elements;\n      if (options.backdrop === 'object') {\n        elements = XtUtil.arrSingle(this.object);\n      } else if (options.backdrop === 'targets') {\n        elements = XtUtil.arrSingle(el);\n      } else {\n        elements = el.querySelectorAll(options.backdrop);\n        if (!elements.length) {\n          elements = this.object.querySelectorAll(options.backdrop);\n        }\n      }\n      for (let element of elements) {\n        let backdrop = element.querySelectorAll('.xt-backdrop');\n        if (!backdrop.length) {\n          backdrop = XtUtil.createElement('<div class=\"xt-backdrop\"></div>');\n          element.append(backdrop);\n        }\n      }\n    }\n  }\n\n  /**\n   * center position on activation\n   * @param {Node|HTMLElement} el Element\n   */\n  specialCenterOn(el) {\n    if (el.classList.contains('drop-center')) {\n      let add = this.object.clientWidth;\n      let remove = el.clientWidth;\n      el.style.left = ((add - remove) / 2) + 'px';\n    }\n  }\n\n  /**\n   * middle position on activation\n   * @param {Node|HTMLElement} el Element\n   */\n  specialMiddleOn(el) {\n    if (el.classList.contains('drop-middle')) {\n      let add = this.object.clientHeight;\n      let remove = el.clientHeight;\n      el.style.top = ((add - remove) / 2) + 'px';\n    }\n  }\n\n  /**\n   * open collapse on activation\n   * @param {Node|HTMLElement} el Element\n   */\n  specialCollapseOn(el) {\n    if (el.classList.contains('collapse-height')) {\n      el.classList.add('no-transition');\n      el.style.height = 'auto';\n      el.style.paddingTop = '';\n      el.style.paddingBottom = '';\n      let h = el.clientHeight + 'px';\n      let pt = el.style.paddingTop;\n      let pb = el.style.paddingBottom;\n      XtUtil.requestAnimationFrame.call(window, function () {\n        el.style.height = '0';\n        el.style.paddingTop = '0';\n        el.style.paddingBottom = '0';\n        XtUtil.requestAnimationFrame.call(window, function () {\n          el.classList.remove('no-transition');\n          el.style.height = h;\n          el.style.paddingTop = pt;\n          el.style.paddingBottom = pb;\n        });\n      });\n    }\n    if (el.classList.contains('collapse-width')) {\n      el.style.width = 'auto';\n      el.style.paddingLeft = '';\n      el.style.paddingRight = '';\n      let w = el.clientHeight + 'px';\n      let pl = el.style.paddingLeft;\n      let pr = el.style.paddingRight;\n      XtUtil.requestAnimationFrame.call(window, function () {\n        el.style.width = '0';\n        el.style.paddingLeft = '0';\n        el.style.paddingRight = '0';\n        XtUtil.requestAnimationFrame.call(window, function () {\n          el.classList.remove('no-transition');\n          el.style.width = w;\n          el.style.paddingLeft = pl;\n          el.style.paddingRight = pr;\n        });\n      });\n    }\n  }\n\n  /**\n   * close collapse on deactivation\n   * @param {Node|HTMLElement} el Element\n   */\n  specialCollapseOff(el) {\n    if (el.classList.contains('collapse-height')) {\n      let h = el.clientHeight + 'px';\n      let pt = el.style.paddingTop;\n      let pb = el.style.paddingBottom;\n      XtUtil.requestAnimationFrame.call(window, function () {\n        el.style.height = h;\n        el.style.paddingTop = pt;\n        el.style.paddingBottom = pb;\n        XtUtil.requestAnimationFrame.call(window, function () {\n          el.style.height = '0';\n          el.style.paddingTop = '0';\n          el.style.paddingBottom = '0';\n        });\n      });\n    }\n    if (el.classList.contains('collapse-width')) {\n      let w = el.clientWidth + 'px';\n      let pl = el.style.paddingLeft;\n      let pr = el.style.paddingRight;\n      XtUtil.requestAnimationFrame.call(window, function () {\n        el.style.width = w;\n        el.style.paddingLeft = pl;\n        el.style.paddingRight = pr;\n        XtUtil.requestAnimationFrame.call(window, function () {\n          el.style.width = '0';\n          el.style.paddingLeft = '0';\n          el.style.paddingRight = '0';\n        });\n      });\n    }\n  }\n\n  /**\n   * add close events on element\n   * @param {Node|HTMLElement} el Element\n   * @param {Node|HTMLElement} single Element to toggle\n   */\n  specialCloseOn(el, single) {\n    let self = this;\n    let options = self.options;\n    // closeInside\n    if (options.closeInside) {\n      let closeElements = el.querySelectorAll(options.closeInside);\n      XtUtil.requestAnimationFrame.call(window, function () {\n        for (let closeElement of closeElements) {\n          // handler\n          let specialCloseOnHandler = XtUtil.dataStorage.put(el, 'specialCloseOnHandler', self.specialCloseOnHandler.bind(self).bind(self, closeElement, single));\n          // event\n          closeElement.removeEventListener('click', specialCloseOnHandler);\n          closeElement.addEventListener('click', specialCloseOnHandler);\n        }\n      });\n    }\n    // closeOutside\n    if (options.closeOutside) {\n      let closeElements = document.querySelectorAll(options.closeOutside);\n      XtUtil.requestAnimationFrame.call(window, function () {\n        for (let closeElement of closeElements) {\n          // handler\n          let specialCloseOffHandler = XtUtil.dataStorage.put(el, 'specialCloseOffHandler', self.specialCloseOffHandler.bind(self).bind(self, el, single));\n          // event\n          closeElement.removeEventListener('click', specialCloseOffHandler);\n          closeElement.addEventListener('click', specialCloseOffHandler);\n        }\n      });\n    }\n  }\n\n  /**\n   * remove close events on element\n   * @param {Node|HTMLElement} el Element\n   */\n  specialCloseOff(el) {\n    let self = this;\n    let options = self.options;\n    // closeInside\n    if (options.closeInside) {\n      let closeElements = el.querySelectorAll(options.closeInside);\n      for (let closeElement of closeElements) {\n        // handler\n        let specialCloseOnHandler = XtUtil.dataStorage.get(el, 'specialCloseOnHandler');\n        closeElement.removeEventListener('click', specialCloseOnHandler);\n      }\n    }\n    // closeOutside\n    if (options.closeOutside) {\n      let closeElements = document.querySelectorAll(options.closeOutside);\n      for (let closeElement of closeElements) {\n        let specialCloseOffHandler = XtUtil.dataStorage.get(el, 'specialCloseOffHandler');\n        closeElement.removeEventListener('click', specialCloseOffHandler);\n      }\n    }\n  }\n\n  /**\n   * element on handler\n   * @param {Node|HTMLElement} checkEl\n   * @param {Node|HTMLElement} single\n   * @param {Event} e\n   */\n  specialCloseOnHandler(checkEl, single, e) {\n    if (XtUtil.checkInside(e, XtUtil.arrSingle(checkEl))) {\n      this.eventOff(single);\n    }\n  }\n\n  /**\n   * element off handler\n   * @param {Node|HTMLElement} checkEl\n   * @param {Node|HTMLElement} single\n   * @param {Event} e\n   */\n  specialCloseOffHandler(checkEl, single, e) {\n    if (XtUtil.checkOutside(e, XtUtil.arrSingle(checkEl))) {\n      this.eventOff(single);\n    }\n  }\n\n  /**\n   * scrollbar activation\n   */\n  specialScrollbarOn() {\n    let self = this;\n    let options = self.options;\n    //\n    if (options.scrollbar) {\n      let elements;\n      let width = XtUtil.scrollbarWidth();\n      // check fixed\n      elements = document.querySelectorAll('.xt-check-fixed > *');\n      for (let element of elements) {\n        let style = getComputedStyle(element);\n        if (style.position === 'fixed') {\n          element.classList.add('xt-fixed');\n        } else {\n          element.classList.remove('xt-fixed');\n        }\n      }\n      // fixed\n      elements = document.querySelectorAll('.xt-fixed');\n      for (let element of elements) {\n        element.style.paddingRight = '';\n        if (self.normalizeWidth(element.clientWidth) === '') {\n          let style = getComputedStyle(element);\n          let padding = style.paddingRight;\n          let str = 'calc(' + padding + ' + ' + width + 'px)';\n          element.classList.add('no-transition');\n          XtUtil.requestAnimationFrame.call(window, function () {\n            element.style.paddingRight = str;\n            XtUtil.requestAnimationFrame.call(window, function () {\n              element.classList.remove('no-transition');\n            });\n          });\n        }\n      }\n      // backdrop\n      elements = document.querySelectorAll('.xt-backdrop');\n      for (let element of elements) {\n        element.style.right = width + 'px';\n      }\n      // scroll\n      let container = document.documentElement;\n      container.style.paddingRight = width + 'px';\n      container.classList.add('xt-scrollbar');\n    }\n  }\n\n  /**\n   * scrollbar deactivation\n   */\n  specialScrollbarOff() {\n    let self = this;\n    let options = self.options;\n    //\n    if (options.scrollbar) {\n      let elements;\n      // scroll\n      let container = document.documentElement;\n      container.style.paddingRight = '';\n      container.classList.remove('xt-scrollbar');\n      // fixed\n      elements = document.querySelectorAll('.xt-fixed');\n      for (let element of elements) {\n        element.classList.add('no-transition');\n        XtUtil.requestAnimationFrame.call(window, function () {\n          element.style.paddingRight = '';\n          XtUtil.requestAnimationFrame.call(window, function () {\n            element.classList.remove('no-transition');\n          });\n        });\n      }\n      // backdrop\n      elements = document.querySelectorAll('.xt-backdrop');\n      for (let element of elements) {\n        element.style.right = '';\n      }\n    }\n  }\n\n  /**\n   * if full width return '' else return value in px\n   * @param {Number|String} width\n   * @returns {String} Value in px\n   */\n  normalizeWidth(width) {\n    width = parseFloat(width);\n    if (width + XtUtil.scrollbarWidth() >= window.innerWidth) {\n      width = '';\n    } else {\n      width += 'px';\n    }\n    return width;\n  }\n\n}\n\n// default\n\nXt.defaults = {\n  \"auto\": false,\n  \"autoPause\": false,\n  \"autoAlways\": false\n};\n\n// export\n\nwindow.Xt = Xt;\nexport {Xt};\n\n//////////////////////\n// XtToggle\n//////////////////////\n\nclass XtToggle extends Xt {\n\n  /**\n   * constructor\n   * @param {Node|HTMLElement} object Base node\n   * @param {Object} jsOptions User options\n   * @constructor\n   */\n  constructor(object, jsOptions = {}) {\n    super(object, jsOptions, 'data-xt-toggle');\n  }\n\n}\n\n// default\n\nXtToggle.defaults = {\n  \"elements\": \":scope > a, :scope > button\",\n  \"targets\": \":scope > [class^=\\\"toggle-\\\"], :scope > [class*=\\\" toggle-\\\"]\",\n  \"class\": \"active\",\n  \"instant\": {\"elements\": true},\n  \"on\": \"click\",\n  \"toggle\": true,\n  \"min\": 0,\n  \"max\": 1\n};\n\n// export\n\nwindow.XtToggle = XtToggle;\nexport {XtToggle};\n\n//////////////////////\n// XtDrop\n//////////////////////\n\nclass XtDrop extends Xt {\n\n  /**\n   * constructor\n   * @param {Node|HTMLElement} object Base node\n   * @param {Object} jsOptions User options\n   * @constructor\n   */\n  constructor(object, jsOptions = {}) {\n    super(object, jsOptions, 'data-xt-drop');\n  }\n\n  /**\n   * init aria\n   */\n  initAria() {\n    if (this.targets) {\n      for (let tr of this.targets) {\n        // aria-label\n        if (this.options.additional) {\n          let label = this.getAdditional();\n          if (label.length) {\n            label = label[0].innerText.replace(/\\s+/g, ' ').trim();\n            tr.setAttribute('aria-label', label);\n          }\n        }\n      }\n    }\n  }\n\n}\n\n// default\n\nXtDrop.defaults = {\n  \"elements\": \":scope\",\n  \"targets\": \":scope > .drop\",\n  \"additional\": \":scope > a, :scope > button\",\n  \"class\": \"active\",\n  \"instant\": {\"elements\": true},\n  \"on\": \"click\",\n  \"toggle\": true,\n  \"min\": 0,\n  \"max\": 1,\n  \"closeOutside\": \"body\"\n};\n\n// export\n\nwindow.XtDrop = XtDrop;\nexport {XtDrop};\n\n//////////////////////\n// XtOverlay\n//////////////////////\n\nclass XtOverlay extends Xt {\n\n  /**\n   * constructor\n   * @param {Node|HTMLElement} object Base node\n   * @param {Object} jsOptions User options\n   * @constructor\n   */\n  constructor(object, jsOptions = {}) {\n    super(object, jsOptions, 'data-xt-overlay');\n  }\n\n  /**\n   * init aria\n   */\n  initAria() {\n    super.initAria();\n    if (this.targets) {\n      for (let tr of this.targets) {\n        // role\n        tr.setAttribute('role', 'dialog');\n        tr.setAttribute('aria-modal', 'true');\n      }\n    }\n  }\n\n}\n\n// default\n\nXtOverlay.defaults = {\n  \"elements\": \":scope > a, :scope > button\",\n  \"targets\": \":scope > .overlay-outer\",\n  \"class\": \"active\",\n  \"instant\": {\"elements\": true},\n  \"on\": \"click\",\n  \"toggle\": true,\n  \"min\": 0,\n  \"max\": 1,\n  \"appendTo\": \"body\",\n  \"backdrop\": \"targets\",\n  \"classHtml\": \"xt-overlay\",\n  \"closeInside\": \".overlay-dismiss, :scope > .xt-backdrop, :scope .overlay-inner > .btn-close\",\n  \"scrollbar\": true\n};\n\n// export\n\nwindow.XtOverlay = XtOverlay;\nexport {XtOverlay};\n\n//////////////////////\n// XtSticky\n//////////////////////\n\nclass XtSticky extends Xt {\n\n  /**\n   * constructor\n   * @param {Node|HTMLElement} object Base node\n   * @param {Object} jsOptions User options\n   * @constructor\n   */\n  constructor(object, jsOptions = {}) {\n    super(object, jsOptions, 'data-xt-sticky');\n  }\n\n  //////////////////////\n  // init\n  //////////////////////\n\n  /**\n   * init elements, targets and currents\n   */\n  initScope() {\n    super.initScope();\n    // mode\n    this.mode = 'all';\n    // container\n    this.container = XtUtil.parents(this.object, '.xt-container');\n    if (!this.container.length) {\n      this.container = XtUtil.createElement('<div class=\"xt-container xt-check-fixed\"></div>');\n      this.object.before(this.container);\n      this.container.append(this.object);\n      this.container = XtUtil.parents(this.object, '.xt-container');\n    }\n    // targets\n    this.targets = this.container[0].querySelectorAll('.xt-clone');\n    if (!this.targets.length) {\n      this.targets = this.object.cloneNode(true);\n      this.targets.classList.add('xt-clone');\n      this.targets.setAttribute('aria-hidden', 'true');\n      for (let elId of this.targets.querySelectorAll('[id]')) {\n        elId.setAttribute('id', elId.getAttribute('id') + '-clone');\n      }\n      for (let elName of this.targets.querySelectorAll('[name]')) {\n        elName.setAttribute('name', elName.getAttribute('name') + '-clone');\n      }\n      this.container[0].append(this.targets);\n    }\n    this.targets = XtUtil.arrSingle(this.targets);\n    // xt-fixed\n    this.object.classList.add('xt-fixed');\n    // hide\n    if (this.options.hide === 'down') {\n      this.object.classList.add('sticky-hide-down');\n    } else {\n      this.object.classList.remove('sticky-hide-down');\n    }\n    if (this.options.hide === 'up') {\n      this.object.classList.add('sticky-hide-up');\n    } else {\n      this.object.classList.remove('sticky-hide-up');\n    }\n    // z-index\n    this.unique = XtUtil.getUniqueNum();\n    this.object.style.zIndex = '' + (100 - this.unique);\n  }\n\n  /**\n   * init events\n   */\n  initEvents() {\n    let self = this;\n    let options = self.options;\n    // events\n    if (options.on) {\n      // handler\n      let stickyHandler = XtUtil.dataStorage.put(window, 'stickyHandler', self.eventOnHandler.bind(self));\n      // event\n      let events = [...options.on.split(' ')];\n      for (let event of events) {\n        window.removeEventListener(event, stickyHandler);\n        window.addEventListener(event, stickyHandler);\n      }\n      window.addEventListener('on.sticky', stickyHandler);\n    }\n    // trigger initial\n    window.dispatchEvent(new CustomEvent('on.sticky'));\n  }\n\n  /**\n   * element on handler\n   * @param {Node|HTMLElement} element\n   * @param {Event} e\n   */\n  eventOnHandler(element, e) {\n    this.eventScroll(this.object);\n  }\n\n  //////////////////////\n  // events\n  //////////////////////\n\n  /**\n   * window scroll\n   * @param {Node|HTMLElement} element To be activated or deactivated\n   */\n  eventScroll(element) {\n    let self = this;\n    let options = self.options;\n    // vars\n    let anim = true;\n    let hide = false;\n    let scrollInverse = false;\n    let add = 0;\n    let addHide = 0;\n    let windowHeight = window.innerHeight;\n    let el = self.object;\n    let rectElTop = el.getBoundingClientRect().top;\n    let heightEl = parseFloat(getComputedStyle(el).height);\n    let heightTarget = parseFloat(getComputedStyle(self.targets[0]).height);\n    let rectContainerTop = self.container[0].getBoundingClientRect().top;\n    let scrollingElement = document.scrollingElement;\n    let scrollHeight = scrollingElement.scrollHeight;\n    let scrollTop = scrollingElement.scrollTop;\n    let scrollTopOld = self.scrollTopOld;\n    // direction\n    if (scrollTop < scrollTopOld) {\n      el.classList.remove('sticky-down');\n      el.classList.add('sticky-up');\n      scrollInverse = true;\n    } else {\n      el.classList.add('sticky-down');\n      el.classList.remove('sticky-up');\n    }\n    // hide\n    if (options.hide === 'down') {\n      if (!scrollInverse) {\n        addHide = heightTarget;\n      }\n    }\n    if (options.hide === 'up') {\n      if (scrollInverse) {\n        addHide = heightTarget;\n      }\n    }\n    // scroll\n    let top = self.eventScrollPos(options.limit['top'] || self.targets, scrollTop, rectContainerTop);\n    let bottom = self.eventScrollPos(options.limit['bottom'], scrollTop, Infinity);\n    if (options.position === 'top') {\n      bottom -= heightTarget;\n    }\n    if (options.position === 'bottom') {\n      top -= windowHeight - heightTarget;\n      bottom = Math.abs(scrollHeight - windowHeight - bottom);\n    }\n    // contain and add\n    let addTop = 0;\n    let addBottom = 0;\n    if (options.contain) {\n      if (options.contain['top']) {\n        let addTopObj = self.eventScrollHeight(options.contain['top'], scrollInverse);\n        addTop = addTopObj.val;\n        if (addTop !== null && addTop > rectContainerTop) {\n          add = addTop;\n          if (!addTopObj.foundHide) {\n            anim = false;\n          }\n        } else {\n          addTop = null;\n        }\n      }\n      if (options.contain['bottom']) {\n        addBottom = self.eventScrollPos(options.contain['bottom']);\n        if (addBottom !== null && addBottom < heightEl + addTop) {\n          add = addBottom - heightEl;\n          anim = false;\n        } else {\n          addBottom = null;\n        }\n      }\n    }\n    // save real add for calculation\n    el.dataset.xtAddSticky = add.toString();\n    // activation\n    let checkTop = scrollTop >= top - add + addHide;\n    let checkBottom = scrollTop < bottom + add - addHide;\n    if (checkTop && checkBottom) {\n      // inside\n      self.eventOn(element);\n      // hide\n      if (addHide) {\n        hide = true;\n      }\n    } else {\n      // outside\n      self.eventOff(element);\n    }\n    // after active\n    if (el.classList.contains('active')) {\n      // hide\n      if (hide) {\n        add = -heightEl;\n        if (!el.classList.contains('sticky-hide')) {\n          el.classList.add('sticky-hide');\n          el.dispatchEvent(new CustomEvent('sticky.hide'));\n        }\n      } else {\n        if (el.classList.contains('sticky-hide')) {\n          el.classList.remove('sticky-hide');\n          el.dispatchEvent(new CustomEvent('sticky.show'));\n        }\n      }\n    } else {\n      // reset\n      add = 0;\n      anim = false;\n    }\n    // anim\n    if (anim && scrollTopOld !== undefined) {\n      if (!el.classList.contains('sticky-anim')) {\n        el.classList.add('sticky-anim');\n      }\n    } else {\n      if (el.classList.contains('sticky-anim')) {\n        el.classList.remove('sticky-anim');\n      }\n    }\n    // top and bottom\n    if (!checkTop) {\n      if (!el.classList.contains('sticky-top')) {\n        el.classList.add('sticky-top');\n      }\n    } else {\n      if (el.classList.contains('sticky-top')) {\n        el.classList.remove('sticky-top');\n      }\n    }\n    if (!checkBottom) {\n      if (!el.classList.contains('sticky-bottom')) {\n        el.classList.add('sticky-bottom');\n      }\n    } else {\n      if (el.classList.contains('sticky-bottom')) {\n        el.classList.remove('sticky-bottom');\n      }\n    }\n    // set add\n    if (add !== self.addOld) {\n      el.classList.add('no-transition');\n      if (self.addOld !== undefined) {\n        el.style[options.position] = rectElTop + 'px';\n      }\n      XtUtil.cancelAnimationFrame.call(window, self.eventFrame);\n      self.eventFrame = XtUtil.requestAnimationFrame.call(window, function () {\n        el.classList.remove('no-transition');\n        el.style[options.position] = add + 'px';\n      });\n    }\n    // fix position fixed width 100% of parent\n    let width = self.normalizeWidth(self.container[0].clientWidth);\n    if (el.style.width !== width) {\n      el.style.width = width;\n    }\n    // save for direction\n    self.addOld = add;\n    self.scrollTopOld = scrollTop;\n  }\n\n  /**\n   * get position of option\n   * @param {String|Number|Element} option\n   * @param {Number} val Default value\n   * @param {Number} scrollTop Window's scrollTop\n   * @returns {Number} value Option's position (px)\n   */\n  eventScrollPos(option, scrollTop = 0, val = null) {\n    if (!isNaN(parseFloat(option))) {\n      val = option;\n    } else {\n      let elements = Array.isArray(option) ? option : document.querySelectorAll(option);\n      if (elements.length) {\n        let found = false;\n        val = 0;\n        for (let el of elements) {\n          let addSticky = parseFloat(el.dataset.xtAddSticky);\n          if (addSticky) { // if sticky-hide get real add\n            let style = getComputedStyle(el);\n            if (style.display !== 'none') {\n              val += addSticky;\n              found = true;\n            }\n          } else {\n            let rect = el.getBoundingClientRect();\n            val += rect.top;\n            found = true;\n          }\n        }\n        if (found) {\n          val += scrollTop;\n        } else {\n          val = null;\n        }\n      }\n    }\n    return val;\n  }\n\n  /**\n   * get height of option\n   * @param {String|Number|Element} option\n   * @param {Boolean} scrollInverse\n   * @param {Number} val Default value\n   * @returns {Object} obj Option's height (px) and if found hide element\n   */\n  eventScrollHeight(option, scrollInverse, val = null) {\n    let foundHide = false;\n    if (!isNaN(parseFloat(option))) {\n      val = option;\n    } else {\n      let elements = Array.isArray(option) ? option : document.querySelectorAll(option);\n      if (elements.length) {\n        for (let el of elements) {\n          if (el.classList.contains('sticky-hide-down') && el.classList.contains('active')) {\n            if (scrollInverse) {\n              val += el.clientHeight;\n              foundHide = true;\n            }\n          } else if (el.classList.contains('sticky-hide-up') && el.classList.contains('active')) {\n            if (!scrollInverse) {\n              val += el.clientHeight;\n              foundHide = true;\n            }\n          } else {\n            val += el.clientHeight;\n          }\n        }\n      }\n    }\n    return {val: val, foundHide: foundHide};\n  }\n\n}\nalert('cccc');\n// default\n\nXtSticky.defaults = {\n  \"class\": \"active\",\n  \"on\": \"scroll resize\",\n  \"min\": 0,\n  \"max\": Infinity,\n  \"position\": \"top\",\n  \"limit\": {\"bottom\": Infinity},\n  \"contain\": false,\n  \"hide\": false\n};\n\n// export\n\nwindow.XtSticky = XtSticky;\nexport {XtSticky};\n\n//////////////////////\n// XtFade\n//////////////////////\n\nclass XtFade extends Xt {\n\n  /**\n   * constructor\n   * @param {Node|HTMLElement} object Base node\n   * @param {Object} jsOptions User options\n   * @constructor\n   */\n  constructor(object, jsOptions = {}) {\n    super(object, jsOptions, 'data-xt-fade');\n  }\n\n  //////////////////////\n  // init\n  //////////////////////\n\n  /**\n   * init events\n   */\n  initEvents() {\n    let self = this;\n    let options = self.options;\n    // events\n    if (options.on) {\n      // handler\n      let fadeHandler = XtUtil.dataStorage.put(window, 'fadeHandler', self.eventOnHandler.bind(self));\n      // event\n      let events = [...options.on.split(' ')];\n      for (let event of events) {\n        window.removeEventListener(event, fadeHandler);\n        window.addEventListener(event, fadeHandler);\n      }\n      window.addEventListener('on.fade', fadeHandler);\n    }\n    // trigger initial\n    window.dispatchEvent(new CustomEvent('on.fade'));\n  }\n\n  /**\n   * element on handler\n   * @param {Node|HTMLElement} element\n   * @param {Event} e\n   */\n  eventOnHandler(element, e) {\n    this.eventScroll(this.object);\n  }\n\n  //////////////////////\n  // events\n  //////////////////////\n\n  /**\n   * window scroll\n   */\n  eventScroll() {\n    let self = this;\n    let options = self.options;\n    // vars\n    let current = 0;\n    let currents = [];\n    let scrollInverse = false;\n    let windowHeight = window.innerHeight;\n    let scrollingElement = document.scrollingElement;\n    let scrollTop = scrollingElement.scrollTop;\n    let scrollTopOld = self.scrollTopOld;\n    // direction\n    if (scrollTop < scrollTopOld) {\n      scrollInverse = true;\n    }\n    // core\n    for (let el of self.elements) {\n      if (el.offsetParent && !el.classList.contains('fade-block')) {\n        // vars\n        let rectElTop = el.offsetParent.getBoundingClientRect().top + el.offsetTop; // we use parents to not include transforms animations\n        let heightEl = parseFloat(getComputedStyle(el).height);\n        // scroll\n        let changed = false;\n        let top = rectElTop + scrollTop;\n        let bottom = top + heightEl;\n        let dist = windowHeight * options.distance;\n        // activation\n        let checkTop = scrollTop + windowHeight >= top + dist;\n        let checkBottom = scrollTop < bottom - dist;\n        if (checkTop && checkBottom) {\n          // inside\n          changed = self.checkOn(el);\n          if (changed) {\n            currents.push(el);\n            XtUtil.cancelAnimationFrame.call(window, el.dataset.eventFrame);\n            el.dataset.eventFrame = XtUtil.requestAnimationFrame.call(window, function () {\n              if (options.delayOn) {\n                let func = new Function('current', 'total', options.delayOn);\n                el.dataset.xtOnDelay = func(current, currents.length).toString();\n                current++;\n              }\n              self.eventOn(el);\n            });\n          }\n        } else {\n          // outside\n          changed = self.checkOff(el);\n          el.classList.add('fade-visible');\n          if (changed) {\n            el.classList.add('fade-scroll');\n            currents.push(el);\n            XtUtil.cancelAnimationFrame.call(window, el.dataset.eventFrame);\n            el.dataset.eventFrame = XtUtil.requestAnimationFrame.call(window, function () {\n              if (options.delayOff) {\n                let func = new Function('current', 'total', options.delayOff);\n                el.dataset.xtOffDelay = func(current, currents.length).toString();\n                current++;\n              }\n              changed = self.eventOff(el);\n            });\n          }\n        }\n        // direction\n        if (changed) {\n          if (scrollInverse) {\n            el.classList.remove('fade-down');\n            el.classList.add('fade-up');\n          } else {\n            el.classList.add('fade-down');\n            el.classList.remove('fade-up');\n          }\n        }\n      }\n    }\n    // save for direction\n    self.scrollTopOld = scrollTop;\n  }\n\n}\n\n// default\n\nXtFade.defaults = {\n  \"elements\": \".fade\",\n  \"class\": \"in\",\n  \"on\": \"scroll resize\",\n  \"min\": 0,\n  \"max\": Infinity,\n  \"distance\": 0.2,\n  \"delayOn\": false,\n  \"delayOff\": false\n};\n\n// export\n\nwindow.XtFade = XtFade;\nexport {XtFade};\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4taW5zdGFuY2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1jb3B5LXdpdGhpbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZpbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19iaW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tc3Ryb25nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi13ZWFrLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0ta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLWlzLXJlZ2V4cC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZml4LXJlLXdrcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZsYWdzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZm9yLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGlkZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2luaGVyaXQtaWYtcmVxdWlyZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pbnZva2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtaW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLXJlZ2V4cC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2xpYnJhcnkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLWV4cG0xLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1mcm91bmQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLWxvZzFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1zaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWV0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21pY3JvdGFzay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX25ldy1wcm9taXNlLWNhcGFiaWxpdHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qtc2FwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXRvLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb3duLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wZXJmb3JtLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvbWlzZS1yZXNvbHZlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2FtZS12YWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1wcm90by5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1jb250ZXh0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXBhZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1yZXBlYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190YXNrLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC1idWZmZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VpZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VzZXItYWdlbnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL192YWxpZGF0ZS1jb2xsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy1leHQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkub2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hY29zaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXNpbmguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmF0YW5oLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jYnJ0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jbHozMi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY29zaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZXhwbTEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmZyb3VuZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmltdWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2luaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudGFuaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudHJ1bmMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuZXBzaWxvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtc2FmZS1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWluLXNhZmUtaW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtc2VhbGVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNlYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnByb21pc2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuaGFzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5pcy1leHRlbnNpYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5vd24ta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5zZXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuZmxhZ3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2guanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAucmVwbGFjZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zZWFyY2guanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zZXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJhdy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5hcnJheS1idWZmZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDMyLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQ2NC1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDE2LWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MzItYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQ4LWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDMyLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLXNldC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmVudHJpZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtc3RhcnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5pbW1lZGlhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi50aW1lcnMuanMiLCJub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwic3JjL2RvY3MvYXNzZXRzL3NjcmlwdHMveHRlbmQuanMiLCJzcmMvc2NyaXB0cy94dGVuZC11dGlscy5qcyIsInNyYy9zY3JpcHRzL3h0ZW5kLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFJLE9BQU8sSUFBSSxRQUFKLENBQWEsU0FBYixFQUF3QixPQUF4QixFQUFpQyxRQUFRLFFBQXpDLENBQVg7QUFDQSx1QkFBRyxPQUFILENBQVcsVUFBWCxHQUF3QixLQUFLLE9BQUwsRUFBYyxTQUFTLE1BQXZCLEVBQStCLFFBQS9CLEVBQXhCO0FBQ0E7QUFDRDtBQUNELDRCQUFVLEtBQUssUUFBTCxDQUFjLEVBQWQsQ0FBVjtBQUNELGlCQVB1QixDQUF4QjtBQVFEO0FBQ0Y7QUFDRDtBQUNBLGdCQUFJLE9BQUosRUFBYTtBQUNYLGtCQUFJLGFBQUosRUFBbUI7QUFDakIsbUJBQUcsU0FBSCxDQUFhLE1BQWIsQ0FBb0IsV0FBcEI7QUFDQSxtQkFBRyxTQUFILENBQWEsR0FBYixDQUFpQixTQUFqQjtBQUNELGVBSEQsTUFHTztBQUNMLG1CQUFHLFNBQUgsQ0FBYSxHQUFiLENBQWlCLFdBQWpCO0FBQ0EsbUJBQUcsU0FBSCxDQUFhLE1BQWIsQ0FBb0IsU0FBcEI7QUFDRDtBQUNGO0FBQ0Y7QUF4RVM7O0FBZ0JaLCtCQUFlLEtBQUssUUFBcEIsd0lBQThCO0FBQUE7QUF5RDdCO0FBQ0Q7QUExRVk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUEyRVosV0FBSyxZQUFMLEdBQW9CLFNBQXBCO0FBQ0Q7Ozs7RUFsSWtCLEU7O0FBc0lyQjs7QUFFQSxPQUFPLFFBQVAsR0FBa0I7QUFDaEIsY0FBWSxPQURJO0FBRWhCLFdBQVMsSUFGTztBQUdoQixRQUFNLGVBSFU7QUFJaEIsU0FBTyxDQUpTO0FBS2hCLFNBQU8sUUFMUztBQU1oQixjQUFZLEdBTkk7QUFPaEIsYUFBVyxLQVBLO0FBUWhCLGNBQVk7QUFSSSxDQUFsQjs7QUFXQTs7QUFFQSxPQUFPLE1BQVAsR0FBZ0IsTUFBaEI7UUFDUSxNLEdBQUEsTSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBVTlNDT1BBQkxFUyA9IHJlcXVpcmUoJy4vX3drcycpKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5pZiAoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSByZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKSB7XG4gIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxuJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtdLmNvcHlXaXRoaW4gfHwgZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQgLyogPSAwICovLCBzdGFydCAvKiA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbiA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIHRvID0gdG9BYnNvbHV0ZUluZGV4KHRhcmdldCwgbGVuKTtcbiAgdmFyIGZyb20gPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbik7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGNvdW50ID0gTWF0aC5taW4oKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuKSkgLSBmcm9tLCBsZW4gLSB0byk7XG4gIHZhciBpbmMgPSAxO1xuICBpZiAoZnJvbSA8IHRvICYmIHRvIDwgZnJvbSArIGNvdW50KSB7XG4gICAgaW5jID0gLTE7XG4gICAgZnJvbSArPSBjb3VudCAtIDE7XG4gICAgdG8gKz0gY291bnQgLSAxO1xuICB9XG4gIHdoaWxlIChjb3VudC0tID4gMCkge1xuICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtcbiAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICB0byArPSBpbmM7XG4gICAgZnJvbSArPSBpbmM7XG4gIH0gcmV0dXJuIE87XG59O1xuIiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyogLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKTtcbiAgd2hpbGUgKGVuZFBvcyA+IGluZGV4KSBPW2luZGV4KytdID0gdmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuIiwiLy8gMCAtPiBBcnJheSNmb3JFYWNoXG4vLyAxIC0+IEFycmF5I21hcFxuLy8gMiAtPiBBcnJheSNmaWx0ZXJcbi8vIDMgLT4gQXJyYXkjc29tZVxuLy8gNCAtPiBBcnJheSNldmVyeVxuLy8gNSAtPiBBcnJheSNmaW5kXG4vLyA2IC0+IEFycmF5I2ZpbmRJbmRleFxudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFzYyA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUWVBFLCAkY3JlYXRlKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG4gIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG4gIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgdmFyIGNyZWF0ZSA9ICRjcmVhdGUgfHwgYXNjO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0KSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7XG4gICAgdmFyIHNlbGYgPSBJT2JqZWN0KE8pO1xuICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsLCByZXM7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICB2YWwgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XG4gICAgICBpZiAoVFlQRSkge1xuICAgICAgICBpZiAoSVNfTUFQKSByZXN1bHRbaW5kZXhdID0gcmVzOyAgIC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXMpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZiAoSVNfRVZFUlkpIHJldHVybiBmYWxzZTsgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5KG9yaWdpbmFsKSkge1xuICAgIEMgPSBvcmlnaW5hbC5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmICh0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGlzT2JqZWN0KEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xufTtcbiIsIi8vIDkuNC4yLjMgQXJyYXlTcGVjaWVzQ3JlYXRlKG9yaWdpbmFsQXJyYXksIGxlbmd0aClcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsLCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsKSkobGVuZ3RoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaW52b2tlID0gcmVxdWlyZSgnLi9faW52b2tlJyk7XG52YXIgYXJyYXlTbGljZSA9IFtdLnNsaWNlO1xudmFyIGZhY3RvcmllcyA9IHt9O1xuXG52YXIgY29uc3RydWN0ID0gZnVuY3Rpb24gKEYsIGxlbiwgYXJncykge1xuICBpZiAoIShsZW4gaW4gZmFjdG9yaWVzKSkge1xuICAgIGZvciAodmFyIG4gPSBbXSwgaSA9IDA7IGkgPCBsZW47IGkrKykgbltpXSA9ICdhWycgKyBpICsgJ10nO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgIGZhY3Rvcmllc1tsZW5dID0gRnVuY3Rpb24oJ0YsYScsICdyZXR1cm4gbmV3IEYoJyArIG4uam9pbignLCcpICsgJyknKTtcbiAgfSByZXR1cm4gZmFjdG9yaWVzW2xlbl0oRiwgYXJncyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLmJpbmQgfHwgZnVuY3Rpb24gYmluZCh0aGF0IC8qICwgLi4uYXJncyAqLykge1xuICB2YXIgZm4gPSBhRnVuY3Rpb24odGhpcyk7XG4gIHZhciBwYXJ0QXJncyA9IGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB2YXIgYm91bmQgPSBmdW5jdGlvbiAoLyogYXJncy4uLiAqLykge1xuICAgIHZhciBhcmdzID0gcGFydEFyZ3MuY29uY2F0KGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGJvdW5kID8gY29uc3RydWN0KGZuLCBhcmdzLmxlbmd0aCwgYXJncykgOiBpbnZva2UoZm4sIGFyZ3MsIHRoYXQpO1xuICB9O1xuICBpZiAoaXNPYmplY3QoZm4ucHJvdG90eXBlKSkgYm91bmQucHJvdG90eXBlID0gZm4ucHJvdG90eXBlO1xuICByZXR1cm4gYm91bmQ7XG59O1xuIiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQVJHID0gY29mKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyICRpdGVyRGVmaW5lID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKTtcbnZhciBzdGVwID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJyk7XG52YXIgc2V0U3BlY2llcyA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIGZhc3RLZXkgPSByZXF1aXJlKCcuL19tZXRhJykuZmFzdEtleTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBTSVpFID0gREVTQ1JJUFRPUlMgPyAnX3MnIDogJ3NpemUnO1xuXG52YXIgZ2V0RW50cnkgPSBmdW5jdGlvbiAodGhhdCwga2V5KSB7XG4gIC8vIGZhc3QgY2FzZVxuICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSk7XG4gIHZhciBlbnRyeTtcbiAgaWYgKGluZGV4ICE9PSAnRicpIHJldHVybiB0aGF0Ll9pW2luZGV4XTtcbiAgLy8gZnJvemVuIG9iamVjdCBjYXNlXG4gIGZvciAoZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKSB7XG4gICAgaWYgKGVudHJ5LmsgPT0ga2V5KSByZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5fdCA9IE5BTUU7ICAgICAgICAgLy8gY29sbGVjdGlvbiB0eXBlXG4gICAgICB0aGF0Ll9pID0gY3JlYXRlKG51bGwpOyAvLyBpbmRleFxuICAgICAgdGhhdC5fZiA9IHVuZGVmaW5lZDsgICAgLy8gZmlyc3QgZW50cnlcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7ICAgIC8vIGxhc3QgZW50cnlcbiAgICAgIHRoYXRbU0laRV0gPSAwOyAgICAgICAgIC8vIHNpemVcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXG4gICAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgZm9yICh2YXIgdGhhdCA9IHZhbGlkYXRlKHRoaXMsIE5BTUUpLCBkYXRhID0gdGhhdC5faSwgZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKSB7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYgKGVudHJ5LnApIGVudHJ5LnAgPSBlbnRyeS5wLm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5fZiA9IHRoYXQuX2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoYXRbU0laRV0gPSAwO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy4zIE1hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjIuMy40IFNldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB2YWxpZGF0ZSh0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uO1xuICAgICAgICAgIHZhciBwcmV2ID0gZW50cnkucDtcbiAgICAgICAgICBkZWxldGUgdGhhdC5faVtlbnRyeS5pXTtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocHJldikgcHJldi5uID0gbmV4dDtcbiAgICAgICAgICBpZiAobmV4dCkgbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZiAodGhhdC5fZiA9PSBlbnRyeSkgdGhhdC5fZiA9IG5leHQ7XG4gICAgICAgICAgaWYgKHRoYXQuX2wgPT0gZW50cnkpIHRoYXQuX2wgPSBwcmV2O1xuICAgICAgICAgIHRoYXRbU0laRV0tLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgICAgICB2YWxpZGF0ZSh0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDMpO1xuICAgICAgICB2YXIgZW50cnk7XG4gICAgICAgIHdoaWxlIChlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXMuX2YpIHtcbiAgICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSBlbnRyeSA9IGVudHJ5LnA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSwga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoREVTQ1JJUFRPUlMpIGRQKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUodGhpcywgTkFNRSlbU0laRV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgIHZhciBwcmV2LCBpbmRleDtcbiAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnYgPSB2YWx1ZTtcbiAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX2wgPSBlbnRyeSA9IHtcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksIC8vIDwtIGluZGV4XG4gICAgICAgIGs6IGtleSwgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBrZXlcbiAgICAgICAgdjogdmFsdWUsICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICAgIHA6IHByZXYgPSB0aGF0Ll9sLCAgICAgICAgICAgICAvLyA8LSBwcmV2aW91cyBlbnRyeVxuICAgICAgICBuOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgLy8gPC0gbmV4dCBlbnRyeVxuICAgICAgICByOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gcmVtb3ZlZFxuICAgICAgfTtcbiAgICAgIGlmICghdGhhdC5fZikgdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYgKHByZXYpIHByZXYubiA9IGVudHJ5O1xuICAgICAgdGhhdFtTSVpFXSsrO1xuICAgICAgLy8gYWRkIHRvIGluZGV4XG4gICAgICBpZiAoaW5kZXggIT09ICdGJykgdGhhdC5faVtpbmRleF0gPSBlbnRyeTtcbiAgICB9IHJldHVybiB0aGF0O1xuICB9LFxuICBnZXRFbnRyeTogZ2V0RW50cnksXG4gIHNldFN0cm9uZzogZnVuY3Rpb24gKEMsIE5BTUUsIElTX01BUCkge1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICAkaXRlckRlZmluZShDLCBOQU1FLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgICAgIHRoaXMuX3QgPSB2YWxpZGF0ZShpdGVyYXRlZCwgTkFNRSk7IC8vIHRhcmdldFxuICAgICAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgICAgICAgLy8ga2luZFxuICAgICAgdGhpcy5fbCA9IHVuZGVmaW5lZDsgICAgICAgICAgICAgICAgLy8gcHJldmlvdXNcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIga2luZCA9IHRoYXQuX2s7XG4gICAgICB2YXIgZW50cnkgPSB0aGF0Ll9sO1xuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucikgZW50cnkgPSBlbnRyeS5wO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmICghdGhhdC5fdCB8fCAhKHRoYXQuX2wgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoYXQuX3QuX2YpKSB7XG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIHRoYXQuX3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBzdGVwKDEpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuICAgICAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBlbnRyeS5rKTtcbiAgICAgIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBlbnRyeS52KTtcbiAgICAgIHJldHVybiBzdGVwKDAsIFtlbnRyeS5rLCBlbnRyeS52XSk7XG4gICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgZ2V0V2VhayA9IHJlcXVpcmUoJy4vX21ldGEnKS5nZXRXZWFrO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpO1xudmFyICRoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBhcnJheUZpbmQgPSBjcmVhdGVBcnJheU1ldGhvZCg1KTtcbnZhciBhcnJheUZpbmRJbmRleCA9IGNyZWF0ZUFycmF5TWV0aG9kKDYpO1xudmFyIGlkID0gMDtcblxuLy8gZmFsbGJhY2sgZm9yIHVuY2F1Z2h0IGZyb3plbiBrZXlzXG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gIHJldHVybiB0aGF0Ll9sIHx8ICh0aGF0Ll9sID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUoKSk7XG59O1xudmFyIFVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYSA9IFtdO1xufTtcbnZhciBmaW5kVW5jYXVnaHRGcm96ZW4gPSBmdW5jdGlvbiAoc3RvcmUsIGtleSkge1xuICByZXR1cm4gYXJyYXlGaW5kKHN0b3JlLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICB9KTtcbn07XG5VbmNhdWdodEZyb3plblN0b3JlLnByb3RvdHlwZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSByZXR1cm4gZW50cnlbMV07XG4gIH0sXG4gIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhIWZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSBlbnRyeVsxXSA9IHZhbHVlO1xuICAgIGVsc2UgdGhpcy5hLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSxcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgaW5kZXggPSBhcnJheUZpbmRJbmRleCh0aGlzLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gICAgfSk7XG4gICAgaWYgKH5pbmRleCkgdGhpcy5hLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuICEhfmluZGV4O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX3QgPSBOQU1FOyAgICAgIC8vIGNvbGxlY3Rpb24gdHlwZVxuICAgICAgdGhhdC5faSA9IGlkKys7ICAgICAgLy8gY29sbGVjdGlvbiBpZFxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgLy8gbGVhayBzdG9yZSBmb3IgdW5jYXVnaHQgZnJvemVuIG9iamVjdHNcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMy4zLjIgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjQuMy4zIFdlYWtTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIE5BTUUpKVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKSAmJiBkZWxldGUgZGF0YVt0aGlzLl9pXTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4zLjMuNCBXZWFrTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuNC4zLjQgV2Vha1NldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIE5BTUUpKS5oYXMoa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBkYXRhID0gZ2V0V2Vhayhhbk9iamVjdChrZXkpLCB0cnVlKTtcbiAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGF0KS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgZWxzZSBkYXRhW3RoYXQuX2ldID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIHVmc3RvcmU6IHVuY2F1Z2h0RnJvemVuU3RvcmVcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciAkaXRlckRldGVjdCA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0Jyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSykge1xuICB2YXIgQmFzZSA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIEMgPSBCYXNlO1xuICB2YXIgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnO1xuICB2YXIgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlO1xuICB2YXIgTyA9IHt9O1xuICB2YXIgZml4TWV0aG9kID0gZnVuY3Rpb24gKEtFWSkge1xuICAgIHZhciBmbiA9IHByb3RvW0tFWV07XG4gICAgcmVkZWZpbmUocHJvdG8sIEtFWSxcbiAgICAgIEtFWSA9PSAnZGVsZXRlJyA/IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnaGFzJyA/IGZ1bmN0aW9uIGhhcyhhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnZ2V0JyA/IGZ1bmN0aW9uIGdldChhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IHVuZGVmaW5lZCA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2FkZCcgPyBmdW5jdGlvbiBhZGQoYSkgeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7IHJldHVybiB0aGlzOyB9XG4gICAgICAgIDogZnVuY3Rpb24gc2V0KGEsIGIpIHsgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEsIGIpOyByZXR1cm4gdGhpczsgfVxuICAgICk7XG4gIH07XG4gIGlmICh0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpIHtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgIG1ldGEuTkVFRCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAvLyBlYXJseSBpbXBsZW1lbnRhdGlvbnMgbm90IHN1cHBvcnRzIGNoYWluaW5nXG4gICAgdmFyIEhBU05UX0NIQUlOSU5HID0gaW5zdGFuY2VbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKSAhPSBpbnN0YW5jZTtcbiAgICAvLyBWOCB+ICBDaHJvbWl1bSA0MC0gd2Vhay1jb2xsZWN0aW9ucyB0aHJvd3Mgb24gcHJpbWl0aXZlcywgYnV0IHNob3VsZCByZXR1cm4gZmFsc2VcbiAgICB2YXIgVEhST1dTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IGluc3RhbmNlLmhhcygxKTsgfSk7XG4gICAgLy8gbW9zdCBlYXJseSBpbXBsZW1lbnRhdGlvbnMgZG9lc24ndCBzdXBwb3J0cyBpdGVyYWJsZXMsIG1vc3QgbW9kZXJuIC0gbm90IGNsb3NlIGl0IGNvcnJlY3RseVxuICAgIHZhciBBQ0NFUFRfSVRFUkFCTEVTID0gJGl0ZXJEZXRlY3QoZnVuY3Rpb24gKGl0ZXIpIHsgbmV3IEMoaXRlcik7IH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxuICAgIHZhciBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVjggfiBDaHJvbWl1bSA0Mi0gZmFpbHMgb25seSB3aXRoIDUrIGVsZW1lbnRzXG4gICAgICB2YXIgJGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAgIHZhciBpbmRleCA9IDU7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkgJGluc3RhbmNlW0FEREVSXShpbmRleCwgaW5kZXgpO1xuICAgICAgcmV0dXJuICEkaW5zdGFuY2UuaGFzKC0wKTtcbiAgICB9KTtcbiAgICBpZiAoIUFDQ0VQVF9JVEVSQUJMRVMpIHtcbiAgICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0YXJnZXQsIGl0ZXJhYmxlKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGFyZ2V0LCBDLCBOQU1FKTtcbiAgICAgICAgdmFyIHRoYXQgPSBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSgpLCB0YXJnZXQsIEMpO1xuICAgICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgfSk7XG4gICAgICBDLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgcHJvdG8uY29uc3RydWN0b3IgPSBDO1xuICAgIH1cbiAgICBpZiAoVEhST1dTX09OX1BSSU1JVElWRVMgfHwgQlVHR1lfWkVSTykge1xuICAgICAgZml4TWV0aG9kKCdkZWxldGUnKTtcbiAgICAgIGZpeE1ldGhvZCgnaGFzJyk7XG4gICAgICBJU19NQVAgJiYgZml4TWV0aG9kKCdnZXQnKTtcbiAgICB9XG4gICAgaWYgKEJVR0dZX1pFUk8gfHwgSEFTTlRfQ0hBSU5JTkcpIGZpeE1ldGhvZChBRERFUik7XG4gICAgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcbiAgICBpZiAoSVNfV0VBSyAmJiBwcm90by5jbGVhcikgZGVsZXRlIHByb3RvLmNsZWFyO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEMgIT0gQmFzZSksIE8pO1xuXG4gIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTtcbiIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjUuNycgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCwgdmFsdWUpIHtcbiAgaWYgKGluZGV4IGluIG9iamVjdCkgJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbn07XG4iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbiIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuIiwiLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcmVzdWx0ID0gZ2V0S2V5cyhpdCk7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICBpZiAoZ2V0U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdCk7XG4gICAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChzeW1ib2xzLmxlbmd0aCA+IGkpIGlmIChpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIHx8IChnbG9iYWxbbmFtZV0gPSB7fSkgOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuICB2YXIgZXhwb3J0cyA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV0gfHwgKGV4cG9ydHNbUFJPVE9UWVBFXSA9IHt9KTtcbiAgdmFyIGtleSwgb3duLCBvdXQsIGV4cDtcbiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTtcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICBleHAgPSBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgaWYgKHRhcmdldCkgcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7XG4gICAgLy8gZXhwb3J0XG4gICAgaWYgKGV4cG9ydHNba2V5XSAhPSBvdXQpIGhpZGUoZXhwb3J0cywga2V5LCBleHApO1xuICAgIGlmIChJU19QUk9UTyAmJiBleHBQcm90b1trZXldICE9IG91dCkgZXhwUHJvdG9ba2V5XSA9IG91dDtcbiAgfVxufTtcbmdsb2JhbC5jb3JlID0gY29yZTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcbiIsInZhciBNQVRDSCA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciByZSA9IC8uLztcbiAgdHJ5IHtcbiAgICAnLy4vJ1tLRVldKHJlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRyeSB7XG4gICAgICByZVtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAhJy8uLydbS0VZXShyZSk7XG4gICAgfSBjYXRjaCAoZikgeyAvKiBlbXB0eSAqLyB9XG4gIH0gcmV0dXJuIHRydWU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGxlbmd0aCwgZXhlYykge1xuICB2YXIgU1lNQk9MID0gd2tzKEtFWSk7XG4gIHZhciBmbnMgPSBleGVjKGRlZmluZWQsIFNZTUJPTCwgJydbS0VZXSk7XG4gIHZhciBzdHJmbiA9IGZuc1swXTtcbiAgdmFyIHJ4Zm4gPSBmbnNbMV07XG4gIGlmIChmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIE8gPSB7fTtcbiAgICBPW1NZTUJPTF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9O1xuICAgIHJldHVybiAnJ1tLRVldKE8pICE9IDc7XG4gIH0pKSB7XG4gICAgcmVkZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgS0VZLCBzdHJmbik7XG4gICAgaGlkZShSZWdFeHAucHJvdG90eXBlLCBTWU1CT0wsIGxlbmd0aCA9PSAyXG4gICAgICAvLyAyMS4yLjUuOCBSZWdFeHAucHJvdG90eXBlW0BAcmVwbGFjZV0oc3RyaW5nLCByZXBsYWNlVmFsdWUpXG4gICAgICAvLyAyMS4yLjUuMTEgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XShzdHJpbmcsIGxpbWl0KVxuICAgICAgPyBmdW5jdGlvbiAoc3RyaW5nLCBhcmcpIHsgcmV0dXJuIHJ4Zm4uY2FsbChzdHJpbmcsIHRoaXMsIGFyZyk7IH1cbiAgICAgIC8vIDIxLjIuNS42IFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF0oc3RyaW5nKVxuICAgICAgLy8gMjEuMi41LjkgUmVnRXhwLnByb3RvdHlwZVtAQHNlYXJjaF0oc3RyaW5nKVxuICAgICAgOiBmdW5jdGlvbiAoc3RyaW5nKSB7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzKTsgfVxuICAgICk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMS4yLjUuMyBnZXQgUmVnRXhwLnByb3RvdHlwZS5mbGFnc1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSBhbk9iamVjdCh0aGlzKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmICh0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKHRoYXQudW5pY29kZSkgcmVzdWx0ICs9ICd1JztcbiAgaWYgKHRoYXQuc3RpY2t5KSByZXN1bHQgKz0gJ3knO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgQlJFQUsgPSB7fTtcbnZhciBSRVRVUk4gPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUikge1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSk7XG4gIHZhciBmID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmIChpc0FycmF5SXRlcihpdGVyRm4pKSBmb3IgKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOykge1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwidmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIHRhcmdldCwgQykge1xuICB2YXIgUyA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgdmFyIFA7XG4gIGlmIChTICE9PSBDICYmIHR5cGVvZiBTID09ICdmdW5jdGlvbicgJiYgKFAgPSBTLnByb3RvdHlwZSkgIT09IEMucHJvdG90eXBlICYmIGlzT2JqZWN0KFApICYmIHNldFByb3RvdHlwZU9mKSB7XG4gICAgc2V0UHJvdG90eXBlT2YodGhhdCwgUCk7XG4gIH0gcmV0dXJuIHRoYXQ7XG59O1xuIiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgYXJncywgdGhhdCkge1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJncyk7XG59O1xuIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcbiIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59O1xuIiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG4iLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNJbnRlZ2VyKGl0KSB7XG4gIHJldHVybiAhaXNPYmplY3QoaXQpICYmIGlzRmluaXRlKGl0KSAmJiBmbG9vcihpdCkgPT09IGl0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuIiwiLy8gNy4yLjggSXNSZWdFeHAoYXJndW1lbnQpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBNQVRDSCA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY29mKGl0KSA9PSAnUmVnRXhwJyk7XG59O1xuIiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgdHlwZW9mIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCJ2YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbiAoKSB7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgc2tpcENsb3NpbmcpIHtcbiAgaWYgKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IFs3XTtcbiAgICB2YXIgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7IGRvbmU6IHNhZmUgPSB0cnVlIH07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcbiIsIi8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXG52YXIgJGV4cG0xID0gTWF0aC5leHBtMTtcbm1vZHVsZS5leHBvcnRzID0gKCEkZXhwbTFcbiAgLy8gT2xkIEZGIGJ1Z1xuICB8fCAkZXhwbTEoMTApID4gMjIwMjUuNDY1Nzk0ODA2NzE5IHx8ICRleHBtMSgxMCkgPCAyMjAyNS40NjU3OTQ4MDY3MTY1MTY4XG4gIC8vIFRvciBCcm93c2VyIGJ1Z1xuICB8fCAkZXhwbTEoLTJlLTE3KSAhPSAtMmUtMTdcbikgPyBmdW5jdGlvbiBleHBtMSh4KSB7XG4gIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IHggPiAtMWUtNiAmJiB4IDwgMWUtNiA/IHggKyB4ICogeCAvIDIgOiBNYXRoLmV4cCh4KSAtIDE7XG59IDogJGV4cG0xO1xuIiwiLy8gMjAuMi4yLjE2IE1hdGguZnJvdW5kKHgpXG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpO1xudmFyIHBvdyA9IE1hdGgucG93O1xudmFyIEVQU0lMT04gPSBwb3coMiwgLTUyKTtcbnZhciBFUFNJTE9OMzIgPSBwb3coMiwgLTIzKTtcbnZhciBNQVgzMiA9IHBvdygyLCAxMjcpICogKDIgLSBFUFNJTE9OMzIpO1xudmFyIE1JTjMyID0gcG93KDIsIC0xMjYpO1xuXG52YXIgcm91bmRUaWVzVG9FdmVuID0gZnVuY3Rpb24gKG4pIHtcbiAgcmV0dXJuIG4gKyAxIC8gRVBTSUxPTiAtIDEgLyBFUFNJTE9OO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLmZyb3VuZCB8fCBmdW5jdGlvbiBmcm91bmQoeCkge1xuICB2YXIgJGFicyA9IE1hdGguYWJzKHgpO1xuICB2YXIgJHNpZ24gPSBzaWduKHgpO1xuICB2YXIgYSwgcmVzdWx0O1xuICBpZiAoJGFicyA8IE1JTjMyKSByZXR1cm4gJHNpZ24gKiByb3VuZFRpZXNUb0V2ZW4oJGFicyAvIE1JTjMyIC8gRVBTSUxPTjMyKSAqIE1JTjMyICogRVBTSUxPTjMyO1xuICBhID0gKDEgKyBFUFNJTE9OMzIgLyBFUFNJTE9OKSAqICRhYnM7XG4gIHJlc3VsdCA9IGEgLSAoYSAtICRhYnMpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIGlmIChyZXN1bHQgPiBNQVgzMiB8fCByZXN1bHQgIT0gcmVzdWx0KSByZXR1cm4gJHNpZ24gKiBJbmZpbml0eTtcbiAgcmV0dXJuICRzaWduICogcmVzdWx0O1xufTtcbiIsIi8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGgubG9nMXAgfHwgZnVuY3Rpb24gbG9nMXAoeCkge1xuICByZXR1cm4gKHggPSAreCkgPiAtMWUtOCAmJiB4IDwgMWUtOCA/IHggLSB4ICogeCAvIDIgOiBNYXRoLmxvZygxICsgeCk7XG59O1xuIiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24gc2lnbih4KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgfHwgeCAhPSB4ID8geCA6IHggPCAwID8gLTEgOiAxO1xufTtcbiIsInZhciBNRVRBID0gcmVxdWlyZSgnLi9fdWlkJykoJ21ldGEnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHNldERlc2MgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGlkID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIEZSRUVaRSA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgc2V0RGVzYyhpdCwgTUVUQSwgeyB2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gfSk7XG59O1xudmFyIGZhc3RLZXkgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIGhhc2ggd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSByZXR1cm4gaXRbTUVUQV0udztcbn07XG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEEpKSBzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogTUVUQSxcbiAgTkVFRDogZmFsc2UsXG4gIGZhc3RLZXk6IGZhc3RLZXksXG4gIGdldFdlYWs6IGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBtYWNyb3Rhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0O1xudmFyIE9ic2VydmVyID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIFByb21pc2UgPSBnbG9iYWwuUHJvbWlzZTtcbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCwgbGFzdCwgbm90aWZ5O1xuXG4gIHZhciBmbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZiAoaXNOb2RlICYmIChwYXJlbnQgPSBwcm9jZXNzLmRvbWFpbikpIHBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgIGZuID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoaGVhZCkgbm90aWZ5KCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gTm9kZS5qc1xuICBpZiAoaXNOb2RlKSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyLCBleGNlcHQgaU9TIFNhZmFyaSAtIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMzlcbiAgfSBlbHNlIGlmIChPYnNlcnZlciAmJiAhKGdsb2JhbC5uYXZpZ2F0b3IgJiYgZ2xvYmFsLm5hdmlnYXRvci5zdGFuZGFsb25lKSkge1xuICAgIHZhciB0b2dnbGUgPSB0cnVlO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYgKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKSB7XG4gICAgLy8gUHJvbWlzZS5yZXNvbHZlIHdpdGhvdXQgYW4gYXJndW1lbnQgdGhyb3dzIGFuIGVycm9yIGluIExHIFdlYk9TIDJcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb21pc2UudGhlbihmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIHRhc2sgPSB7IGZuOiBmbiwgbmV4dDogdW5kZWZpbmVkIH07XG4gICAgaWYgKGxhc3QpIGxhc3QubmV4dCA9IHRhc2s7XG4gICAgaWYgKCFoZWFkKSB7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjUuNC4xLjUgTmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbmZ1bmN0aW9uIFByb21pc2VDYXBhYmlsaXR5KEMpIHtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24gKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcbiAgICBpZiAocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFGdW5jdGlvbihyZXNvbHZlKTtcbiAgdGhpcy5yZWplY3QgPSBhRnVuY3Rpb24ocmVqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIChDKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBTID0gU3ltYm9sKCk7XG4gIHZhciBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICB2YXIgaXNFbnVtID0gcElFLmY7XG4gIHdoaWxlIChhTGVuID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSBpZiAoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSkgVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG4iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG4iLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uIChpdCkge1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTtcbiIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG4iLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG4iLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsIi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgZXhlYykge1xuICB2YXIgZm4gPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV07XG4gIHZhciBleHAgPSB7fTtcbiAgZXhwW0tFWV0gPSBleGVjKGZuKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59O1xuIiwidmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBpc0VudW0gPSByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlzRW50cmllcykge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QoaXQpO1xuICAgIHZhciBrZXlzID0gZ2V0S2V5cyhPKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoTywga2V5ID0ga2V5c1tpKytdKSkge1xuICAgICAgcmVzdWx0LnB1c2goaXNFbnRyaWVzID8gW2tleSwgT1trZXldXSA6IE9ba2V5XSk7XG4gICAgfSByZXR1cm4gcmVzdWx0O1xuICB9O1xufTtcbiIsIi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIFJlZmxlY3QgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBSZWZsZWN0ICYmIFJlZmxlY3Qub3duS2V5cyB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gIHZhciBrZXlzID0gZ09QTi5mKGFuT2JqZWN0KGl0KSk7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICByZXR1cm4gZ2V0U3ltYm9scyA/IGtleXMuY29uY2F0KGdldFN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiB7IGU6IGZhbHNlLCB2OiBleGVjKCkgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7IGU6IHRydWUsIHY6IGUgfTtcbiAgfVxufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEMsIHgpIHtcbiAgYW5PYmplY3QoQyk7XG4gIGlmIChpc09iamVjdCh4KSAmJiB4LmNvbnN0cnVjdG9yID09PSBDKSByZXR1cm4geDtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZihDKTtcbiAgdmFyIHJlc29sdmUgPSBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlO1xuICByZXNvbHZlKHgpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIiwidmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBzYWZlKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgc2FmZSk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgU1JDID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgJHRvU3RyaW5nID0gRnVuY3Rpb25bVE9fU1RSSU5HXTtcbnZhciBUUEwgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWwsIHNhZmUpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgdmFsID09ICdmdW5jdGlvbic7XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmIChPW2tleV0gPT09IHZhbCkgcmV0dXJuO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgU1JDKSB8fCBoaWRlKHZhbCwgU1JDLCBPW2tleV0gPyAnJyArIE9ba2V5XSA6IFRQTC5qb2luKFN0cmluZyhrZXkpKSk7XG4gIGlmIChPID09PSBnbG9iYWwpIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSBpZiAoIXNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9IGVsc2UgaWYgKE9ba2V5XSkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pO1xuIiwiLy8gNy4yLjkgU2FtZVZhbHVlKHgsIHkpXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5pcyB8fCBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgcmV0dXJuIHggPT09IHkgPyB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSA6IHggIT0geCAmJiB5ICE9IHk7XG59O1xuIiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uIChPLCBwcm90bykge1xuICBhbk9iamVjdChPKTtcbiAgaWYgKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpIHRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uICh0ZXN0LCBidWdneSwgc2V0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaCAoZSkgeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmIChidWdneSkgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgdmFyIEMgPSBnbG9iYWxbS0VZXTtcbiAgaWYgKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pIGRQLmYoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG4iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogY29yZS52ZXJzaW9uLFxuICBtb2RlOiByZXF1aXJlKCcuL19saWJyYXJ5JykgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAxOCBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xuIiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBEKSB7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3I7XG4gIHZhciBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcbiIsIi8vIGhlbHBlciBmb3IgU3RyaW5nI3tzdGFydHNXaXRoLCBlbmRzV2l0aCwgaW5jbHVkZXN9XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCBzZWFyY2hTdHJpbmcsIE5BTUUpIHtcbiAgaWYgKGlzUmVnRXhwKHNlYXJjaFN0cmluZykpIHRocm93IFR5cGVFcnJvcignU3RyaW5nIycgKyBOQU1FICsgXCIgZG9lc24ndCBhY2NlcHQgcmVnZXghXCIpO1xuICByZXR1cm4gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xufTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciByZXBlYXQgPSByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhhdCwgbWF4TGVuZ3RoLCBmaWxsU3RyaW5nLCBsZWZ0KSB7XG4gIHZhciBTID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICB2YXIgc3RyaW5nTGVuZ3RoID0gUy5sZW5ndGg7XG4gIHZhciBmaWxsU3RyID0gZmlsbFN0cmluZyA9PT0gdW5kZWZpbmVkID8gJyAnIDogU3RyaW5nKGZpbGxTdHJpbmcpO1xuICB2YXIgaW50TWF4TGVuZ3RoID0gdG9MZW5ndGgobWF4TGVuZ3RoKTtcbiAgaWYgKGludE1heExlbmd0aCA8PSBzdHJpbmdMZW5ndGggfHwgZmlsbFN0ciA9PSAnJykgcmV0dXJuIFM7XG4gIHZhciBmaWxsTGVuID0gaW50TWF4TGVuZ3RoIC0gc3RyaW5nTGVuZ3RoO1xuICB2YXIgc3RyaW5nRmlsbGVyID0gcmVwZWF0LmNhbGwoZmlsbFN0ciwgTWF0aC5jZWlsKGZpbGxMZW4gLyBmaWxsU3RyLmxlbmd0aCkpO1xuICBpZiAoc3RyaW5nRmlsbGVyLmxlbmd0aCA+IGZpbGxMZW4pIHN0cmluZ0ZpbGxlciA9IHN0cmluZ0ZpbGxlci5zbGljZSgwLCBmaWxsTGVuKTtcbiAgcmV0dXJuIGxlZnQgPyBzdHJpbmdGaWxsZXIgKyBTIDogUyArIHN0cmluZ0ZpbGxlcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVwZWF0KGNvdW50KSB7XG4gIHZhciBzdHIgPSBTdHJpbmcoZGVmaW5lZCh0aGlzKSk7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIG4gPSB0b0ludGVnZXIoY291bnQpO1xuICBpZiAobiA8IDAgfHwgbiA9PSBJbmZpbml0eSkgdGhyb3cgUmFuZ2VFcnJvcihcIkNvdW50IGNhbid0IGJlIG5lZ2F0aXZlXCIpO1xuICBmb3IgKDtuID4gMDsgKG4gPj4+PSAxKSAmJiAoc3RyICs9IHN0cikpIGlmIChuICYgMSkgcmVzICs9IHN0cjtcbiAgcmV0dXJuIHJlcztcbn07XG4iLCJ2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgaW52b2tlID0gcmVxdWlyZSgnLi9faW52b2tlJyk7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4vX2h0bWwnKTtcbnZhciBjZWwgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIHNldFRhc2sgPSBnbG9iYWwuc2V0SW1tZWRpYXRlO1xudmFyIGNsZWFyVGFzayA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZTtcbnZhciBNZXNzYWdlQ2hhbm5lbCA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbDtcbnZhciBEaXNwYXRjaCA9IGdsb2JhbC5EaXNwYXRjaDtcbnZhciBjb3VudGVyID0gMDtcbnZhciBxdWV1ZSA9IHt9O1xudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xudmFyIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgaWYgKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYgKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spIHtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIGkgPSAxO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYgKHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gU3BoZXJlIChKUyBnYW1lIGVuZ2luZSkgRGlzcGF0Y2ggQVBJXG4gIH0gZWxzZSBpZiAoRGlzcGF0Y2ggJiYgRGlzcGF0Y2gubm93KSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIERpc3BhdGNoLm5vdyhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmIChNZXNzYWdlQ2hhbm5lbCkge1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSkge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvaW5kZXhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMDtcbiAgdmFyIG51bWJlciA9IHRvSW50ZWdlcihpdCk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChudW1iZXIpO1xuICBpZiAobnVtYmVyICE9PSBsZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIGxlbmd0aCEnKTtcbiAgcmV0dXJuIGxlbmd0aDtcbn07XG4iLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcbiIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcbiIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuaWYgKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykpIHtcbiAgdmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG4gIHZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbiAgdmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbiAgdmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiAgdmFyICR0eXBlZCA9IHJlcXVpcmUoJy4vX3R5cGVkJyk7XG4gIHZhciAkYnVmZmVyID0gcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJyk7XG4gIHZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbiAgdmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xuICB2YXIgcHJvcGVydHlEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xuICB2YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbiAgdmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG4gIHZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG4gIHZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuICB2YXIgdG9JbmRleCA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG4gIHZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xuICB2YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbiAgdmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xuICB2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbiAgdmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4gIHZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuICB2YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG4gIHZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG4gIHZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbiAgdmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG4gIHZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuICB2YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG4gIHZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbiAgdmFyIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpO1xuICB2YXIgY3JlYXRlQXJyYXlJbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJyk7XG4gIHZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG4gIHZhciBBcnJheUl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG4gIHZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbiAgdmFyICRpdGVyRGV0ZWN0ID0gcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKTtcbiAgdmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpO1xuICB2YXIgYXJyYXlGaWxsID0gcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpO1xuICB2YXIgYXJyYXlDb3B5V2l0aGluID0gcmVxdWlyZSgnLi9fYXJyYXktY29weS13aXRoaW4nKTtcbiAgdmFyICREUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuICB2YXIgJEdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xuICB2YXIgZFAgPSAkRFAuZjtcbiAgdmFyIGdPUEQgPSAkR09QRC5mO1xuICB2YXIgUmFuZ2VFcnJvciA9IGdsb2JhbC5SYW5nZUVycm9yO1xuICB2YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbiAgdmFyIFVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheTtcbiAgdmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG4gIHZhciBTSEFSRURfQlVGRkVSID0gJ1NoYXJlZCcgKyBBUlJBWV9CVUZGRVI7XG4gIHZhciBCWVRFU19QRVJfRUxFTUVOVCA9ICdCWVRFU19QRVJfRUxFTUVOVCc7XG4gIHZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheVtQUk9UT1RZUEVdO1xuICB2YXIgJEFycmF5QnVmZmVyID0gJGJ1ZmZlci5BcnJheUJ1ZmZlcjtcbiAgdmFyICREYXRhVmlldyA9ICRidWZmZXIuRGF0YVZpZXc7XG4gIHZhciBhcnJheUZvckVhY2ggPSBjcmVhdGVBcnJheU1ldGhvZCgwKTtcbiAgdmFyIGFycmF5RmlsdGVyID0gY3JlYXRlQXJyYXlNZXRob2QoMik7XG4gIHZhciBhcnJheVNvbWUgPSBjcmVhdGVBcnJheU1ldGhvZCgzKTtcbiAgdmFyIGFycmF5RXZlcnkgPSBjcmVhdGVBcnJheU1ldGhvZCg0KTtcbiAgdmFyIGFycmF5RmluZCA9IGNyZWF0ZUFycmF5TWV0aG9kKDUpO1xuICB2YXIgYXJyYXlGaW5kSW5kZXggPSBjcmVhdGVBcnJheU1ldGhvZCg2KTtcbiAgdmFyIGFycmF5SW5jbHVkZXMgPSBjcmVhdGVBcnJheUluY2x1ZGVzKHRydWUpO1xuICB2YXIgYXJyYXlJbmRleE9mID0gY3JlYXRlQXJyYXlJbmNsdWRlcyhmYWxzZSk7XG4gIHZhciBhcnJheVZhbHVlcyA9IEFycmF5SXRlcmF0b3JzLnZhbHVlcztcbiAgdmFyIGFycmF5S2V5cyA9IEFycmF5SXRlcmF0b3JzLmtleXM7XG4gIHZhciBhcnJheUVudHJpZXMgPSBBcnJheUl0ZXJhdG9ycy5lbnRyaWVzO1xuICB2YXIgYXJyYXlMYXN0SW5kZXhPZiA9IEFycmF5UHJvdG8ubGFzdEluZGV4T2Y7XG4gIHZhciBhcnJheVJlZHVjZSA9IEFycmF5UHJvdG8ucmVkdWNlO1xuICB2YXIgYXJyYXlSZWR1Y2VSaWdodCA9IEFycmF5UHJvdG8ucmVkdWNlUmlnaHQ7XG4gIHZhciBhcnJheUpvaW4gPSBBcnJheVByb3RvLmpvaW47XG4gIHZhciBhcnJheVNvcnQgPSBBcnJheVByb3RvLnNvcnQ7XG4gIHZhciBhcnJheVNsaWNlID0gQXJyYXlQcm90by5zbGljZTtcbiAgdmFyIGFycmF5VG9TdHJpbmcgPSBBcnJheVByb3RvLnRvU3RyaW5nO1xuICB2YXIgYXJyYXlUb0xvY2FsZVN0cmluZyA9IEFycmF5UHJvdG8udG9Mb2NhbGVTdHJpbmc7XG4gIHZhciBJVEVSQVRPUiA9IHdrcygnaXRlcmF0b3InKTtcbiAgdmFyIFRBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbiAgdmFyIFRZUEVEX0NPTlNUUlVDVE9SID0gdWlkKCd0eXBlZF9jb25zdHJ1Y3RvcicpO1xuICB2YXIgREVGX0NPTlNUUlVDVE9SID0gdWlkKCdkZWZfY29uc3RydWN0b3InKTtcbiAgdmFyIEFMTF9DT05TVFJVQ1RPUlMgPSAkdHlwZWQuQ09OU1RSO1xuICB2YXIgVFlQRURfQVJSQVkgPSAkdHlwZWQuVFlQRUQ7XG4gIHZhciBWSUVXID0gJHR5cGVkLlZJRVc7XG4gIHZhciBXUk9OR19MRU5HVEggPSAnV3JvbmcgbGVuZ3RoISc7XG5cbiAgdmFyICRtYXAgPSBjcmVhdGVBcnJheU1ldGhvZCgxLCBmdW5jdGlvbiAoTywgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFsbG9jYXRlKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pLCBsZW5ndGgpO1xuICB9KTtcblxuICB2YXIgTElUVExFX0VORElBTiA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQxNkFycmF5KFsxXSkuYnVmZmVyKVswXSA9PT0gMTtcbiAgfSk7XG5cbiAgdmFyIEZPUkNFRF9TRVQgPSAhIVVpbnQ4QXJyYXkgJiYgISFVaW50OEFycmF5W1BST1RPVFlQRV0uc2V0ICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgVWludDhBcnJheSgxKS5zZXQoe30pO1xuICB9KTtcblxuICB2YXIgdG9PZmZzZXQgPSBmdW5jdGlvbiAoaXQsIEJZVEVTKSB7XG4gICAgdmFyIG9mZnNldCA9IHRvSW50ZWdlcihpdCk7XG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICUgQllURVMpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCEnKTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIGlmIChpc09iamVjdChpdCkgJiYgVFlQRURfQVJSQVkgaW4gaXQpIHJldHVybiBpdDtcbiAgICB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIHR5cGVkIGFycmF5IScpO1xuICB9O1xuXG4gIHZhciBhbGxvY2F0ZSA9IGZ1bmN0aW9uIChDLCBsZW5ndGgpIHtcbiAgICBpZiAoIShpc09iamVjdChDKSAmJiBUWVBFRF9DT05TVFJVQ1RPUiBpbiBDKSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdJdCBpcyBub3QgYSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvciEnKTtcbiAgICB9IHJldHVybiBuZXcgQyhsZW5ndGgpO1xuICB9O1xuXG4gIHZhciBzcGVjaWVzRnJvbUxpc3QgPSBmdW5jdGlvbiAoTywgbGlzdCkge1xuICAgIHJldHVybiBmcm9tTGlzdChzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSwgbGlzdCk7XG4gIH07XG5cbiAgdmFyIGZyb21MaXN0ID0gZnVuY3Rpb24gKEMsIGxpc3QpIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gYWxsb2NhdGUoQywgbGVuZ3RoKTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHJlc3VsdFtpbmRleF0gPSBsaXN0W2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIGFkZEdldHRlciA9IGZ1bmN0aW9uIChpdCwga2V5LCBpbnRlcm5hbCkge1xuICAgIGRQKGl0LCBrZXksIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kW2ludGVybmFsXTsgfSB9KTtcbiAgfTtcblxuICB2YXIgJGZyb20gPSBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiAsIG1hcGZuLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdChzb3VyY2UpO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbWFwZm4gPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIGl0ZXJGbiA9IGdldEl0ZXJGbihPKTtcbiAgICB2YXIgaSwgbGVuZ3RoLCB2YWx1ZXMsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYgKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIWlzQXJyYXlJdGVyKGl0ZXJGbikpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgdmFsdWVzID0gW10sIGkgPSAwOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGkrKykge1xuICAgICAgICB2YWx1ZXMucHVzaChzdGVwLnZhbHVlKTtcbiAgICAgIH0gTyA9IHZhbHVlcztcbiAgICB9XG4gICAgaWYgKG1hcHBpbmcgJiYgYUxlbiA+IDIpIG1hcGZuID0gY3R4KG1hcGZuLCBhcmd1bWVudHNbMl0sIDIpO1xuICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKSwgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTsgbGVuZ3RoID4gaTsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBtYXBwaW5nID8gbWFwZm4oT1tpXSwgaSkgOiBPW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciAkb2YgPSBmdW5jdGlvbiBvZigvKiAuLi5pdGVtcyAqLykge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IGFsbG9jYXRlKHRoaXMsIGxlbmd0aCk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gaU9TIFNhZmFyaSA2LnggZmFpbHMgaGVyZVxuICB2YXIgVE9fTE9DQUxFX0JVRyA9ICEhVWludDhBcnJheSAmJiBmYWlscyhmdW5jdGlvbiAoKSB7IGFycmF5VG9Mb2NhbGVTdHJpbmcuY2FsbChuZXcgVWludDhBcnJheSgxKSk7IH0pO1xuXG4gIHZhciAkdG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZygpIHtcbiAgICByZXR1cm4gYXJyYXlUb0xvY2FsZVN0cmluZy5hcHBseShUT19MT0NBTEVfQlVHID8gYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpKSA6IHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHZhciBwcm90byA9IHtcbiAgICBjb3B5V2l0aGluOiBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldCwgc3RhcnQgLyogLCBlbmQgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUNvcHlXaXRoaW4uY2FsbCh2YWxpZGF0ZSh0aGlzKSwgdGFyZ2V0LCBzdGFydCwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlFdmVyeSh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZmlsbDogZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiAsIHN0YXJ0LCBlbmQgKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5RmlsbC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gc3BlY2llc0Zyb21MaXN0KHRoaXMsIGFycmF5RmlsdGVyKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLFxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCkpO1xuICAgIH0sXG4gICAgZmluZDogZnVuY3Rpb24gZmluZChwcmVkaWNhdGUgLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlGaW5kKHZhbGlkYXRlKHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KHByZWRpY2F0ZSAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUZpbmRJbmRleCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICBhcnJheUZvckVhY2godmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCAqLykge1xuICAgICAgcmV0dXJuIGFycmF5SW5kZXhPZih2YWxpZGF0ZSh0aGlzKSwgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUluY2x1ZGVzKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlKb2luLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5TGFzdEluZGV4T2YuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIG1hcChtYXBmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiAkbWFwKHZhbGlkYXRlKHRoaXMpLCBtYXBmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2UuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2VSaWdodC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIgbGVuZ3RoID0gdmFsaWRhdGUodGhhdCkubGVuZ3RoO1xuICAgICAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IobGVuZ3RoIC8gMik7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgd2hpbGUgKGluZGV4IDwgbWlkZGxlKSB7XG4gICAgICAgIHZhbHVlID0gdGhhdFtpbmRleF07XG4gICAgICAgIHRoYXRbaW5kZXgrK10gPSB0aGF0Wy0tbGVuZ3RoXTtcbiAgICAgICAgdGhhdFtsZW5ndGhdID0gdmFsdWU7XG4gICAgICB9IHJldHVybiB0aGF0O1xuICAgIH0sXG4gICAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIGFycmF5U29tZSh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pIHtcbiAgICAgIHJldHVybiBhcnJheVNvcnQuY2FsbCh2YWxpZGF0ZSh0aGlzKSwgY29tcGFyZWZuKTtcbiAgICB9LFxuICAgIHN1YmFycmF5OiBmdW5jdGlvbiBzdWJhcnJheShiZWdpbiwgZW5kKSB7XG4gICAgICB2YXIgTyA9IHZhbGlkYXRlKHRoaXMpO1xuICAgICAgdmFyIGxlbmd0aCA9IE8ubGVuZ3RoO1xuICAgICAgdmFyICRiZWdpbiA9IHRvQWJzb2x1dGVJbmRleChiZWdpbiwgbGVuZ3RoKTtcbiAgICAgIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pKShcbiAgICAgICAgTy5idWZmZXIsXG4gICAgICAgIE8uYnl0ZU9mZnNldCArICRiZWdpbiAqIE8uQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIHRvTGVuZ3RoKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbmd0aCkpIC0gJGJlZ2luKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyICRzbGljZSA9IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gc3BlY2llc0Zyb21MaXN0KHRoaXMsIGFycmF5U2xpY2UuY2FsbCh2YWxpZGF0ZSh0aGlzKSwgc3RhcnQsIGVuZCkpO1xuICB9O1xuXG4gIHZhciAkc2V0ID0gZnVuY3Rpb24gc2V0KGFycmF5TGlrZSAvKiAsIG9mZnNldCAqLykge1xuICAgIHZhbGlkYXRlKHRoaXMpO1xuICAgIHZhciBvZmZzZXQgPSB0b09mZnNldChhcmd1bWVudHNbMV0sIDEpO1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICB2YXIgc3JjID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgoc3JjLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBpZiAobGVuICsgb2Zmc2V0ID4gbGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgd2hpbGUgKGluZGV4IDwgbGVuKSB0aGlzW29mZnNldCArIGluZGV4XSA9IHNyY1tpbmRleCsrXTtcbiAgfTtcblxuICB2YXIgJGl0ZXJhdG9ycyA9IHtcbiAgICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIGFycmF5RW50cmllcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9LFxuICAgIGtleXM6IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICByZXR1cm4gYXJyYXlLZXlzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH0sXG4gICAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICByZXR1cm4gYXJyYXlWYWx1ZXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc1RBSW5kZXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICByZXR1cm4gaXNPYmplY3QodGFyZ2V0KVxuICAgICAgJiYgdGFyZ2V0W1RZUEVEX0FSUkFZXVxuICAgICAgJiYgdHlwZW9mIGtleSAhPSAnc3ltYm9sJ1xuICAgICAgJiYga2V5IGluIHRhcmdldFxuICAgICAgJiYgU3RyaW5nKCtrZXkpID09IFN0cmluZyhrZXkpO1xuICB9O1xuICB2YXIgJGdldERlc2MgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcbiAgICByZXR1cm4gaXNUQUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSlcbiAgICAgID8gcHJvcGVydHlEZXNjKDIsIHRhcmdldFtrZXldKVxuICAgICAgOiBnT1BEKHRhcmdldCwga2V5KTtcbiAgfTtcbiAgdmFyICRzZXREZXNjID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICBpZiAoaXNUQUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSlcbiAgICAgICYmIGlzT2JqZWN0KGRlc2MpXG4gICAgICAmJiBoYXMoZGVzYywgJ3ZhbHVlJylcbiAgICAgICYmICFoYXMoZGVzYywgJ2dldCcpXG4gICAgICAmJiAhaGFzKGRlc2MsICdzZXQnKVxuICAgICAgLy8gVE9ETzogYWRkIHZhbGlkYXRpb24gZGVzY3JpcHRvciB3L28gY2FsbGluZyBhY2Nlc3NvcnNcbiAgICAgICYmICFkZXNjLmNvbmZpZ3VyYWJsZVxuICAgICAgJiYgKCFoYXMoZGVzYywgJ3dyaXRhYmxlJykgfHwgZGVzYy53cml0YWJsZSlcbiAgICAgICYmICghaGFzKGRlc2MsICdlbnVtZXJhYmxlJykgfHwgZGVzYy5lbnVtZXJhYmxlKVxuICAgICkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBkZXNjLnZhbHVlO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9IHJldHVybiBkUCh0YXJnZXQsIGtleSwgZGVzYyk7XG4gIH07XG5cbiAgaWYgKCFBTExfQ09OU1RSVUNUT1JTKSB7XG4gICAgJEdPUEQuZiA9ICRnZXREZXNjO1xuICAgICREUC5mID0gJHNldERlc2M7XG4gIH1cblxuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFBTExfQ09OU1RSVUNUT1JTLCAnT2JqZWN0Jywge1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldERlc2MsXG4gICAgZGVmaW5lUHJvcGVydHk6ICRzZXREZXNjXG4gIH0pO1xuXG4gIGlmIChmYWlscyhmdW5jdGlvbiAoKSB7IGFycmF5VG9TdHJpbmcuY2FsbCh7fSk7IH0pKSB7XG4gICAgYXJyYXlUb1N0cmluZyA9IGFycmF5VG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBhcnJheUpvaW4uY2FsbCh0aGlzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyICRUeXBlZEFycmF5UHJvdG90eXBlJCA9IHJlZGVmaW5lQWxsKHt9LCBwcm90byk7XG4gIHJlZGVmaW5lQWxsKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJGl0ZXJhdG9ycyk7XG4gIGhpZGUoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCBJVEVSQVRPUiwgJGl0ZXJhdG9ycy52YWx1ZXMpO1xuICByZWRlZmluZUFsbCgkVHlwZWRBcnJheVByb3RvdHlwZSQsIHtcbiAgICBzbGljZTogJHNsaWNlLFxuICAgIHNldDogJHNldCxcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkgeyAvKiBub29wICovIH0sXG4gICAgdG9TdHJpbmc6IGFycmF5VG9TdHJpbmcsXG4gICAgdG9Mb2NhbGVTdHJpbmc6ICR0b0xvY2FsZVN0cmluZ1xuICB9KTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J1ZmZlcicsICdiJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdieXRlT2Zmc2V0JywgJ28nKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J5dGVMZW5ndGgnLCAnbCcpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnbGVuZ3RoJywgJ2UnKTtcbiAgZFAoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCBUQUcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXNbVFlQRURfQVJSQVldOyB9XG4gIH0pO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50c1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIEJZVEVTLCB3cmFwcGVyLCBDTEFNUEVEKSB7XG4gICAgQ0xBTVBFRCA9ICEhQ0xBTVBFRDtcbiAgICB2YXIgTkFNRSA9IEtFWSArIChDTEFNUEVEID8gJ0NsYW1wZWQnIDogJycpICsgJ0FycmF5JztcbiAgICB2YXIgR0VUVEVSID0gJ2dldCcgKyBLRVk7XG4gICAgdmFyIFNFVFRFUiA9ICdzZXQnICsgS0VZO1xuICAgIHZhciBUeXBlZEFycmF5ID0gZ2xvYmFsW05BTUVdO1xuICAgIHZhciBCYXNlID0gVHlwZWRBcnJheSB8fCB7fTtcbiAgICB2YXIgVEFDID0gVHlwZWRBcnJheSAmJiBnZXRQcm90b3R5cGVPZihUeXBlZEFycmF5KTtcbiAgICB2YXIgRk9SQ0VEID0gIVR5cGVkQXJyYXkgfHwgISR0eXBlZC5BQlY7XG4gICAgdmFyIE8gPSB7fTtcbiAgICB2YXIgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXkgJiYgVHlwZWRBcnJheVtQUk9UT1RZUEVdO1xuICAgIHZhciBnZXR0ZXIgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgpIHtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIHJldHVybiBkYXRhLnZbR0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoYXQuX2Q7XG4gICAgICBpZiAoQ0xBTVBFRCkgdmFsdWUgPSAodmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKSkgPCAwID8gMCA6IHZhbHVlID4gMHhmZiA/IDB4ZmYgOiB2YWx1ZSAmIDB4ZmY7XG4gICAgICBkYXRhLnZbU0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCB2YWx1ZSwgTElUVExFX0VORElBTik7XG4gICAgfTtcbiAgICB2YXIgYWRkRWxlbWVudCA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xuICAgICAgZFAodGhhdCwgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldHRlcih0aGlzLCBpbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHNldHRlcih0aGlzLCBpbmRleCwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIHtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSwgJ19kJyk7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICB2YXIgYnVmZmVyLCBieXRlTGVuZ3RoLCBsZW5ndGgsIGtsYXNzO1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgICAgbGVuZ3RoID0gdG9JbmRleChkYXRhKTtcbiAgICAgICAgICBieXRlTGVuZ3RoID0gbGVuZ3RoICogQllURVM7XG4gICAgICAgICAgYnVmZmVyID0gbmV3ICRBcnJheUJ1ZmZlcihieXRlTGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKSB7XG4gICAgICAgICAgYnVmZmVyID0gZGF0YTtcbiAgICAgICAgICBvZmZzZXQgPSB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUyk7XG4gICAgICAgICAgdmFyICRsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgaWYgKCRsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCRsZW4gJSBCWVRFUykgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9ICRsZW4gLSBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCA8IDApIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9IHRvTGVuZ3RoKCRsZW5ndGgpICogQllURVM7XG4gICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCArIG9mZnNldCA+ICRsZW4pIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoID0gYnl0ZUxlbmd0aCAvIEJZVEVTO1xuICAgICAgICB9IGVsc2UgaWYgKFRZUEVEX0FSUkFZIGluIGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZSh0aGF0LCAnX2QnLCB7XG4gICAgICAgICAgYjogYnVmZmVyLFxuICAgICAgICAgIG86IG9mZnNldCxcbiAgICAgICAgICBsOiBieXRlTGVuZ3RoLFxuICAgICAgICAgIGU6IGxlbmd0aCxcbiAgICAgICAgICB2OiBuZXcgJERhdGFWaWV3KGJ1ZmZlcilcbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkgYWRkRWxlbWVudCh0aGF0LCBpbmRleCsrKTtcbiAgICAgIH0pO1xuICAgICAgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IGNyZWF0ZSgkVHlwZWRBcnJheVByb3RvdHlwZSQpO1xuICAgICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCAnY29uc3RydWN0b3InLCBUeXBlZEFycmF5KTtcbiAgICB9IGVsc2UgaWYgKCFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBUeXBlZEFycmF5KDEpO1xuICAgIH0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBuZXcgVHlwZWRBcnJheSgtMSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfSkgfHwgISRpdGVyRGV0ZWN0KGZ1bmN0aW9uIChpdGVyKSB7XG4gICAgICBuZXcgVHlwZWRBcnJheSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkobnVsbCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICBuZXcgVHlwZWRBcnJheSgxLjUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkoaXRlcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfSwgdHJ1ZSkpIHtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSk7XG4gICAgICAgIHZhciBrbGFzcztcbiAgICAgICAgLy8gYHdzYCBtb2R1bGUgYnVnLCB0ZW1wb3JhcmlseSByZW1vdmUgdmFsaWRhdGlvbiBsZW5ndGggZm9yIFVpbnQ4QXJyYXlcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvcHVsbC82NDVcbiAgICAgICAgaWYgKCFpc09iamVjdChkYXRhKSkgcmV0dXJuIG5ldyBCYXNlKHRvSW5kZXgoZGF0YSkpO1xuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mICRBcnJheUJ1ZmZlciB8fCAoa2xhc3MgPSBjbGFzc29mKGRhdGEpKSA9PSBBUlJBWV9CVUZGRVIgfHwga2xhc3MgPT0gU0hBUkVEX0JVRkZFUikge1xuICAgICAgICAgIHJldHVybiAkbGVuZ3RoICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpLCAkbGVuZ3RoKVxuICAgICAgICAgICAgOiAkb2Zmc2V0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyBuZXcgQmFzZShkYXRhLCB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUykpXG4gICAgICAgICAgICAgIDogbmV3IEJhc2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFRZUEVEX0FSUkFZIGluIGRhdGEpIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIGFycmF5Rm9yRWFjaChUQUMgIT09IEZ1bmN0aW9uLnByb3RvdHlwZSA/IGdPUE4oQmFzZSkuY29uY2F0KGdPUE4oVEFDKSkgOiBnT1BOKEJhc2UpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiBUeXBlZEFycmF5KSkgaGlkZShUeXBlZEFycmF5LCBrZXksIEJhc2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IFR5cGVkQXJyYXlQcm90b3R5cGU7XG4gICAgICBpZiAoIUxJQlJBUlkpIFR5cGVkQXJyYXlQcm90b3R5cGUuY29uc3RydWN0b3IgPSBUeXBlZEFycmF5O1xuICAgIH1cbiAgICB2YXIgJG5hdGl2ZUl0ZXJhdG9yID0gVHlwZWRBcnJheVByb3RvdHlwZVtJVEVSQVRPUl07XG4gICAgdmFyIENPUlJFQ1RfSVRFUl9OQU1FID0gISEkbmF0aXZlSXRlcmF0b3JcbiAgICAgICYmICgkbmF0aXZlSXRlcmF0b3IubmFtZSA9PSAndmFsdWVzJyB8fCAkbmF0aXZlSXRlcmF0b3IubmFtZSA9PSB1bmRlZmluZWQpO1xuICAgIHZhciAkaXRlcmF0b3IgPSAkaXRlcmF0b3JzLnZhbHVlcztcbiAgICBoaWRlKFR5cGVkQXJyYXksIFRZUEVEX0NPTlNUUlVDVE9SLCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRZUEVEX0FSUkFZLCBOQU1FKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgREVGX0NPTlNUUlVDVE9SLCBUeXBlZEFycmF5KTtcblxuICAgIGlmIChDTEFNUEVEID8gbmV3IFR5cGVkQXJyYXkoMSlbVEFHXSAhPSBOQU1FIDogIShUQUcgaW4gVHlwZWRBcnJheVByb3RvdHlwZSkpIHtcbiAgICAgIGRQKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRBRywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5BTUU7IH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIE9bTkFNRV0gPSBUeXBlZEFycmF5O1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoVHlwZWRBcnJheSAhPSBCYXNlKSwgTyk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUywgTkFNRSwge1xuICAgICAgQllURVNfUEVSX0VMRU1FTlQ6IEJZVEVTXG4gICAgfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgQmFzZS5vZi5jYWxsKFR5cGVkQXJyYXksIDEpOyB9KSwgTkFNRSwge1xuICAgICAgZnJvbTogJGZyb20sXG4gICAgICBvZjogJG9mXG4gICAgfSk7XG5cbiAgICBpZiAoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSkgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBCWVRFU19QRVJfRUxFTUVOVCwgQllURVMpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAsIE5BTUUsIHByb3RvKTtcblxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIEZPUkNFRF9TRVQsIE5BTUUsIHsgc2V0OiAkc2V0IH0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhQ09SUkVDVF9JVEVSX05BTUUsIE5BTUUsICRpdGVyYXRvcnMpO1xuXG4gICAgaWYgKCFMSUJSQVJZICYmIFR5cGVkQXJyYXlQcm90b3R5cGUudG9TdHJpbmcgIT0gYXJyYXlUb1N0cmluZykgVHlwZWRBcnJheVByb3RvdHlwZS50b1N0cmluZyA9IGFycmF5VG9TdHJpbmc7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIG5ldyBUeXBlZEFycmF5KDEpLnNsaWNlKCk7XG4gICAgfSksIE5BTUUsIHsgc2xpY2U6ICRzbGljZSB9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbMSwgMl0udG9Mb2NhbGVTdHJpbmcoKSAhPSBuZXcgVHlwZWRBcnJheShbMSwgMl0pLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcuY2FsbChbMSwgMl0pO1xuICAgIH0pKSwgTkFNRSwgeyB0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nIH0pO1xuXG4gICAgSXRlcmF0b3JzW05BTUVdID0gQ09SUkVDVF9JVEVSX05BTUUgPyAkbmF0aXZlSXRlcmF0b3IgOiAkaXRlcmF0b3I7XG4gICAgaWYgKCFMSUJSQVJZICYmICFDT1JSRUNUX0lURVJfTkFNRSkgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBJVEVSQVRPUiwgJGl0ZXJhdG9yKTtcbiAgfTtcbn0gZWxzZSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciAkdHlwZWQgPSByZXF1aXJlKCcuL190eXBlZCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9JbmRleCA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgYXJyYXlGaWxsID0gcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xudmFyIERBVEFfVklFVyA9ICdEYXRhVmlldyc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgV1JPTkdfTEVOR1RIID0gJ1dyb25nIGxlbmd0aCEnO1xudmFyIFdST05HX0lOREVYID0gJ1dyb25nIGluZGV4ISc7XG52YXIgJEFycmF5QnVmZmVyID0gZ2xvYmFsW0FSUkFZX0JVRkZFUl07XG52YXIgJERhdGFWaWV3ID0gZ2xvYmFsW0RBVEFfVklFV107XG52YXIgTWF0aCA9IGdsb2JhbC5NYXRoO1xudmFyIFJhbmdlRXJyb3IgPSBnbG9iYWwuUmFuZ2VFcnJvcjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3ctcmVzdHJpY3RlZC1uYW1lc1xudmFyIEluZmluaXR5ID0gZ2xvYmFsLkluZmluaXR5O1xudmFyIEJhc2VCdWZmZXIgPSAkQXJyYXlCdWZmZXI7XG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgcG93ID0gTWF0aC5wb3c7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIGxvZyA9IE1hdGgubG9nO1xudmFyIExOMiA9IE1hdGguTE4yO1xudmFyIEJVRkZFUiA9ICdidWZmZXInO1xudmFyIEJZVEVfTEVOR1RIID0gJ2J5dGVMZW5ndGgnO1xudmFyIEJZVEVfT0ZGU0VUID0gJ2J5dGVPZmZzZXQnO1xudmFyICRCVUZGRVIgPSBERVNDUklQVE9SUyA/ICdfYicgOiBCVUZGRVI7XG52YXIgJExFTkdUSCA9IERFU0NSSVBUT1JTID8gJ19sJyA6IEJZVEVfTEVOR1RIO1xudmFyICRPRkZTRVQgPSBERVNDUklQVE9SUyA/ICdfbycgOiBCWVRFX09GRlNFVDtcblxuLy8gSUVFRTc1NCBjb252ZXJzaW9ucyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2llZWU3NTRcbmZ1bmN0aW9uIHBhY2tJRUVFNzU0KHZhbHVlLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShuQnl0ZXMpO1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIHJ0ID0gbUxlbiA9PT0gMjMgPyBwb3coMiwgLTI0KSAtIHBvdygyLCAtNzcpIDogMDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwID8gMSA6IDA7XG4gIHZhciBlLCBtLCBjO1xuICB2YWx1ZSA9IGFicyh2YWx1ZSk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgaWYgKHZhbHVlICE9IHZhbHVlIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBtID0gdmFsdWUgIT0gdmFsdWUgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gZmxvb3IobG9nKHZhbHVlKSAvIExOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBwb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogcG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIHBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIHBvdygyLCBlQmlhcyAtIDEpICogcG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltpKytdID0gbSAmIDI1NSwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG4gIGUgPSBlIDw8IG1MZW4gfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW2krK10gPSBlICYgMjU1LCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcbiAgYnVmZmVyWy0taV0gfD0gcyAqIDEyODtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIHVucGFja0lFRUU3NTQoYnVmZmVyLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBuQml0cyA9IGVMZW4gLSA3O1xuICB2YXIgaSA9IG5CeXRlcyAtIDE7XG4gIHZhciBzID0gYnVmZmVyW2ktLV07XG4gIHZhciBlID0gcyAmIDEyNztcbiAgdmFyIG07XG4gIHMgPj49IDc7XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW2ldLCBpLS0sIG5CaXRzIC09IDgpO1xuICBtID0gZSAmICgxIDw8IC1uQml0cykgLSAxO1xuICBlID4+PSAtbkJpdHM7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW2ldLCBpLS0sIG5CaXRzIC09IDgpO1xuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogcyA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgcG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH0gcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBwb3coMiwgZSAtIG1MZW4pO1xufVxuXG5mdW5jdGlvbiB1bnBhY2tJMzIoYnl0ZXMpIHtcbiAgcmV0dXJuIGJ5dGVzWzNdIDw8IDI0IHwgYnl0ZXNbMl0gPDwgMTYgfCBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG59XG5mdW5jdGlvbiBwYWNrSTgoaXQpIHtcbiAgcmV0dXJuIFtpdCAmIDB4ZmZdO1xufVxuZnVuY3Rpb24gcGFja0kxNihpdCkge1xuICByZXR1cm4gW2l0ICYgMHhmZiwgaXQgPj4gOCAmIDB4ZmZdO1xufVxuZnVuY3Rpb24gcGFja0kzMihpdCkge1xuICByZXR1cm4gW2l0ICYgMHhmZiwgaXQgPj4gOCAmIDB4ZmYsIGl0ID4+IDE2ICYgMHhmZiwgaXQgPj4gMjQgJiAweGZmXTtcbn1cbmZ1bmN0aW9uIHBhY2tGNjQoaXQpIHtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KGl0LCA1MiwgOCk7XG59XG5mdW5jdGlvbiBwYWNrRjMyKGl0KSB7XG4gIHJldHVybiBwYWNrSUVFRTc1NChpdCwgMjMsIDQpO1xufVxuXG5mdW5jdGlvbiBhZGRHZXR0ZXIoQywga2V5LCBpbnRlcm5hbCkge1xuICBkUChDW1BST1RPVFlQRV0sIGtleSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXNbaW50ZXJuYWxdOyB9IH0pO1xufVxuXG5mdW5jdGlvbiBnZXQodmlldywgYnl0ZXMsIGluZGV4LCBpc0xpdHRsZUVuZGlhbikge1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXg7XG4gIHZhciBpbnRJbmRleCA9IHRvSW5kZXgobnVtSW5kZXgpO1xuICBpZiAoaW50SW5kZXggKyBieXRlcyA+IHZpZXdbJExFTkdUSF0pIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iO1xuICB2YXIgc3RhcnQgPSBpbnRJbmRleCArIHZpZXdbJE9GRlNFVF07XG4gIHZhciBwYWNrID0gc3RvcmUuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgYnl0ZXMpO1xuICByZXR1cm4gaXNMaXR0bGVFbmRpYW4gPyBwYWNrIDogcGFjay5yZXZlcnNlKCk7XG59XG5mdW5jdGlvbiBzZXQodmlldywgYnl0ZXMsIGluZGV4LCBjb252ZXJzaW9uLCB2YWx1ZSwgaXNMaXR0bGVFbmRpYW4pIHtcbiAgdmFyIG51bUluZGV4ID0gK2luZGV4O1xuICB2YXIgaW50SW5kZXggPSB0b0luZGV4KG51bUluZGV4KTtcbiAgaWYgKGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0lOREVYKTtcbiAgdmFyIHN0b3JlID0gdmlld1skQlVGRkVSXS5fYjtcbiAgdmFyIHN0YXJ0ID0gaW50SW5kZXggKyB2aWV3WyRPRkZTRVRdO1xuICB2YXIgcGFjayA9IGNvbnZlcnNpb24oK3ZhbHVlKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlczsgaSsrKSBzdG9yZVtzdGFydCArIGldID0gcGFja1tpc0xpdHRsZUVuZGlhbiA/IGkgOiBieXRlcyAtIGkgLSAxXTtcbn1cblxuaWYgKCEkdHlwZWQuQUJWKSB7XG4gICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCkge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuICAgIHZhciBieXRlTGVuZ3RoID0gdG9JbmRleChsZW5ndGgpO1xuICAgIHRoaXMuX2IgPSBhcnJheUZpbGwuY2FsbChuZXcgQXJyYXkoYnl0ZUxlbmd0aCksIDApO1xuICAgIHRoaXNbJExFTkdUSF0gPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gICREYXRhVmlldyA9IGZ1bmN0aW9uIERhdGFWaWV3KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuICAgIGFuSW5zdGFuY2UoYnVmZmVyLCAkQXJyYXlCdWZmZXIsIERBVEFfVklFVyk7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJ1ZmZlclskTEVOR1RIXTtcbiAgICB2YXIgb2Zmc2V0ID0gdG9JbnRlZ2VyKGJ5dGVPZmZzZXQpO1xuICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGJ1ZmZlckxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID09PSB1bmRlZmluZWQgPyBidWZmZXJMZW5ndGggLSBvZmZzZXQgOiB0b0xlbmd0aChieXRlTGVuZ3RoKTtcbiAgICBpZiAob2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlckxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHRoaXNbJEJVRkZFUl0gPSBidWZmZXI7XG4gICAgdGhpc1skT0ZGU0VUXSA9IG9mZnNldDtcbiAgICB0aGlzWyRMRU5HVEhdID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICBpZiAoREVTQ1JJUFRPUlMpIHtcbiAgICBhZGRHZXR0ZXIoJEFycmF5QnVmZmVyLCBCWVRFX0xFTkdUSCwgJ19sJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQlVGRkVSLCAnX2InKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCWVRFX0xFTkdUSCwgJ19sJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQllURV9PRkZTRVQsICdfbycpO1xuICB9XG5cbiAgcmVkZWZpbmVBbGwoJERhdGFWaWV3W1BST1RPVFlQRV0sIHtcbiAgICBnZXRJbnQ4OiBmdW5jdGlvbiBnZXRJbnQ4KGJ5dGVPZmZzZXQpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF0gPDwgMjQgPj4gMjQ7XG4gICAgfSxcbiAgICBnZXRVaW50ODogZnVuY3Rpb24gZ2V0VWludDgoYnl0ZU9mZnNldCkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXTtcbiAgICB9LFxuICAgIGdldEludDE2OiBmdW5jdGlvbiBnZXRJbnQxNihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKTtcbiAgICAgIHJldHVybiAoYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdKSA8PCAxNiA+PiAxNjtcbiAgICB9LFxuICAgIGdldFVpbnQxNjogZnVuY3Rpb24gZ2V0VWludDE2KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pO1xuICAgICAgcmV0dXJuIGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcbiAgICB9LFxuICAgIGdldEludDMyOiBmdW5jdGlvbiBnZXRJbnQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSTMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKTtcbiAgICB9LFxuICAgIGdldFVpbnQzMjogZnVuY3Rpb24gZ2V0VWludDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpID4+PiAwO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQzMjogZnVuY3Rpb24gZ2V0RmxvYXQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSwgMjMsIDQpO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQ2NDogZnVuY3Rpb24gZ2V0RmxvYXQ2NChieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSwgNTIsIDgpO1xuICAgIH0sXG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJOCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRJbnQxNjogZnVuY3Rpb24gc2V0SW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSTE2LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldFVpbnQxNjogZnVuY3Rpb24gc2V0VWludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0kxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRJbnQzMjogZnVuY3Rpb24gc2V0SW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldFVpbnQzMjogZnVuY3Rpb24gc2V0VWludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0kzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDMyOiBmdW5jdGlvbiBzZXRGbG9hdDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0YzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDY0OiBmdW5jdGlvbiBzZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgcGFja0Y2NCwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIGlmICghZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICRBcnJheUJ1ZmZlcigxKTtcbiAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgJEFycmF5QnVmZmVyKC0xKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgfSkgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBuZXcgJEFycmF5QnVmZmVyKDEuNSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbmV3ICRBcnJheUJ1ZmZlcihOYU4pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIHJldHVybiAkQXJyYXlCdWZmZXIubmFtZSAhPSBBUlJBWV9CVUZGRVI7XG4gIH0pKSB7XG4gICAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgICBhbkluc3RhbmNlKHRoaXMsICRBcnJheUJ1ZmZlcik7XG4gICAgICByZXR1cm4gbmV3IEJhc2VCdWZmZXIodG9JbmRleChsZW5ndGgpKTtcbiAgICB9O1xuICAgIHZhciBBcnJheUJ1ZmZlclByb3RvID0gJEFycmF5QnVmZmVyW1BST1RPVFlQRV0gPSBCYXNlQnVmZmVyW1BST1RPVFlQRV07XG4gICAgZm9yICh2YXIga2V5cyA9IGdPUE4oQmFzZUJ1ZmZlciksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajspIHtcbiAgICAgIGlmICghKChrZXkgPSBrZXlzW2orK10pIGluICRBcnJheUJ1ZmZlcikpIGhpZGUoJEFycmF5QnVmZmVyLCBrZXksIEJhc2VCdWZmZXJba2V5XSk7XG4gICAgfVxuICAgIGlmICghTElCUkFSWSkgQXJyYXlCdWZmZXJQcm90by5jb25zdHJ1Y3RvciA9ICRBcnJheUJ1ZmZlcjtcbiAgfVxuICAvLyBpT1MgU2FmYXJpIDcueCBidWdcbiAgdmFyIHZpZXcgPSBuZXcgJERhdGFWaWV3KG5ldyAkQXJyYXlCdWZmZXIoMikpO1xuICB2YXIgJHNldEludDggPSAkRGF0YVZpZXdbUFJPVE9UWVBFXS5zZXRJbnQ4O1xuICB2aWV3LnNldEludDgoMCwgMjE0NzQ4MzY0OCk7XG4gIHZpZXcuc2V0SW50OCgxLCAyMTQ3NDgzNjQ5KTtcbiAgaWYgKHZpZXcuZ2V0SW50OCgwKSB8fCAhdmlldy5nZXRJbnQ4KDEpKSByZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgICRzZXRJbnQ4LmNhbGwodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICAkc2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9XG4gIH0sIHRydWUpO1xufVxuc2V0VG9TdHJpbmdUYWcoJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuc2V0VG9TdHJpbmdUYWcoJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuaGlkZSgkRGF0YVZpZXdbUFJPVE9UWVBFXSwgJHR5cGVkLlZJRVcsIHRydWUpO1xuZXhwb3J0c1tBUlJBWV9CVUZGRVJdID0gJEFycmF5QnVmZmVyO1xuZXhwb3J0c1tEQVRBX1ZJRVddID0gJERhdGFWaWV3O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgVFlQRUQgPSB1aWQoJ3R5cGVkX2FycmF5Jyk7XG52YXIgVklFVyA9IHVpZCgndmlldycpO1xudmFyIEFCViA9ICEhKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBnbG9iYWwuRGF0YVZpZXcpO1xudmFyIENPTlNUUiA9IEFCVjtcbnZhciBpID0gMDtcbnZhciBsID0gOTtcbnZhciBUeXBlZDtcblxudmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMgPSAoXG4gICdJbnQ4QXJyYXksVWludDhBcnJheSxVaW50OENsYW1wZWRBcnJheSxJbnQxNkFycmF5LFVpbnQxNkFycmF5LEludDMyQXJyYXksVWludDMyQXJyYXksRmxvYXQzMkFycmF5LEZsb2F0NjRBcnJheSdcbikuc3BsaXQoJywnKTtcblxud2hpbGUgKGkgPCBsKSB7XG4gIGlmIChUeXBlZCA9IGdsb2JhbFtUeXBlZEFycmF5Q29uc3RydWN0b3JzW2krK11dKSB7XG4gICAgaGlkZShUeXBlZC5wcm90b3R5cGUsIFRZUEVELCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkLnByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gIH0gZWxzZSBDT05TVFIgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFCVjogQUJWLFxuICBDT05TVFI6IENPTlNUUixcbiAgVFlQRUQ6IFRZUEVELFxuICBWSUVXOiBWSUVXXG59O1xuIiwidmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgbmF2aWdhdG9yID0gZ2xvYmFsLm5hdmlnYXRvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFRZUEUpIHtcbiAgaWYgKCFpc09iamVjdChpdCkgfHwgaXQuX3QgIT09IFRZUEUpIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmIChuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKSBkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7IHZhbHVlOiB3a3NFeHQuZihuYW1lKSB9KTtcbn07XG4iLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTtcbiIsInZhciBzdG9yZSA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2w7XG52YXIgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuIiwiLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5JywgeyBjb3B5V2l0aGluOiByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpIH0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnY29weVdpdGhpbicpO1xuIiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5JywgeyBmaWxsOiByZXF1aXJlKCcuL19hcnJheS1maWxsJykgfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdmaWxsJyk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGZpbmQgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNik7XG52YXIgS0VZID0gJ2ZpbmRJbmRleCc7XG52YXIgZm9yY2VkID0gdHJ1ZTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZiAoS0VZIGluIFtdKSBBcnJheSgxKVtLRVldKGZ1bmN0aW9uICgpIHsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgoY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKEtFWSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOCBBcnJheS5wcm90b3R5cGUuZmluZChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmaW5kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDUpO1xudmFyIEtFWSA9ICdmaW5kJztcbnZhciBmb3JjZWQgPSB0cnVlO1xuLy8gU2hvdWxkbid0IHNraXAgaG9sZXNcbmlmIChLRVkgaW4gW10pIEFycmF5KDEpW0tFWV0oZnVuY3Rpb24gKCkgeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kOiBmdW5jdGlvbiBmaW5kKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKShLRVkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikgeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlIC8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi8pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gICAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5O1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbWFwZm4gPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgaXRlckZuID0gZ2V0SXRlckZuKE8pO1xuICAgIHZhciBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYgKG1hcHBpbmcpIG1hcGZuID0gY3R4KG1hcGZuLCBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG4gICAgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG4gICAgaWYgKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKSB7XG4gICAgICBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDKCk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gY2FsbChpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICAgIGZvciAocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG5cbi8vIFdlYktpdCBBcnJheS5vZiBpc24ndCBnZW5lcmljXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiAhKEFycmF5Lm9mLmNhbGwoRikgaW5zdGFuY2VvZiBGKTtcbn0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4zIEFycmF5Lm9mKCAuLi5pdGVtcylcbiAgb2Y6IGZ1bmN0aW9uIG9mKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gbmV3ICh0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5KShhTGVuKTtcbiAgICB3aGlsZSAoYUxlbiA+IGluZGV4KSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHJlc3VsdC5sZW5ndGggPSBhTGVuO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBGUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgbmFtZVJFID0gL15cXHMqZnVuY3Rpb24gKFteIChdKikvO1xudmFyIE5BTUUgPSAnbmFtZSc7XG5cbi8vIDE5LjIuNC4yIG5hbWVcbk5BTUUgaW4gRlByb3RvIHx8IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgZFAoRlByb3RvLCBOQU1FLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoJycgKyB0aGlzKS5tYXRjaChuYW1lUkUpWzFdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgTUFQID0gJ01hcCc7XG5cbi8vIDIzLjEgTWFwIE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKE1BUCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gTWFwKCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMS4zLjYgTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICB2YXIgZW50cnkgPSBzdHJvbmcuZ2V0RW50cnkodmFsaWRhdGUodGhpcywgTUFQKSwga2V5KTtcbiAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudjtcbiAgfSxcbiAgLy8gMjMuMS4zLjkgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHZhbGlkYXRlKHRoaXMsIE1BUCksIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nLCB0cnVlKTtcbiIsIi8vIDIwLjIuMi4zIE1hdGguYWNvc2goeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgbG9nMXAgPSByZXF1aXJlKCcuL19tYXRoLWxvZzFwJyk7XG52YXIgc3FydCA9IE1hdGguc3FydDtcbnZhciAkYWNvc2ggPSBNYXRoLmFjb3NoO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGFjb3NoXG4gIC8vIFY4IGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM1MDlcbiAgJiYgTWF0aC5mbG9vcigkYWNvc2goTnVtYmVyLk1BWF9WQUxVRSkpID09IDcxMFxuICAvLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYWNvc2goSW5maW5pdHkpIC0+IE5hTlxuICAmJiAkYWNvc2goSW5maW5pdHkpID09IEluZmluaXR5XG4pLCAnTWF0aCcsIHtcbiAgYWNvc2g6IGZ1bmN0aW9uIGFjb3NoKHgpIHtcbiAgICByZXR1cm4gKHggPSAreCkgPCAxID8gTmFOIDogeCA+IDk0OTA2MjY1LjYyNDI1MTU2XG4gICAgICA/IE1hdGgubG9nKHgpICsgTWF0aC5MTjJcbiAgICAgIDogbG9nMXAoeCAtIDEgKyBzcXJ0KHggLSAxKSAqIHNxcnQoeCArIDEpKTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuNSBNYXRoLmFzaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRhc2luaCA9IE1hdGguYXNpbmg7XG5cbmZ1bmN0aW9uIGFzaW5oKHgpIHtcbiAgcmV0dXJuICFpc0Zpbml0ZSh4ID0gK3gpIHx8IHggPT0gMCA/IHggOiB4IDwgMCA/IC1hc2luaCgteCkgOiBNYXRoLmxvZyh4ICsgTWF0aC5zcXJ0KHggKiB4ICsgMSkpO1xufVxuXG4vLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYXNpbmgoMCkgLT4gLTBcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXNpbmggJiYgMSAvICRhc2luaCgwKSA+IDApLCAnTWF0aCcsIHsgYXNpbmg6IGFzaW5oIH0pO1xuIiwiLy8gMjAuMi4yLjcgTWF0aC5hdGFuaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkYXRhbmggPSBNYXRoLmF0YW5oO1xuXG4vLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYXRhbmgoLTApIC0+IDBcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXRhbmggJiYgMSAvICRhdGFuaCgtMCkgPCAwKSwgJ01hdGgnLCB7XG4gIGF0YW5oOiBmdW5jdGlvbiBhdGFuaCh4KSB7XG4gICAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogTWF0aC5sb2coKDEgKyB4KSAvICgxIC0geCkpIC8gMjtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuOSBNYXRoLmNicnQoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNicnQ6IGZ1bmN0aW9uIGNicnQoeCkge1xuICAgIHJldHVybiBzaWduKHggPSAreCkgKiBNYXRoLnBvdyhNYXRoLmFicyh4KSwgMSAvIDMpO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4xMSBNYXRoLmNsejMyKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNsejMyOiBmdW5jdGlvbiBjbHozMih4KSB7XG4gICAgcmV0dXJuICh4ID4+Pj0gMCkgPyAzMSAtIE1hdGguZmxvb3IoTWF0aC5sb2coeCArIDAuNSkgKiBNYXRoLkxPRzJFKSA6IDMyO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4xMiBNYXRoLmNvc2goeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZXhwID0gTWF0aC5leHA7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY29zaDogZnVuY3Rpb24gY29zaCh4KSB7XG4gICAgcmV0dXJuIChleHAoeCA9ICt4KSArIGV4cCgteCkpIC8gMjtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZXhwbTEgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCRleHBtMSAhPSBNYXRoLmV4cG0xKSwgJ01hdGgnLCB7IGV4cG0xOiAkZXhwbTEgfSk7XG4iLCIvLyAyMC4yLjIuMTYgTWF0aC5mcm91bmQoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgZnJvdW5kOiByZXF1aXJlKCcuL19tYXRoLWZyb3VuZCcpIH0pO1xuIiwiLy8gMjAuMi4yLjE3IE1hdGguaHlwb3QoW3ZhbHVlMVssIHZhbHVlMlssIOKApiBdXV0pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFicyA9IE1hdGguYWJzO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGh5cG90OiBmdW5jdGlvbiBoeXBvdCh2YWx1ZTEsIHZhbHVlMikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbGFyZyA9IDA7XG4gICAgdmFyIGFyZywgZGl2O1xuICAgIHdoaWxlIChpIDwgYUxlbikge1xuICAgICAgYXJnID0gYWJzKGFyZ3VtZW50c1tpKytdKTtcbiAgICAgIGlmIChsYXJnIDwgYXJnKSB7XG4gICAgICAgIGRpdiA9IGxhcmcgLyBhcmc7XG4gICAgICAgIHN1bSA9IHN1bSAqIGRpdiAqIGRpdiArIDE7XG4gICAgICAgIGxhcmcgPSBhcmc7XG4gICAgICB9IGVsc2UgaWYgKGFyZyA+IDApIHtcbiAgICAgICAgZGl2ID0gYXJnIC8gbGFyZztcbiAgICAgICAgc3VtICs9IGRpdiAqIGRpdjtcbiAgICAgIH0gZWxzZSBzdW0gKz0gYXJnO1xuICAgIH1cbiAgICByZXR1cm4gbGFyZyA9PT0gSW5maW5pdHkgPyBJbmZpbml0eSA6IGxhcmcgKiBNYXRoLnNxcnQoc3VtKTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMTggTWF0aC5pbXVsKHgsIHkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRpbXVsID0gTWF0aC5pbXVsO1xuXG4vLyBzb21lIFdlYktpdCB2ZXJzaW9ucyBmYWlscyB3aXRoIGJpZyBudW1iZXJzLCBzb21lIGhhcyB3cm9uZyBhcml0eVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICRpbXVsKDB4ZmZmZmZmZmYsIDUpICE9IC01IHx8ICRpbXVsLmxlbmd0aCAhPSAyO1xufSksICdNYXRoJywge1xuICBpbXVsOiBmdW5jdGlvbiBpbXVsKHgsIHkpIHtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmO1xuICAgIHZhciB4biA9ICt4O1xuICAgIHZhciB5biA9ICt5O1xuICAgIHZhciB4bCA9IFVJTlQxNiAmIHhuO1xuICAgIHZhciB5bCA9IFVJTlQxNiAmIHluO1xuICAgIHJldHVybiAwIHwgeGwgKiB5bCArICgoVUlOVDE2ICYgeG4gPj4+IDE2KSAqIHlsICsgeGwgKiAoVUlOVDE2ICYgeW4gPj4+IDE2KSA8PCAxNiA+Pj4gMCk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjIxIE1hdGgubG9nMTAoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgbG9nMTA6IGZ1bmN0aW9uIGxvZzEwKHgpIHtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgKiBNYXRoLkxPRzEwRTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMjAgTWF0aC5sb2cxcCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBsb2cxcDogcmVxdWlyZSgnLi9fbWF0aC1sb2cxcCcpIH0pO1xuIiwiLy8gMjAuMi4yLjIyIE1hdGgubG9nMih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cyOiBmdW5jdGlvbiBsb2cyKHgpIHtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMjtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IHNpZ246IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpIH0pO1xuIiwiLy8gMjAuMi4yLjMwIE1hdGguc2luaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBleHBtMSA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKTtcbnZhciBleHAgPSBNYXRoLmV4cDtcblxuLy8gVjggbmVhciBDaHJvbWl1bSAzOCBoYXMgYSBwcm9ibGVtIHdpdGggdmVyeSBzbWFsbCBudW1iZXJzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIU1hdGguc2luaCgtMmUtMTcpICE9IC0yZS0xNztcbn0pLCAnTWF0aCcsIHtcbiAgc2luaDogZnVuY3Rpb24gc2luaCh4KSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHggPSAreCkgPCAxXG4gICAgICA/IChleHBtMSh4KSAtIGV4cG0xKC14KSkgLyAyXG4gICAgICA6IChleHAoeCAtIDEpIC0gZXhwKC14IC0gMSkpICogKE1hdGguRSAvIDIpO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4zMyBNYXRoLnRhbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZXhwbTEgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJyk7XG52YXIgZXhwID0gTWF0aC5leHA7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdGFuaDogZnVuY3Rpb24gdGFuaCh4KSB7XG4gICAgdmFyIGEgPSBleHBtMSh4ID0gK3gpO1xuICAgIHZhciBiID0gZXhwbTEoLXgpO1xuICAgIHJldHVybiBhID09IEluZmluaXR5ID8gMSA6IGIgPT0gSW5maW5pdHkgPyAtMSA6IChhIC0gYikgLyAoZXhwKHgpICsgZXhwKC14KSk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjM0IE1hdGgudHJ1bmMoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdHJ1bmM6IGZ1bmN0aW9uIHRydW5jKGl0KSB7XG4gICAgcmV0dXJuIChpdCA+IDAgPyBNYXRoLmZsb29yIDogTWF0aC5jZWlsKShpdCk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMS4yLjEgTnVtYmVyLkVQU0lMT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBFUFNJTE9OOiBNYXRoLnBvdygyLCAtNTIpIH0pO1xuIiwiLy8gMjAuMS4yLjIgTnVtYmVyLmlzRmluaXRlKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgX2lzRmluaXRlID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuaXNGaW5pdGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc0Zpbml0ZTogZnVuY3Rpb24gaXNGaW5pdGUoaXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGl0ID09ICdudW1iZXInICYmIF9pc0Zpbml0ZShpdCk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHsgaXNJbnRlZ2VyOiByZXF1aXJlKCcuL19pcy1pbnRlZ2VyJykgfSk7XG4iLCIvLyAyMC4xLjIuNCBOdW1iZXIuaXNOYU4obnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzTmFOOiBmdW5jdGlvbiBpc05hTihudW1iZXIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgcmV0dXJuIG51bWJlciAhPSBudW1iZXI7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMS4yLjUgTnVtYmVyLmlzU2FmZUludGVnZXIobnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBpc0ludGVnZXIgPSByZXF1aXJlKCcuL19pcy1pbnRlZ2VyJyk7XG52YXIgYWJzID0gTWF0aC5hYnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc1NhZmVJbnRlZ2VyOiBmdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKG51bWJlcikge1xuICAgIHJldHVybiBpc0ludGVnZXIobnVtYmVyKSAmJiBhYnMobnVtYmVyKSA8PSAweDFmZmZmZmZmZmZmZmZmO1xuICB9XG59KTtcbiIsIi8vIDIwLjEuMi42IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHsgTUFYX1NBRkVfSU5URUdFUjogMHgxZmZmZmZmZmZmZmZmZiB9KTtcbiIsIi8vIDIwLjEuMi4xMCBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7IE1JTl9TQUZFX0lOVEVHRVI6IC0weDFmZmZmZmZmZmZmZmZmIH0pO1xuIiwiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0JywgeyBhc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKSB9KTtcbiIsIi8vIDE5LjEuMi41IE9iamVjdC5mcmVlemUoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZnJlZXplJywgZnVuY3Rpb24gKCRmcmVlemUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZyZWV6ZShpdCkge1xuICAgIHJldHVybiAkZnJlZXplICYmIGlzT2JqZWN0KGl0KSA/ICRmcmVlemUobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSU9iamVjdChpdCksIGtleSk7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5TmFtZXMnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKS5mO1xufSk7XG4iLCIvLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyICRnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRQcm90b3R5cGVPZicsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KSB7XG4gICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuMTEgT2JqZWN0LmlzRXh0ZW5zaWJsZShPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNFeHRlbnNpYmxlJywgZnVuY3Rpb24gKCRpc0V4dGVuc2libGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZShpdCkge1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNFeHRlbnNpYmxlID8gJGlzRXh0ZW5zaWJsZShpdCkgOiB0cnVlIDogZmFsc2U7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi4xMiBPYmplY3QuaXNGcm96ZW4oTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzRnJvemVuJywgZnVuY3Rpb24gKCRpc0Zyb3plbikge1xuICByZXR1cm4gZnVuY3Rpb24gaXNGcm96ZW4oaXQpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzRnJvemVuID8gJGlzRnJvemVuKGl0KSA6IGZhbHNlIDogdHJ1ZTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjEzIE9iamVjdC5pc1NlYWxlZChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNTZWFsZWQnLCBmdW5jdGlvbiAoJGlzU2VhbGVkKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpc1NlYWxlZChpdCkge1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNTZWFsZWQgPyAkaXNTZWFsZWQoaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjMuMTAgT2JqZWN0LmlzKHZhbHVlMSwgdmFsdWUyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBpczogcmVxdWlyZSgnLi9fc2FtZS12YWx1ZScpIH0pO1xuIiwiLy8gMTkuMS4yLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgna2V5cycsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoaXQpIHtcbiAgICByZXR1cm4gJGtleXModG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjE1IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyhPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdwcmV2ZW50RXh0ZW5zaW9ucycsIGZ1bmN0aW9uICgkcHJldmVudEV4dGVuc2lvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKGl0KSB7XG4gICAgcmV0dXJuICRwcmV2ZW50RXh0ZW5zaW9ucyAmJiBpc09iamVjdChpdCkgPyAkcHJldmVudEV4dGVuc2lvbnMobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi4xNyBPYmplY3Quc2VhbChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdzZWFsJywgZnVuY3Rpb24gKCRzZWFsKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzZWFsKGl0KSB7XG4gICAgcmV0dXJuICRzZWFsICYmIGlzT2JqZWN0KGl0KSA/ICRzZWFsKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0IH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi9fcGVyZm9ybScpO1xudmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4vX3VzZXItYWdlbnQnKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4vX3Byb21pc2UtcmVzb2x2ZScpO1xudmFyIFBST01JU0UgPSAnUHJvbWlzZSc7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzICYmIHByb2Nlc3MudmVyc2lvbnM7XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52OCB8fCAnJztcbnZhciAkUHJvbWlzZSA9IGdsb2JhbFtQUk9NSVNFXTtcbnZhciBpc05vZGUgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJztcbnZhciBlbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBJbnRlcm5hbCwgbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5LCBPd25Qcm9taXNlQ2FwYWJpbGl0eSwgV3JhcHBlcjtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmY7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgLy8gY29ycmVjdCBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gICAgdmFyIHByb21pc2UgPSAkUHJvbWlzZS5yZXNvbHZlKDEpO1xuICAgIHZhciBGYWtlUHJvbWlzZSA9IChwcm9taXNlLmNvbnN0cnVjdG9yID0ge30pW3JlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyldID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICAgIGV4ZWMoZW1wdHksIGVtcHR5KTtcbiAgICB9O1xuICAgIC8vIHVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgICByZXR1cm4gKGlzTm9kZSB8fCB0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50ID09ICdmdW5jdGlvbicpXG4gICAgICAmJiBwcm9taXNlLnRoZW4oZW1wdHkpIGluc3RhbmNlb2YgRmFrZVByb21pc2VcbiAgICAgIC8vIHY4IDYuNiAoTm9kZSAxMCBhbmQgQ2hyb21lIDY2KSBoYXZlIGEgYnVnIHdpdGggcmVzb2x2aW5nIGN1c3RvbSB0aGVuYWJsZXNcbiAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTgzMDU2NVxuICAgICAgLy8gd2UgY2FuJ3QgZGV0ZWN0IGl0IHN5bmNocm9ub3VzbHksIHNvIGp1c3QgY2hlY2sgdmVyc2lvbnNcbiAgICAgICYmIHY4LmluZGV4T2YoJzYuNicpICE9PSAwXG4gICAgICAmJiB1c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lLzY2JykgPT09IC0xO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn0oKTtcblxuLy8gaGVscGVyc1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHRoZW47XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgdHlwZW9mICh0aGVuID0gaXQudGhlbikgPT0gJ2Z1bmN0aW9uJyA/IHRoZW4gOiBmYWxzZTtcbn07XG52YXIgbm90aWZ5ID0gZnVuY3Rpb24gKHByb21pc2UsIGlzUmVqZWN0KSB7XG4gIGlmIChwcm9taXNlLl9uKSByZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIG9rID0gcHJvbWlzZS5fcyA9PSAxO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24gKHJlYWN0aW9uKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsO1xuICAgICAgdmFyIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlO1xuICAgICAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcbiAgICAgIHZhciBkb21haW4gPSByZWFjdGlvbi5kb21haW47XG4gICAgICB2YXIgcmVzdWx0LCB0aGVuLCBleGl0ZWQ7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlLl9oID09IDIpIG9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5faCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYW5kbGVyID09PSB0cnVlKSByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7IC8vIG1heSB0aHJvd1xuICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgICAgICBleGl0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKSB7XG4gICAgICAgICAgICByZWplY3QoVHlwZUVycm9yKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhlbi5jYWxsKHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGRvbWFpbiAmJiAhZXhpdGVkKSBkb21haW4uZXhpdCgpO1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaSkgcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIHByb21pc2UuX2MgPSBbXTtcbiAgICBwcm9taXNlLl9uID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFwcm9taXNlLl9oKSBvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIHVuaGFuZGxlZCA9IGlzVW5oYW5kbGVkKHByb21pc2UpO1xuICAgIHZhciByZXN1bHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYgKHVuaGFuZGxlZCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKSB7XG4gICAgICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWUgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgcHJvbWlzZS5faCA9IGlzTm9kZSB8fCBpc1VuaGFuZGxlZChwcm9taXNlKSA/IDIgOiAxO1xuICAgIH0gcHJvbWlzZS5fYSA9IHVuZGVmaW5lZDtcbiAgICBpZiAodW5oYW5kbGVkICYmIHJlc3VsdC5lKSB0aHJvdyByZXN1bHQudjtcbiAgfSk7XG59O1xudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgcmV0dXJuIHByb21pc2UuX2ggIT09IDEgJiYgKHByb21pc2UuX2EgfHwgcHJvbWlzZS5fYykubGVuZ3RoID09PSAwO1xufTtcbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFuZGxlcjtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub25yZWplY3Rpb25oYW5kbGVkKSB7XG4gICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiBwcm9taXNlLl92IH0pO1xuICAgIH1cbiAgfSk7XG59O1xudmFyICRyZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmICghcHJvbWlzZS5fYSkgcHJvbWlzZS5fYSA9IHByb21pc2UuX2Muc2xpY2UoKTtcbiAgbm90aWZ5KHByb21pc2UsIHRydWUpO1xufTtcbnZhciAkcmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIHZhciB0aGVuO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZiAodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHsgX3c6IHByb21pc2UsIF9kOiBmYWxzZSB9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgJHJlamVjdC5jYWxsKHdyYXBwZXIsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICAgICAgcHJvbWlzZS5fcyA9IDE7XG4gICAgICBub3RpZnkocHJvbWlzZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgICRyZWplY3QuY2FsbCh7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmICghVVNFX05BVElWRSkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICAkUHJvbWlzZSA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAkcmVqZWN0LmNhbGwodGhpcywgZXJyKTtcbiAgICB9XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICB0aGlzLl9jID0gW107ICAgICAgICAgICAgIC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuICAgIHRoaXMuX2EgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gY2hlY2tlZCBpbiBpc1VuaGFuZGxlZCByZWFjdGlvbnNcbiAgICB0aGlzLl9zID0gMDsgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgdGhpcy5fZCA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBkb25lXG4gICAgdGhpcy5fdiA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSB2YWx1ZVxuICAgIHRoaXMuX2ggPSAwOyAgICAgICAgICAgICAgLy8gPC0gcmVqZWN0aW9uIHN0YXRlLCAwIC0gZGVmYXVsdCwgMSAtIGhhbmRsZWQsIDIgLSB1bmhhbmRsZWRcbiAgICB0aGlzLl9uID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIG5vdGlmeVxuICB9O1xuICBJbnRlcm5hbC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKSgkUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkUHJvbWlzZSkpO1xuICAgICAgcmVhY3Rpb24ub2sgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICAgIHJlYWN0aW9uLmZhaWwgPSB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICYmIG9uUmVqZWN0ZWQ7XG4gICAgICByZWFjdGlvbi5kb21haW4gPSBpc05vZGUgPyBwcm9jZXNzLmRvbWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2MucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fYSkgdGhpcy5fYS5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9zKSBub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcbiAgT3duUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgSW50ZXJuYWwoKTtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IGN0eCgkcmVzb2x2ZSwgcHJvbWlzZSwgMSk7XG4gICAgdGhpcy5yZWplY3QgPSBjdHgoJHJlamVjdCwgcHJvbWlzZSwgMSk7XG4gIH07XG4gIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uIChDKSB7XG4gICAgcmV0dXJuIEMgPT09ICRQcm9taXNlIHx8IEMgPT09IFdyYXBwZXJcbiAgICAgID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICA6IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBQcm9taXNlOiAkUHJvbWlzZSB9KTtcbnJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJykoJFByb21pc2UsIFBST01JU0UpO1xucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShQUk9NSVNFKTtcbldyYXBwZXIgPSByZXF1aXJlKCcuL19jb3JlJylbUFJPTUlTRV07XG5cbi8vIHN0YXRpY3NcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZWplY3QocilcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocikge1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcyk7XG4gICAgdmFyICQkcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgJCRyZWplY3Qocik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChMSUJSQVJZIHx8ICFVU0VfTkFUSVZFKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKExJQlJBUlkgJiYgdGhpcyA9PT0gV3JhcHBlciA/ICRQcm9taXNlIDogdGhpcywgeCk7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKFVTRV9OQVRJVkUgJiYgcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikge1xuICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciAkaW5kZXggPSBpbmRleCsrO1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjEgUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgckFwcGx5ID0gKHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3QgfHwge30pLmFwcGx5O1xudmFyIGZBcHBseSA9IEZ1bmN0aW9uLmFwcGx5O1xuLy8gTVMgRWRnZSBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgckFwcGx5KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG59KSwgJ1JlZmxlY3QnLCB7XG4gIGFwcGx5OiBmdW5jdGlvbiBhcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdCkge1xuICAgIHZhciBUID0gYUZ1bmN0aW9uKHRhcmdldCk7XG4gICAgdmFyIEwgPSBhbk9iamVjdChhcmd1bWVudHNMaXN0KTtcbiAgICByZXR1cm4gckFwcGx5ID8gckFwcGx5KFQsIHRoaXNBcmd1bWVudCwgTCkgOiBmQXBwbHkuY2FsbChULCB0aGlzQXJndW1lbnQsIEwpO1xuICB9XG59KTtcbiIsIi8vIDI2LjEuMiBSZWZsZWN0LmNvbnN0cnVjdCh0YXJnZXQsIGFyZ3VtZW50c0xpc3QgWywgbmV3VGFyZ2V0XSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL19iaW5kJyk7XG52YXIgckNvbnN0cnVjdCA9IChyZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0IHx8IHt9KS5jb25zdHJ1Y3Q7XG5cbi8vIE1TIEVkZ2Ugc3VwcG9ydHMgb25seSAyIGFyZ3VtZW50cyBhbmQgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuLy8gRkYgTmlnaHRseSBzZXRzIHRoaXJkIGFyZ3VtZW50IGFzIGBuZXcudGFyZ2V0YCwgYnV0IGRvZXMgbm90IGNyZWF0ZSBgdGhpc2AgZnJvbSBpdFxudmFyIE5FV19UQVJHRVRfQlVHID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiAhKHJDb25zdHJ1Y3QoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCBbXSwgRikgaW5zdGFuY2VvZiBGKTtcbn0pO1xudmFyIEFSR1NfQlVHID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgckNvbnN0cnVjdChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE5FV19UQVJHRVRfQlVHIHx8IEFSR1NfQlVHKSwgJ1JlZmxlY3QnLCB7XG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gY29uc3RydWN0KFRhcmdldCwgYXJncyAvKiAsIG5ld1RhcmdldCAqLykge1xuICAgIGFGdW5jdGlvbihUYXJnZXQpO1xuICAgIGFuT2JqZWN0KGFyZ3MpO1xuICAgIHZhciBuZXdUYXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IFRhcmdldCA6IGFGdW5jdGlvbihhcmd1bWVudHNbMl0pO1xuICAgIGlmIChBUkdTX0JVRyAmJiAhTkVXX1RBUkdFVF9CVUcpIHJldHVybiByQ29uc3RydWN0KFRhcmdldCwgYXJncywgbmV3VGFyZ2V0KTtcbiAgICBpZiAoVGFyZ2V0ID09IG5ld1RhcmdldCkge1xuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBvcHRpbWl6YXRpb24gZm9yIDAtNCBhcmd1bWVudHNcbiAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IFRhcmdldCgpO1xuICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0pO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgfVxuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBsb3Qgb2YgYXJndW1lbnRzIGNhc2VcbiAgICAgIHZhciAkYXJncyA9IFtudWxsXTtcbiAgICAgICRhcmdzLnB1c2guYXBwbHkoJGFyZ3MsIGFyZ3MpO1xuICAgICAgcmV0dXJuIG5ldyAoYmluZC5hcHBseShUYXJnZXQsICRhcmdzKSkoKTtcbiAgICB9XG4gICAgLy8gd2l0aCBhbHRlcmVkIG5ld1RhcmdldCwgbm90IHN1cHBvcnQgYnVpbHQtaW4gY29uc3RydWN0b3JzXG4gICAgdmFyIHByb3RvID0gbmV3VGFyZ2V0LnByb3RvdHlwZTtcbiAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGUoaXNPYmplY3QocHJvdG8pID8gcHJvdG8gOiBPYmplY3QucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gRnVuY3Rpb24uYXBwbHkuY2FsbChUYXJnZXQsIGluc3RhbmNlLCBhcmdzKTtcbiAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IGluc3RhbmNlO1xuICB9XG59KTtcbiIsIi8vIDI2LjEuMyBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpXG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG4vLyBNUyBFZGdlIGhhcyBicm9rZW4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSAtIHRocm93aW5nIGluc3RlYWQgb2YgcmV0dXJuaW5nIGZhbHNlXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShkUC5mKHt9LCAxLCB7IHZhbHVlOiAxIH0pLCAxLCB7IHZhbHVlOiAyIH0pO1xufSksICdSZWZsZWN0Jywge1xuICBkZWZpbmVQcm9wZXJ0eTogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcykge1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgcHJvcGVydHlLZXkgPSB0b1ByaW1pdGl2ZShwcm9wZXJ0eUtleSwgdHJ1ZSk7XG4gICAgYW5PYmplY3QoYXR0cmlidXRlcyk7XG4gICAgdHJ5IHtcbiAgICAgIGRQLmYodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcbiIsIi8vIDI2LjEuNCBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIHZhciBkZXNjID0gZ09QRChhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gICAgcmV0dXJuIGRlc2MgJiYgIWRlc2MuY29uZmlndXJhYmxlID8gZmFsc2UgOiBkZWxldGUgdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjcgUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSlcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgcmV0dXJuIGdPUEQuZihhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS44IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBnZXRQcm90byA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGdldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZih0YXJnZXQpIHtcbiAgICByZXR1cm4gZ2V0UHJvdG8oYW5PYmplY3QodGFyZ2V0KSk7XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS42IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkgWywgcmVjZWl2ZXJdKVxudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIGdldCh0YXJnZXQsIHByb3BlcnR5S2V5IC8qICwgcmVjZWl2ZXIgKi8pIHtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiBhcmd1bWVudHNbMl07XG4gIHZhciBkZXNjLCBwcm90bztcbiAgaWYgKGFuT2JqZWN0KHRhcmdldCkgPT09IHJlY2VpdmVyKSByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgaWYgKGRlc2MgPSBnT1BELmYodGFyZ2V0LCBwcm9wZXJ0eUtleSkpIHJldHVybiBoYXMoZGVzYywgJ3ZhbHVlJylcbiAgICA/IGRlc2MudmFsdWVcbiAgICA6IGRlc2MuZ2V0ICE9PSB1bmRlZmluZWRcbiAgICAgID8gZGVzYy5nZXQuY2FsbChyZWNlaXZlcilcbiAgICAgIDogdW5kZWZpbmVkO1xuICBpZiAoaXNPYmplY3QocHJvdG8gPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSkgcmV0dXJuIGdldChwcm90bywgcHJvcGVydHlLZXksIHJlY2VpdmVyKTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0JywgeyBnZXQ6IGdldCB9KTtcbiIsIi8vIDI2LjEuOSBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBoYXM6IGZ1bmN0aW9uIGhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgcmV0dXJuIHByb3BlcnR5S2V5IGluIHRhcmdldDtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjEwIFJlZmxlY3QuaXNFeHRlbnNpYmxlKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciAkaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBpc0V4dGVuc2libGU6IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZSh0YXJnZXQpIHtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHJldHVybiAkaXNFeHRlbnNpYmxlID8gJGlzRXh0ZW5zaWJsZSh0YXJnZXQpIDogdHJ1ZTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjExIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7IG93bktleXM6IHJlcXVpcmUoJy4vX293bi1rZXlzJykgfSk7XG4iLCIvLyAyNi4xLjEyIFJlZmxlY3QucHJldmVudEV4dGVuc2lvbnModGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyICRwcmV2ZW50RXh0ZW5zaW9ucyA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KSB7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICB0cnkge1xuICAgICAgaWYgKCRwcmV2ZW50RXh0ZW5zaW9ucykgJHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcbiIsIi8vIDI2LjEuMTQgUmVmbGVjdC5zZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBzZXRQcm90byA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpO1xuXG5pZiAoc2V0UHJvdG8pICRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgc2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pIHtcbiAgICBzZXRQcm90by5jaGVjayh0YXJnZXQsIHByb3RvKTtcbiAgICB0cnkge1xuICAgICAgc2V0UHJvdG8uc2V0KHRhcmdldCwgcHJvdG8pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG4iLCIvLyAyNi4xLjEzIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYgWywgcmVjZWl2ZXJdKVxudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5mdW5jdGlvbiBzZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgViAvKiAsIHJlY2VpdmVyICovKSB7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCA0ID8gdGFyZ2V0IDogYXJndW1lbnRzWzNdO1xuICB2YXIgb3duRGVzYyA9IGdPUEQuZihhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gIHZhciBleGlzdGluZ0Rlc2NyaXB0b3IsIHByb3RvO1xuICBpZiAoIW93bkRlc2MpIHtcbiAgICBpZiAoaXNPYmplY3QocHJvdG8gPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSkge1xuICAgICAgcmV0dXJuIHNldChwcm90bywgcHJvcGVydHlLZXksIFYsIHJlY2VpdmVyKTtcbiAgICB9XG4gICAgb3duRGVzYyA9IGNyZWF0ZURlc2MoMCk7XG4gIH1cbiAgaWYgKGhhcyhvd25EZXNjLCAndmFsdWUnKSkge1xuICAgIGlmIChvd25EZXNjLndyaXRhYmxlID09PSBmYWxzZSB8fCAhaXNPYmplY3QocmVjZWl2ZXIpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGV4aXN0aW5nRGVzY3JpcHRvciA9IGdPUEQuZihyZWNlaXZlciwgcHJvcGVydHlLZXkpKSB7XG4gICAgICBpZiAoZXhpc3RpbmdEZXNjcmlwdG9yLmdldCB8fCBleGlzdGluZ0Rlc2NyaXB0b3Iuc2V0IHx8IGV4aXN0aW5nRGVzY3JpcHRvci53cml0YWJsZSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgIGV4aXN0aW5nRGVzY3JpcHRvci52YWx1ZSA9IFY7XG4gICAgICBkUC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSwgZXhpc3RpbmdEZXNjcmlwdG9yKTtcbiAgICB9IGVsc2UgZFAuZihyZWNlaXZlciwgcHJvcGVydHlLZXksIGNyZWF0ZURlc2MoMCwgVikpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBvd25EZXNjLnNldCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiAob3duRGVzYy5zZXQuY2FsbChyZWNlaXZlciwgViksIHRydWUpO1xufVxuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7IHNldDogc2V0IH0pO1xuIiwiLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3MoKVxuaWYgKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgLy4vZy5mbGFncyAhPSAnZycpIHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYoUmVnRXhwLnByb3RvdHlwZSwgJ2ZsYWdzJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogcmVxdWlyZSgnLi9fZmxhZ3MnKVxufSk7XG4iLCIvLyBAQG1hdGNoIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ21hdGNoJywgMSwgZnVuY3Rpb24gKGRlZmluZWQsIE1BVENILCAkbWF0Y2gpIHtcbiAgLy8gMjEuMS4zLjExIFN0cmluZy5wcm90b3R5cGUubWF0Y2gocmVnZXhwKVxuICByZXR1cm4gW2Z1bmN0aW9uIG1hdGNoKHJlZ2V4cCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgdmFyIGZuID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtNQVRDSF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbTUFUQ0hdKFN0cmluZyhPKSk7XG4gIH0sICRtYXRjaF07XG59KTtcbiIsIi8vIEBAcmVwbGFjZSBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdyZXBsYWNlJywgMiwgZnVuY3Rpb24gKGRlZmluZWQsIFJFUExBQ0UsICRyZXBsYWNlKSB7XG4gIC8vIDIxLjEuMy4xNCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSlcbiAgcmV0dXJuIFtmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgIHZhciBmbiA9IHNlYXJjaFZhbHVlID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlYXJjaFZhbHVlW1JFUExBQ0VdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGZuLmNhbGwoc2VhcmNoVmFsdWUsIE8sIHJlcGxhY2VWYWx1ZSlcbiAgICAgIDogJHJlcGxhY2UuY2FsbChTdHJpbmcoTyksIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICB9LCAkcmVwbGFjZV07XG59KTtcbiIsIi8vIEBAc2VhcmNoIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3NlYXJjaCcsIDEsIGZ1bmN0aW9uIChkZWZpbmVkLCBTRUFSQ0gsICRzZWFyY2gpIHtcbiAgLy8gMjEuMS4zLjE1IFN0cmluZy5wcm90b3R5cGUuc2VhcmNoKHJlZ2V4cClcbiAgcmV0dXJuIFtmdW5jdGlvbiBzZWFyY2gocmVnZXhwKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICB2YXIgZm4gPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW1NFQVJDSF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbU0VBUkNIXShTdHJpbmcoTykpO1xuICB9LCAkc2VhcmNoXTtcbn0pO1xuIiwiLy8gQEBzcGxpdCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzcGxpdCcsIDIsIGZ1bmN0aW9uIChkZWZpbmVkLCBTUExJVCwgJHNwbGl0KSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJyk7XG4gIHZhciBfc3BsaXQgPSAkc3BsaXQ7XG4gIHZhciAkcHVzaCA9IFtdLnB1c2g7XG4gIHZhciAkU1BMSVQgPSAnc3BsaXQnO1xuICB2YXIgTEVOR1RIID0gJ2xlbmd0aCc7XG4gIHZhciBMQVNUX0lOREVYID0gJ2xhc3RJbmRleCc7XG4gIGlmIChcbiAgICAnYWJiYydbJFNQTElUXSgvKGIpKi8pWzFdID09ICdjJyB8fFxuICAgICd0ZXN0J1skU1BMSVRdKC8oPzopLywgLTEpW0xFTkdUSF0gIT0gNCB8fFxuICAgICdhYidbJFNQTElUXSgvKD86YWIpKi8pW0xFTkdUSF0gIT0gMiB8fFxuICAgICcuJ1skU1BMSVRdKC8oLj8pKC4/KS8pW0xFTkdUSF0gIT0gNCB8fFxuICAgICcuJ1skU1BMSVRdKC8oKSgpLylbTEVOR1RIXSA+IDEgfHxcbiAgICAnJ1skU1BMSVRdKC8uPy8pW0xFTkdUSF1cbiAgKSB7XG4gICAgdmFyIE5QQ0cgPSAvKCk/Py8uZXhlYygnJylbMV0gPT09IHVuZGVmaW5lZDsgLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBcbiAgICAvLyBiYXNlZCBvbiBlczUtc2hpbSBpbXBsZW1lbnRhdGlvbiwgbmVlZCB0byByZXdvcmsgaXRcbiAgICAkc3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgdmFyIHN0cmluZyA9IFN0cmluZyh0aGlzKTtcbiAgICAgIGlmIChzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMCkgcmV0dXJuIFtdO1xuICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcbiAgICAgIGlmICghaXNSZWdFeHAoc2VwYXJhdG9yKSkgcmV0dXJuIF9zcGxpdC5jYWxsKHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICB2YXIgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci51bmljb2RlID8gJ3UnIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ID8gJ3knIDogJycpO1xuICAgICAgdmFyIGxhc3RMYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIHNwbGl0TGltaXQgPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gNDI5NDk2NzI5NSA6IGxpbWl0ID4+PiAwO1xuICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgIHZhciBzZXBhcmF0b3JDb3B5ID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICB2YXIgc2VwYXJhdG9yMiwgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aCwgaTtcbiAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgaWYgKCFOUENHKSBzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cCgnXicgKyBzZXBhcmF0b3JDb3B5LnNvdXJjZSArICckKD8hXFxcXHMpJywgZmxhZ3MpO1xuICAgICAgd2hpbGUgKG1hdGNoID0gc2VwYXJhdG9yQ29weS5leGVjKHN0cmluZykpIHtcbiAgICAgICAgLy8gYHNlcGFyYXRvckNvcHkubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdW0xFTkdUSF07XG4gICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yIE5QQ0dcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9vcC1mdW5jXG4gICAgICAgICAgaWYgKCFOUENHICYmIG1hdGNoW0xFTkdUSF0gPiAxKSBtYXRjaFswXS5yZXBsYWNlKHNlcGFyYXRvcjIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHNbTEVOR1RIXSAtIDI7IGkrKykgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdW5kZWZpbmVkKSBtYXRjaFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAobWF0Y2hbTEVOR1RIXSA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmdbTEVOR1RIXSkgJHB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdW0xFTkdUSF07XG4gICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICBpZiAob3V0cHV0W0xFTkdUSF0gPj0gc3BsaXRMaW1pdCkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0gPT09IG1hdGNoLmluZGV4KSBzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdKys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmdbTEVOR1RIXSkge1xuICAgICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yQ29weS50ZXN0KCcnKSkgb3V0cHV0LnB1c2goJycpO1xuICAgICAgfSBlbHNlIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICByZXR1cm4gb3V0cHV0W0xFTkdUSF0gPiBzcGxpdExpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIHNwbGl0TGltaXQpIDogb3V0cHV0O1xuICAgIH07XG4gIC8vIENoYWtyYSwgVjhcbiAgfSBlbHNlIGlmICgnMCdbJFNQTElUXSh1bmRlZmluZWQsIDApW0xFTkdUSF0pIHtcbiAgICAkc3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgcmV0dXJuIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwID8gW10gOiBfc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9O1xuICB9XG4gIC8vIDIxLjEuMy4xNyBTdHJpbmcucHJvdG90eXBlLnNwbGl0KHNlcGFyYXRvciwgbGltaXQpXG4gIHJldHVybiBbZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICB2YXIgZm4gPSBzZXBhcmF0b3IgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VwYXJhdG9yW1NQTElUXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwoc2VwYXJhdG9yLCBPLCBsaW1pdCkgOiAkc3BsaXQuY2FsbChTdHJpbmcoTyksIHNlcGFyYXRvciwgbGltaXQpO1xuICB9LCAkc3BsaXRdO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBTRVQgPSAnU2V0JztcblxuLy8gMjMuMiBTZXQgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoU0VULCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih2YWxpZGF0ZSh0aGlzLCBTRVQpLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKGZhbHNlKTtcbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuMyBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0KHBvcylcbiAgY29kZVBvaW50QXQ6IGZ1bmN0aW9uIGNvZGVQb2ludEF0KHBvcykge1xuICAgIHJldHVybiAkYXQodGhpcywgcG9zKTtcbiAgfVxufSk7XG4iLCIvLyAyMS4xLjMuNiBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKHNlYXJjaFN0cmluZyBbLCBlbmRQb3NpdGlvbl0pXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY29udGV4dCA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0Jyk7XG52YXIgRU5EU19XSVRIID0gJ2VuZHNXaXRoJztcbnZhciAkZW5kc1dpdGggPSAnJ1tFTkRTX1dJVEhdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKEVORFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIGVuZHNXaXRoOiBmdW5jdGlvbiBlbmRzV2l0aChzZWFyY2hTdHJpbmcgLyogLCBlbmRQb3NpdGlvbiA9IEBsZW5ndGggKi8pIHtcbiAgICB2YXIgdGhhdCA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBFTkRTX1dJVEgpO1xuICAgIHZhciBlbmRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aCh0aGF0Lmxlbmd0aCk7XG4gICAgdmFyIGVuZCA9IGVuZFBvc2l0aW9uID09PSB1bmRlZmluZWQgPyBsZW4gOiBNYXRoLm1pbih0b0xlbmd0aChlbmRQb3NpdGlvbiksIGxlbik7XG4gICAgdmFyIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiAkZW5kc1dpdGhcbiAgICAgID8gJGVuZHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBlbmQpXG4gICAgICA6IHRoYXQuc2xpY2UoZW5kIC0gc2VhcmNoLmxlbmd0aCwgZW5kKSA9PT0gc2VhcmNoO1xuICB9XG59KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xudmFyICRmcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG5cbi8vIGxlbmd0aCBzaG91bGQgYmUgMSwgb2xkIEZGIHByb2JsZW1cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCEhJGZyb21Db2RlUG9pbnQgJiYgJGZyb21Db2RlUG9pbnQubGVuZ3RoICE9IDEpLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjIuMiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jb2RlUG9pbnRzKVxuICBmcm9tQ29kZVBvaW50OiBmdW5jdGlvbiBmcm9tQ29kZVBvaW50KHgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciByZXMgPSBbXTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBjb2RlO1xuICAgIHdoaWxlIChhTGVuID4gaSkge1xuICAgICAgY29kZSA9ICthcmd1bWVudHNbaSsrXTtcbiAgICAgIGlmICh0b0Fic29sdXRlSW5kZXgoY29kZSwgMHgxMGZmZmYpICE9PSBjb2RlKSB0aHJvdyBSYW5nZUVycm9yKGNvZGUgKyAnIGlzIG5vdCBhIHZhbGlkIGNvZGUgcG9pbnQnKTtcbiAgICAgIHJlcy5wdXNoKGNvZGUgPCAweDEwMDAwXG4gICAgICAgID8gZnJvbUNoYXJDb2RlKGNvZGUpXG4gICAgICAgIDogZnJvbUNoYXJDb2RlKCgoY29kZSAtPSAweDEwMDAwKSA+PiAxMCkgKyAweGQ4MDAsIGNvZGUgJSAweDQwMCArIDB4ZGMwMClcbiAgICAgICk7XG4gICAgfSByZXR1cm4gcmVzLmpvaW4oJycpO1xuICB9XG59KTtcbiIsIi8vIDIxLjEuMy43IFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbiA9IDApXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpO1xudmFyIElOQ0xVREVTID0gJ2luY2x1ZGVzJztcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShJTkNMVURFUyksICdTdHJpbmcnLCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hTdHJpbmcgLyogLCBwb3NpdGlvbiA9IDAgKi8pIHtcbiAgICByZXR1cm4gISF+Y29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIElOQ0xVREVTKVxuICAgICAgLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMi40IFN0cmluZy5yYXcoY2FsbFNpdGUsIC4uLnN1YnN0aXR1dGlvbnMpXG4gIHJhdzogZnVuY3Rpb24gcmF3KGNhbGxTaXRlKSB7XG4gICAgdmFyIHRwbCA9IHRvSU9iamVjdChjYWxsU2l0ZS5yYXcpO1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aCh0cGwubGVuZ3RoKTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAobGVuID4gaSkge1xuICAgICAgcmVzLnB1c2goU3RyaW5nKHRwbFtpKytdKSk7XG4gICAgICBpZiAoaSA8IGFMZW4pIHJlcy5wdXNoKFN0cmluZyhhcmd1bWVudHNbaV0pKTtcbiAgICB9IHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4xMyBTdHJpbmcucHJvdG90eXBlLnJlcGVhdChjb3VudClcbiAgcmVwZWF0OiByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0Jylcbn0pO1xuIiwiLy8gMjEuMS4zLjE4IFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgWywgcG9zaXRpb24gXSlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBjb250ZXh0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKTtcbnZhciBTVEFSVFNfV0lUSCA9ICdzdGFydHNXaXRoJztcbnZhciAkc3RhcnRzV2l0aCA9ICcnW1NUQVJUU19XSVRIXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShTVEFSVFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIHN0YXJ0c1dpdGg6IGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIC8qICwgcG9zaXRpb24gPSAwICovKSB7XG4gICAgdmFyIHRoYXQgPSBjb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgU1RBUlRTX1dJVEgpO1xuICAgIHZhciBpbmRleCA9IHRvTGVuZ3RoKE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0aGF0Lmxlbmd0aCkpO1xuICAgIHZhciBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gJHN0YXJ0c1dpdGhcbiAgICAgID8gJHN0YXJ0c1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGluZGV4KVxuICAgICAgOiB0aGF0LnNsaWNlKGluZGV4LCBpbmRleCArIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIE1FVEEgPSByZXF1aXJlKCcuL19tZXRhJykuS0VZO1xudmFyICRmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciB3a3NEZWZpbmUgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJyk7XG52YXIgZW51bUtleXMgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBfY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGdPUE5FeHQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKTtcbnZhciAkR09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgJERQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUEQgPSAkR09QRC5mO1xudmFyIGRQID0gJERQLmY7XG52YXIgZ09QTiA9IGdPUE5FeHQuZjtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkSlNPTiA9IGdsb2JhbC5KU09OO1xudmFyIF9zdHJpbmdpZnkgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgSElEREVOID0gd2tzKCdfaGlkZGVuJyk7XG52YXIgVE9fUFJJTUlUSVZFID0gd2tzKCd0b1ByaW1pdGl2ZScpO1xudmFyIGlzRW51bSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKTtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT1BTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciBVU0VfTkFUSVZFID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcbnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24gKGl0LCBrZXksIEQpIHtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmIChwcm90b0Rlc2MpIGRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBkUChpdCwga2V5LCBEKTtcbiAgaWYgKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pIGRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZykge1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCkge1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvKSAkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUQuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXMoaXQsIEhJRERFTikpIGRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSBpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHsgZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCkge1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGwgPiBpKSAkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKSB7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KSB7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICBpdCA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZiAoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSBELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHZhciBuYW1lcyA9IGdPUE4odG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICB2YXIgSVNfT1AgPSBpdCA9PT0gT2JqZWN0UHJvdG87XG4gIHZhciBuYW1lcyA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSkgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8pICRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmIChoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKSB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmIChERVNDUklQVE9SUyAmJiBzZXR0ZXIpIHNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldCB9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZiAoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSkge1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgU3ltYm9sOiAkU3ltYm9sIH0pO1xuXG5mb3IgKHZhciBlczZTeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGogPSAwOyBlczZTeW1ib2xzLmxlbmd0aCA+IGo7KXdrcyhlczZTeW1ib2xzW2orK10pO1xuXG5mb3IgKHZhciB3ZWxsS25vd25TeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgayA9IDA7IHdlbGxLbm93blN5bWJvbHMubGVuZ3RoID4gazspIHdrc0RlZmluZSh3ZWxsS25vd25TeW1ib2xzW2srK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHN5bSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICAgIGZvciAodmFyIGtleSBpbiBTeW1ib2xSZWdpc3RyeSkgaWYgKFN5bWJvbFJlZ2lzdHJ5W2tleV0gPT09IHN5bSkgcmV0dXJuIGtleTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBTID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHsgYTogUyB9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpIHtcbiAgICB2YXIgYXJncyA9IFtpdF07XG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICAkcmVwbGFjZXIgPSByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYgKCFpc09iamVjdChyZXBsYWNlcikgJiYgaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpIHJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIGlmICghaXNBcnJheShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgJHJlcGxhY2VyID09ICdmdW5jdGlvbicpIHZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcbiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IHJlcXVpcmUoJy4vX2hpZGUnKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHR5cGVkID0gcmVxdWlyZSgnLi9fdHlwZWQnKTtcbnZhciBidWZmZXIgPSByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIEFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuQXJyYXlCdWZmZXI7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyICRBcnJheUJ1ZmZlciA9IGJ1ZmZlci5BcnJheUJ1ZmZlcjtcbnZhciAkRGF0YVZpZXcgPSBidWZmZXIuRGF0YVZpZXc7XG52YXIgJGlzVmlldyA9ICR0eXBlZC5BQlYgJiYgQXJyYXlCdWZmZXIuaXNWaWV3O1xudmFyICRzbGljZSA9ICRBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2U7XG52YXIgVklFVyA9ICR0eXBlZC5WSUVXO1xudmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEFycmF5QnVmZmVyICE9PSAkQXJyYXlCdWZmZXIpLCB7IEFycmF5QnVmZmVyOiAkQXJyYXlCdWZmZXIgfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISR0eXBlZC5DT05TVFIsIEFSUkFZX0JVRkZFUiwge1xuICAvLyAyNC4xLjMuMSBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJnKVxuICBpc1ZpZXc6IGZ1bmN0aW9uIGlzVmlldyhpdCkge1xuICAgIHJldHVybiAkaXNWaWV3ICYmICRpc1ZpZXcoaXQpIHx8IGlzT2JqZWN0KGl0KSAmJiBWSUVXIGluIGl0O1xuICB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlUgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICFuZXcgJEFycmF5QnVmZmVyKDIpLnNsaWNlKDEsIHVuZGVmaW5lZCkuYnl0ZUxlbmd0aDtcbn0pLCBBUlJBWV9CVUZGRVIsIHtcbiAgLy8gMjQuMS40LjMgQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgaWYgKCRzbGljZSAhPT0gdW5kZWZpbmVkICYmIGVuZCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJHNsaWNlLmNhbGwoYW5PYmplY3QodGhpcyksIHN0YXJ0KTsgLy8gRkYgZml4XG4gICAgdmFyIGxlbiA9IGFuT2JqZWN0KHRoaXMpLmJ5dGVMZW5ndGg7XG4gICAgdmFyIGZpcnN0ID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW4pO1xuICAgIHZhciBmaW4gPSB0b0Fic29sdXRlSW5kZXgoZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQsIGxlbik7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRBcnJheUJ1ZmZlcikpKHRvTGVuZ3RoKGZpbiAtIGZpcnN0KSk7XG4gICAgdmFyIHZpZXdTID0gbmV3ICREYXRhVmlldyh0aGlzKTtcbiAgICB2YXIgdmlld1QgPSBuZXcgJERhdGFWaWV3KHJlc3VsdCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB3aGlsZSAoZmlyc3QgPCBmaW4pIHtcbiAgICAgIHZpZXdULnNldFVpbnQ4KGluZGV4KyssIHZpZXdTLmdldFVpbnQ4KGZpcnN0KyspKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKEFSUkFZX0JVRkZFUik7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdGbG9hdDMyJywgNCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdGbG9hdDY0JywgOCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0NjRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQxNicsIDIsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQxNkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDMyJywgNCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50OCcsIDEsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDE2JywgMiwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQxNkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQzMicsIDQsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50OCcsIDEsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQ4JywgMSwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQ4Q2xhbXBlZEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59LCB0cnVlKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBlYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKTtcbnZhciB3ZWFrID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi13ZWFrJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgV0VBS19NQVAgPSAnV2Vha01hcCc7XG52YXIgZ2V0V2VhayA9IG1ldGEuZ2V0V2VhaztcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSB3ZWFrLnVmc3RvcmU7XG52YXIgdG1wID0ge307XG52YXIgSW50ZXJuYWxNYXA7XG5cbnZhciB3cmFwcGVyID0gZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha01hcCgpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgfTtcbn07XG5cbnZhciBtZXRob2RzID0ge1xuICAvLyAyMy4zLjMuMyBXZWFrTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodmFsaWRhdGUodGhpcywgV0VBS19NQVApKS5nZXQoa2V5KTtcbiAgICAgIHJldHVybiBkYXRhID8gZGF0YVt0aGlzLl9pXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG4gIC8vIDIzLjMuMy41IFdlYWtNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHdlYWsuZGVmKHZhbGlkYXRlKHRoaXMsIFdFQUtfTUFQKSwga2V5LCB2YWx1ZSk7XG4gIH1cbn07XG5cbi8vIDIzLjMgV2Vha01hcCBPYmplY3RzXG52YXIgJFdlYWtNYXAgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShXRUFLX01BUCwgd3JhcHBlciwgbWV0aG9kcywgd2VhaywgdHJ1ZSwgdHJ1ZSk7XG5cbi8vIElFMTEgV2Vha01hcCBmcm96ZW4ga2V5cyBmaXhcbmlmIChmYWlscyhmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgJFdlYWtNYXAoKS5zZXQoKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh0bXApLCA3KS5nZXQodG1wKSAhPSA3OyB9KSkge1xuICBJbnRlcm5hbE1hcCA9IHdlYWsuZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgV0VBS19NQVApO1xuICBhc3NpZ24oSW50ZXJuYWxNYXAucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgZWFjaChbJ2RlbGV0ZScsICdoYXMnLCAnZ2V0JywgJ3NldCddLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHByb3RvID0gJFdlYWtNYXAucHJvdG90eXBlO1xuICAgIHZhciBtZXRob2QgPSBwcm90b1trZXldO1xuICAgIHJlZGVmaW5lKHByb3RvLCBrZXksIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAvLyBzdG9yZSBmcm96ZW4gb2JqZWN0cyBvbiBpbnRlcm5hbCB3ZWFrbWFwIHNoaW1cbiAgICAgIGlmIChpc09iamVjdChhKSAmJiAhaXNFeHRlbnNpYmxlKGEpKSB7XG4gICAgICAgIGlmICghdGhpcy5fZikgdGhpcy5fZiA9IG5ldyBJbnRlcm5hbE1hcCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fZltrZXldKGEsIGIpO1xuICAgICAgICByZXR1cm4ga2V5ID09ICdzZXQnID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIC8vIHN0b3JlIGFsbCB0aGUgcmVzdCBvbiBuYXRpdmUgd2Vha21hcFxuICAgICAgfSByZXR1cm4gbWV0aG9kLmNhbGwodGhpcywgYSwgYik7XG4gICAgfSk7XG4gIH0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHdlYWsgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBXRUFLX1NFVCA9ICdXZWFrU2V0JztcblxuLy8gMjMuNCBXZWFrU2V0IE9iamVjdHNcbnJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShXRUFLX1NFVCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha1NldCgpIHsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjQuMy4xIFdlYWtTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICByZXR1cm4gd2Vhay5kZWYodmFsaWRhdGUodGhpcywgV0VBS19TRVQpLCB2YWx1ZSwgdHJ1ZSk7XG4gIH1cbn0sIHdlYWssIGZhbHNlLCB0cnVlKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L0FycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkaW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWwgLyogLCBmcm9tSW5kZXggPSAwICovKSB7XG4gICAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2luY2x1ZGVzJyk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtdmFsdWVzLWVudHJpZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGVudHJpZXMgPSByZXF1aXJlKCcuL19vYmplY3QtdG8tYXJyYXknKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoaXQpIHtcbiAgICByZXR1cm4gJGVudHJpZXMoaXQpO1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIG93bktleXMgPSByZXF1aXJlKCcuL19vd24ta2V5cycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3QpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICAgIHZhciBnZXREZXNjID0gZ09QRC5mO1xuICAgIHZhciBrZXlzID0gb3duS2V5cyhPKTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBrZXksIGRlc2M7XG4gICAgd2hpbGUgKGtleXMubGVuZ3RoID4gaSkge1xuICAgICAgZGVzYyA9IGdldERlc2MoTywga2V5ID0ga2V5c1tpKytdKTtcbiAgICAgIGlmIChkZXNjICE9PSB1bmRlZmluZWQpIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwga2V5LCBkZXNjKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtdmFsdWVzLWVudHJpZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHZhbHVlcyA9IHJlcXVpcmUoJy4vX29iamVjdC10by1hcnJheScpKGZhbHNlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKGl0KSB7XG4gICAgcmV0dXJuICR2YWx1ZXMoaXQpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRwYWQgPSByZXF1aXJlKCcuL19zdHJpbmctcGFkJyk7XG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi9fdXNlci1hZ2VudCcpO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMjgwXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIC9WZXJzaW9uXFwvMTBcXC5cXGQrKFxcLlxcZCspPyBTYWZhcmlcXC8vLnRlc3QodXNlckFnZW50KSwgJ1N0cmluZycsIHtcbiAgcGFkRW5kOiBmdW5jdGlvbiBwYWRFbmQobWF4TGVuZ3RoIC8qICwgZmlsbFN0cmluZyA9ICcgJyAqLykge1xuICAgIHJldHVybiAkcGFkKHRoaXMsIG1heExlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGZhbHNlKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFkID0gcmVxdWlyZSgnLi9fc3RyaW5nLXBhZCcpO1xudmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4vX3VzZXItYWdlbnQnKTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzI4MFxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAvVmVyc2lvblxcLzEwXFwuXFxkKyhcXC5cXGQrKT8gU2FmYXJpXFwvLy50ZXN0KHVzZXJBZ2VudCksICdTdHJpbmcnLCB7XG4gIHBhZFN0YXJ0OiBmdW5jdGlvbiBwYWRTdGFydChtYXhMZW5ndGggLyogLCBmaWxsU3RyaW5nID0gJyAnICovKSB7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIH1cbn0pO1xuIiwidmFyICRpdGVyYXRvcnMgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIElURVJBVE9SID0gd2tzKCdpdGVyYXRvcicpO1xudmFyIFRPX1NUUklOR19UQUcgPSB3a3MoJ3RvU3RyaW5nVGFnJyk7XG52YXIgQXJyYXlWYWx1ZXMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbnZhciBET01JdGVyYWJsZXMgPSB7XG4gIENTU1J1bGVMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogZmFsc2UsXG4gIENTU1ZhbHVlTGlzdDogZmFsc2UsXG4gIENsaWVudFJlY3RMaXN0OiBmYWxzZSxcbiAgRE9NUmVjdExpc3Q6IGZhbHNlLFxuICBET01TdHJpbmdMaXN0OiBmYWxzZSxcbiAgRE9NVG9rZW5MaXN0OiB0cnVlLFxuICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogZmFsc2UsXG4gIEZpbGVMaXN0OiBmYWxzZSxcbiAgSFRNTEFsbENvbGxlY3Rpb246IGZhbHNlLFxuICBIVE1MQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxGb3JtRWxlbWVudDogZmFsc2UsXG4gIEhUTUxTZWxlY3RFbGVtZW50OiBmYWxzZSxcbiAgTWVkaWFMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgTWltZVR5cGVBcnJheTogZmFsc2UsXG4gIE5hbWVkTm9kZU1hcDogZmFsc2UsXG4gIE5vZGVMaXN0OiB0cnVlLFxuICBQYWludFJlcXVlc3RMaXN0OiBmYWxzZSxcbiAgUGx1Z2luOiBmYWxzZSxcbiAgUGx1Z2luQXJyYXk6IGZhbHNlLFxuICBTVkdMZW5ndGhMaXN0OiBmYWxzZSxcbiAgU1ZHTnVtYmVyTGlzdDogZmFsc2UsXG4gIFNWR1BhdGhTZWdMaXN0OiBmYWxzZSxcbiAgU1ZHUG9pbnRMaXN0OiBmYWxzZSxcbiAgU1ZHU3RyaW5nTGlzdDogZmFsc2UsXG4gIFNWR1RyYW5zZm9ybUxpc3Q6IGZhbHNlLFxuICBTb3VyY2VCdWZmZXJMaXN0OiBmYWxzZSxcbiAgU3R5bGVTaGVldExpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBUZXh0VHJhY2tDdWVMaXN0OiBmYWxzZSxcbiAgVGV4dFRyYWNrTGlzdDogZmFsc2UsXG4gIFRvdWNoTGlzdDogZmFsc2Vcbn07XG5cbmZvciAodmFyIGNvbGxlY3Rpb25zID0gZ2V0S2V5cyhET01JdGVyYWJsZXMpLCBpID0gMDsgaSA8IGNvbGxlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gIHZhciBOQU1FID0gY29sbGVjdGlvbnNbaV07XG4gIHZhciBleHBsaWNpdCA9IERPTUl0ZXJhYmxlc1tOQU1FXTtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV07XG4gIHZhciBwcm90byA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIHZhciBrZXk7XG4gIGlmIChwcm90bykge1xuICAgIGlmICghcHJvdG9bSVRFUkFUT1JdKSBoaWRlKHByb3RvLCBJVEVSQVRPUiwgQXJyYXlWYWx1ZXMpO1xuICAgIGlmICghcHJvdG9bVE9fU1RSSU5HX1RBR10pIGhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IEFycmF5VmFsdWVzO1xuICAgIGlmIChleHBsaWNpdCkgZm9yIChrZXkgaW4gJGl0ZXJhdG9ycykgaWYgKCFwcm90b1trZXldKSByZWRlZmluZShwcm90bywga2V5LCAkaXRlcmF0b3JzW2tleV0sIHRydWUpO1xuICB9XG59XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICR0YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpO1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkIsIHtcbiAgc2V0SW1tZWRpYXRlOiAkdGFzay5zZXQsXG4gIGNsZWFySW1tZWRpYXRlOiAkdGFzay5jbGVhclxufSk7XG4iLCIvLyBpZTktIHNldFRpbWVvdXQgJiBzZXRJbnRlcnZhbCBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgZml4XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4vX3VzZXItYWdlbnQnKTtcbnZhciBzbGljZSA9IFtdLnNsaWNlO1xudmFyIE1TSUUgPSAvTVNJRSAuXFwuLy50ZXN0KHVzZXJBZ2VudCk7IC8vIDwtIGRpcnR5IGllOS0gY2hlY2tcbnZhciB3cmFwID0gZnVuY3Rpb24gKHNldCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGZuLCB0aW1lIC8qICwgLi4uYXJncyAqLykge1xuICAgIHZhciBib3VuZEFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICB2YXIgYXJncyA9IGJvdW5kQXJncyA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IGZhbHNlO1xuICAgIHJldHVybiBzZXQoYm91bmRBcmdzID8gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICAodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSA6IGZuLCB0aW1lKTtcbiAgfTtcbn07XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiArICRleHBvcnQuRiAqIE1TSUUsIHtcbiAgc2V0VGltZW91dDogd3JhcChnbG9iYWwuc2V0VGltZW91dCksXG4gIHNldEludGVydmFsOiB3cmFwKGdsb2JhbC5zZXRJbnRlcnZhbClcbn0pO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBydW50aW1lLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEluIHNsb3BweSBtb2RlLCB1bmJvdW5kIGB0aGlzYCByZWZlcnMgdG8gdGhlIGdsb2JhbCBvYmplY3QsIGZhbGxiYWNrIHRvXG4gIC8vIEZ1bmN0aW9uIGNvbnN0cnVjdG9yIGlmIHdlJ3JlIGluIGdsb2JhbCBzdHJpY3QgbW9kZS4gVGhhdCBpcyBzYWRseSBhIGZvcm1cbiAgLy8gb2YgaW5kaXJlY3QgZXZhbCB3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeS5cbiAgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcyB9KSgpIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKVxuKTtcbiIsIi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIHh0ZW5kXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmltcG9ydCB7WHRVdGlsfSBmcm9tICcuLi8uLi8uLi9zY3JpcHRzL3h0ZW5kLXV0aWxzJztcbiIsIi8qISB4dGVuZCAoaHR0cHM6Ly9nZXR4dGVuZC5jb20vKVxuQGNvcHlyaWdodCAoYykgMjAxNyAtIDIwMTggUmljY2FyZG8gQ2Fyb2xpXG5AbGljZW5zZSBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS9taW5pbWl0L3h0ZW5kLWxpYnJhcnkvYmxvYi9tYXN0ZXIvTElDRU5TRSkgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgJ2JhYmVsLXBvbHlmaWxsJztcblxuaW1wb3J0IHtYdFRvZ2dsZSwgWHREcm9wLCBYdE92ZXJsYXksIFh0RmFkZSwgWHRTdGlja3l9IGZyb20gJy4veHRlbmQnO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBjb25zdHJ1Y3RvclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5jb25zdCBYdFV0aWwgPSB7fTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gcHJvcGVydGllc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLyBYdCBjdXJyZW50cyBiYXNlZCBvbiBuYW1lc3BhY2UgKHNvIHNoYXJlZCBiZXR3ZWVuIFh0IG9iamVjdHMpXG5cblh0VXRpbC5jdXJyZW50cyA9IHt9O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBtZXRob2RzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogaW5pdCBhbGwgZGF0YS14dCBjbGFzc2VzXG4gKi9cblh0VXRpbC5pbml0QWxsID0gZnVuY3Rpb24gKGNvbnRhaW5lciA9IGRvY3VtZW50KSB7XG4gIC8vIHh0LXRvZ2dsZVxuICBBcnJheS5mcm9tKGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS14dC10b2dnbGVdJykpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgbmV3IFh0VG9nZ2xlKGVsKTtcbiAgfSk7XG4gIEFycmF5LmZyb20oY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXh0LWRyb3BdJykpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgbmV3IFh0RHJvcChlbCk7XG4gIH0pO1xuICBBcnJheS5mcm9tKGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS14dC1vdmVybGF5XScpKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgIG5ldyBYdE92ZXJsYXkoZWwpO1xuICB9KTtcbiAgQXJyYXkuZnJvbShjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEteHQtZmFkZV0nKSkuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICBuZXcgWHRGYWRlKGVsKTtcbiAgfSk7XG4gIEFycmF5LmZyb20oY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXh0LXN0aWNreV0nKSkuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICBuZXcgWHRTdGlja3koZWwpO1xuICB9KTtcbn07XG5cbi8qKlxuICogcmVxdWVzdCBhbmltYXRpb24gZnJhbWVcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGFuaW1hdGlvbkZyYW1lSURcbiAqIFVTQUdFOiBsZXQgYW5pbWF0aW9uRnJhbWUgPSBYdFV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmNhbGwod2luZG93LCBmdW5jdGlvbiAoKSB7fSk7XG4gKi9cblh0VXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgfTtcbn0oKTtcblxuLyoqXG4gKiBjYW5jZWwgYW5pbWF0aW9uIGZyYW1lXG4gKiBVU0FHRTogWHRVdGlsLmNhbmNlbEFuaW1hdGlvbkZyYW1lLmNhbGwod2luZG93LCBhbmltYXRpb25GcmFtZUlEKTtcbiAqL1xuWHRVdGlsLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgd2luZG93LmNsZWFyVGltZW91dChpZCk7XG4gIH07XG59KCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgZXZlbnQgdGFyZ2V0IGlzIGluc2lkZSBlbGVtZW50c1xuICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCB0byBjaGVjayB0YXJnZXRcbiAqIEBwYXJhbSB7Tm9kZUxpc3R8QXJyYXl9IHRhcmdldHMgRWxlbWVudHMgdG8gY2hlY2sgaW5zaWRlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5YdFV0aWwuY2hlY2tJbnNpZGUgPSBmdW5jdGlvbiAoZSwgdGFyZ2V0cykge1xuICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gIGZvciAobGV0IHQgb2YgdGFyZ2V0cykge1xuICAgIGlmIChlLnRhcmdldCA9PT0gdCB8fCB0LmNvbnRhaW5zKGUudGFyZ2V0KSkge1xuICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgZXZlbnQgdGFyZ2V0IGlzIG91dHNpZGUgZWxlbWVudHNcbiAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgdG8gY2hlY2sgdGFyZ2V0XG4gKiBAcGFyYW0ge05vZGVMaXN0fEFycmF5fSB0YXJnZXRzIEVsZW1lbnRzIHRvIGNoZWNrIE91dHNpZGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblh0VXRpbC5jaGVja091dHNpZGUgPSBmdW5jdGlvbiAoZSwgdGFyZ2V0cykge1xuICBsZXQgcmVzdWx0ID0gdHJ1ZTtcbiAgZm9yIChsZXQgdCBvZiB0YXJnZXRzKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSB0IHx8IHQuY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogR2V0IHNjcm9sbGJhciB3aWR0aCBvZiBkb2N1bWVudFxuICogQHJldHVybnMge051bWJlcn0gU2Nyb2xsYmFyIHdpZHRoXG4gKi9cblh0VXRpbC5zY3JvbGxiYXJXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gYWRkIG91dGVyXG4gIGxldCBvdXRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBvdXRlci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gIG91dGVyLnN0eWxlLndpZHRoID0gJzEwMHB4JztcbiAgb3V0ZXIuc3R5bGUubXNPdmVyZmxvd1N0eWxlID0gJ3Njcm9sbGJhcic7IC8vIG5lZWRlZCBmb3IgV2luSlMgYXBwc1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG91dGVyKTtcbiAgbGV0IHdpZHRoTm9TY3JvbGwgPSBvdXRlci5vZmZzZXRXaWR0aDtcbiAgLy8gZm9yY2Ugc2Nyb2xsYmFyc1xuICBvdXRlci5zdHlsZS5vdmVyZmxvdyA9ICdzY3JvbGwnO1xuICAvLyBhZGQgaW5uZXJcbiAgbGV0IGlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGlubmVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICBvdXRlci5hcHBlbmRDaGlsZChpbm5lcik7XG4gIGxldCB3aWR0aFdpdGhTY3JvbGwgPSBpbm5lci5vZmZzZXRXaWR0aDtcbiAgLy8gcmVtb3ZlXG4gIG91dGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob3V0ZXIpO1xuICByZXR1cm4gd2lkdGhOb1Njcm9sbCAtIHdpZHRoV2l0aFNjcm9sbDtcbn07XG5cbi8qKlxuICogR2V0IHVuaXF1ZSBpZFxuICogQHJldHVybnMge1N0cmluZ30gVW5pcXVlIGlkXG4gKi9cblh0VXRpbC5nZXRVbmlxdWVJRCA9IGZ1bmN0aW9uICgpIHtcbiAgWHRVdGlsLnVpZCA9IFh0VXRpbC51aWQgIT09IHVuZGVmaW5lZCA/IFh0VXRpbC51aWQgOiAwO1xuICByZXR1cm4gJ3VuaXF1ZS1pZC0nICsgKFh0VXRpbC51aWQrKyk7XG59O1xuXG4vKipcbiAqIEdldCB1bmlxdWUgbnVtYmVyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBVbmlxdWUgbnVtYmVyXG4gKi9cblh0VXRpbC5nZXRVbmlxdWVOdW0gPSBmdW5jdGlvbiAoKSB7XG4gIFh0VXRpbC51bnVtYmVyID0gWHRVdGlsLnVudW1iZXIgIT09IHVuZGVmaW5lZCA/IFh0VXRpbC51bnVtYmVyIDogMDtcbiAgcmV0dXJuIFh0VXRpbC51bnVtYmVyKys7XG59O1xuXG4vKipcbiAqIE1lcmdlIG9iamVjdHNcbiAqIEBwYXJhbSB7QXJyYXl9IGFyciBBcnJheSBvZiBvYmplY3RzIHRvIG1lcmdlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBNZXJnZWQgb2JqZWN0XG4gKi9cblh0VXRpbC5tZXJnZSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgbGV0IGZpbmFsID0ge307XG4gIGZvciAobGV0IG9iaiBvZiBhcnIpIHtcbiAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob2JqKSkge1xuICAgICAgZmluYWxba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmluYWw7XG59O1xuXG4vKipcbiAqIE1ha2UgYW4gYXJyYXkgd2hlbiBlbGVtZW50IGlzIG9ubHkgb25lXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gZWxlbWVudFxuICogQHJldHVybnMge0FycmF5fVxuICovXG5YdFV0aWwuYXJyU2luZ2xlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQubGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgYXJyID0gbmV3IEFycmF5KDEpO1xuICAgIGFyclswXSA9IGVsZW1lbnQ7XG4gICAgcmV0dXJuIGFycjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGUgRE9NIGVsZW1lbnQgZnJvbSBodG1sIHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBIdG1sIHN0cmluZyAob25seSAxIHJvb3QgaHRtbCB0YWcpXG4gKiBAcmV0dXJuIHtOb2RlfEhUTUxFbGVtZW50fSBET00gZWxlbWVudFxuICovXG5YdFV0aWwuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgbGV0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gc3RyLnRyaW0oKTtcbiAgcmV0dXJuIGRpdi5maXJzdENoaWxkO1xufTtcblxuLyoqXG4gKiBRdWVyeSBlbGVtZW50J3MgcGFyZW50c1xuICogQHBhcmFtIHtOb2RlfEhUTUxFbGVtZW50fSBlbGVtZW50IENoaWxkIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeSBRdWVyeSBwYXJlbnRzXG4gKiBAcmV0dXJuIHtBcnJheX0gUGFyZW50cyBlbGVtZW50cyBieSBxdWVyeVxuICovXG5YdFV0aWwucGFyZW50cyA9IGZ1bmN0aW9uIChlbGVtZW50LCBxdWVyeSkge1xuICBsZXQgcGFyZW50cyA9IFtdO1xuICB3aGlsZSAoZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudC5jbG9zZXN0KHF1ZXJ5KSkge1xuICAgIHBhcmVudHMucHVzaChlbGVtZW50KTtcbiAgfVxuICByZXR1cm4gcGFyZW50cztcbn07XG5cbi8qKlxuICogZGF0YVN0b3JhZ2VcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI5MjIyMDI3L3ZhbmlsbGEtYWx0ZXJuYXRpdmUtdG8tanF1ZXJ5LWRhdGEtZnVuY3Rpb24tYW55LW5hdGl2ZS1qYXZhc2NyaXB0LWFsdGVybmF0aVxuICogVVNBR0U6IFh0VXRpbC5kYXRhU3RvcmFnZS5wdXQoZWxlbWVudCwgJ2tleScsIHZhbHVlKTtcbiAqL1xuWHRVdGlsLmRhdGFTdG9yYWdlID0ge1xuICBfc3RvcmFnZTogbmV3IFdlYWtNYXAoKSxcbiAgcHV0OiBmdW5jdGlvbiAoZWxlbWVudCwga2V5LCBvYmopIHtcbiAgICBpZiAoIXRoaXMuX3N0b3JhZ2UuaGFzKGtleSkpIHtcbiAgICAgIHRoaXMuX3N0b3JhZ2Uuc2V0KGVsZW1lbnQsIG5ldyBNYXAoKSk7XG4gICAgfVxuICAgIHRoaXMuX3N0b3JhZ2UuZ2V0KGVsZW1lbnQpLnNldChrZXksIG9iaik7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2UuZ2V0KGVsZW1lbnQpLmdldChrZXkpO1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uIChlbGVtZW50LCBrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RvcmFnZS5nZXQoZWxlbWVudCkuZ2V0KGtleSk7XG4gIH0sXG4gIGhhczogZnVuY3Rpb24gKGVsZW1lbnQsIGtleSkge1xuICAgIHJldHVybiB0aGlzLl9zdG9yYWdlLmdldChlbGVtZW50KS5oYXMoa2V5KTtcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbiAoZWxlbWVudCwga2V5KSB7XG4gICAgbGV0IHJldCA9IHRoaXMuX3N0b3JhZ2UuZ2V0KGVsZW1lbnQpLmRlbGV0ZShrZXkpO1xuICAgIGlmICghdGhpcy5fc3RvcmFnZS5nZXQoa2V5KS5zaXplID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5fc3RvcmFnZS5kZWxldGUoZWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbn07XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGFwaVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG53aW5kb3cuWHRVdGlsID0gWHRVdGlsO1xuZXhwb3J0IHtYdFV0aWx9O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBjbG9zZXN0IHBvbHlmaWxsXG4vLyBodHRwczovL2dpdGh1Yi5jb20vam9uYXRoYW50bmVhbC9jbG9zZXN0XG4vLyBVU0FHRTogZWxlbWVudC5jbG9zZXN0KHF1ZXJ5KTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuKGZ1bmN0aW9uIChFbGVtZW50UHJvdG8pIHtcbiAgaWYgKHR5cGVvZiBFbGVtZW50UHJvdG8ubWF0Y2hlcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIEVsZW1lbnRQcm90by5tYXRjaGVzID0gRWxlbWVudFByb3RvLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnRQcm90by5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudFByb3RvLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBmdW5jdGlvbiBtYXRjaGVzKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXM7XG4gICAgICB2YXIgZWxlbWVudHMgPSAoZWxlbWVudC5kb2N1bWVudCB8fCBlbGVtZW50Lm93bmVyRG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHdoaWxlIChlbGVtZW50c1tpbmRleF0gJiYgZWxlbWVudHNbaW5kZXhdICE9PSBlbGVtZW50KSB7XG4gICAgICAgICsraW5kZXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gQm9vbGVhbihlbGVtZW50c1tpbmRleF0pO1xuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBFbGVtZW50UHJvdG8uY2xvc2VzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIEVsZW1lbnRQcm90by5jbG9zZXN0ID0gZnVuY3Rpb24gY2xvc2VzdChzZWxlY3Rvcikge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzO1xuICAgICAgd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICBpZiAoZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICB9XG59KSh3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUpO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBzY29wZSBwb2x5ZmlsbFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pvbmF0aGFudG5lYWwvZWxlbWVudC1xc2Etc2NvcGVcbi8vIFVTQUdFOiBxdWVyeVNlbGVjdG9yQWxsKCc6c2NvcGUgPiAuc2VsZWN0b3InKTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuKGZ1bmN0aW9uIChFbGVtZW50UHJvdG90eXBlKSB7XG4gIHRyeSB7XG4gICAgLy8gdGVzdCBmb3Igc2NvcGUgc3VwcG9ydFxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJzpzY29wZSAqJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gc2NvcGUgcmVnZXhcbiAgICBsZXQgc2NvcGUgPSAvOnNjb3BlKD8hW1xcdy1dKS9naTtcbiAgICAvLyBwb2x5ZmlsbCBFbGVtZW50I3F1ZXJ5U2VsZWN0b3JcbiAgICBsZXQgcXVlcnlTZWxlY3RvcldpdGhTY29wZSA9IHBvbHlmaWxsKEVsZW1lbnRQcm90b3R5cGUucXVlcnlTZWxlY3Rvcik7XG4gICAgRWxlbWVudFByb3RvdHlwZS5xdWVyeVNlbGVjdG9yID0gZnVuY3Rpb24gcXVlcnlTZWxlY3RvcihzZWxlY3RvcnMpIHtcbiAgICAgIHJldHVybiBxdWVyeVNlbGVjdG9yV2l0aFNjb3BlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICAvLyBwb2x5ZmlsbCBFbGVtZW50I3F1ZXJ5U2VsZWN0b3JBbGxcbiAgICBsZXQgcXVlcnlTZWxlY3RvckFsbFdpdGhTY29wZSA9IHBvbHlmaWxsKEVsZW1lbnRQcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbCk7XG4gICAgRWxlbWVudFByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsID0gZnVuY3Rpb24gcXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcnMpIHtcbiAgICAgIHJldHVybiBxdWVyeVNlbGVjdG9yQWxsV2l0aFNjb3BlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICAvLyBwb2x5ZmlsbCBFbGVtZW50I21hdGNoZXNcbiAgICBpZiAoRWxlbWVudFByb3RvdHlwZS5tYXRjaGVzKSB7XG4gICAgICBsZXQgbWF0Y2hlc1dpdGhTY29wZSA9IHBvbHlmaWxsKEVsZW1lbnRQcm90b3R5cGUubWF0Y2hlcyk7XG4gICAgICBFbGVtZW50UHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbiBtYXRjaGVzKHNlbGVjdG9ycykge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc1dpdGhTY29wZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG4gICAgLy8gcG9seWZpbGwgRWxlbWVudCNjbG9zZXN0XG4gICAgaWYgKEVsZW1lbnRQcm90b3R5cGUuY2xvc2VzdCkge1xuICAgICAgbGV0IGNsb3Nlc3RXaXRoU2NvcGUgPSBwb2x5ZmlsbChFbGVtZW50UHJvdG90eXBlLmNsb3Nlc3QpO1xuICAgICAgRWxlbWVudFByb3RvdHlwZS5jbG9zZXN0ID0gZnVuY3Rpb24gY2xvc2VzdChzZWxlY3RvcnMpIHtcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3RXaXRoU2NvcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvbHlmaWxsKHFzYSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzZWxlY3RvcnMpIHtcbiAgICAgICAgLy8gd2hldGhlciB0aGUgc2VsZWN0b3JzIGNvbnRhaW4gOnNjb3BlXG4gICAgICAgIGxldCBoYXNTY29wZSA9IHNlbGVjdG9ycyAmJiBzY29wZS50ZXN0KHNlbGVjdG9ycyk7XG4gICAgICAgIGlmIChoYXNTY29wZSkge1xuICAgICAgICAgIC8vIGZhbGxiYWNrIGF0dHJpYnV0ZVxuICAgICAgICAgIGxldCBhdHRyID0gJ3EnICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogOTAwMDAwMCkgKyAxMDAwMDAwO1xuICAgICAgICAgIC8vIHJlcGxhY2UgOnNjb3BlIHdpdGggdGhlIGZhbGxiYWNrIGF0dHJpYnV0ZVxuICAgICAgICAgIGFyZ3VtZW50c1swXSA9IHNlbGVjdG9ycy5yZXBsYWNlKHNjb3BlLCAnWycgKyBhdHRyICsgJ10nKTtcbiAgICAgICAgICAvLyBhZGQgdGhlIGZhbGxiYWNrIGF0dHJpYnV0ZVxuICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGF0dHIsICcnKTtcbiAgICAgICAgICAvLyByZXN1bHRzIG9mIHRoZSBxc2FcbiAgICAgICAgICBsZXQgZWxlbWVudE9yTm9kZUxpc3QgPSBxc2EuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAvLyByZW1vdmUgdGhlIGZhbGxiYWNrIGF0dHJpYnV0ZVxuICAgICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgICAgIC8vIHJldHVybiB0aGUgcmVzdWx0cyBvZiB0aGUgcXNhXG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnRPck5vZGVMaXN0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHJldHVybiB0aGUgcmVzdWx0cyBvZiB0aGUgcXNhXG4gICAgICAgICAgcmV0dXJuIHFzYS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfVxufSkoRWxlbWVudC5wcm90b3R5cGUpO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBDdXN0b21FdmVudCBwb2x5ZmlsbFxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50L0N1c3RvbUV2ZW50XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbihmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBDdXN0b21FdmVudChldmVudCwgcGFyYW1zKSB7XG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHtidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogdW5kZWZpbmVkfTtcbiAgICBsZXQgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcbiAgICByZXR1cm4gZXZ0O1xuICB9XG5cbiAgQ3VzdG9tRXZlbnQucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZTtcbiAgd2luZG93LkN1c3RvbUV2ZW50ID0gQ3VzdG9tRXZlbnQ7XG59KSgpO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBzY3JvbGxpbmdFbGVtZW50IHBvbHlmaWxsXG4vLyBodHRwczovL2dpdGh1Yi5jb20veWFuZ2cvc2Nyb2xsaW5nLWVsZW1lbnRcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuKGZ1bmN0aW9uICgpIHtcbiAgaWYgKGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGVsZW1lbnQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHNjcm9sbGluZ0VsZW1lbnQoKSB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuYm9keS5zY3JvbGxUb3ApIHtcbiAgICAgIC8vIHNwZWVkIHVwIGlmIHNjcm9sbFRvcCA+IDBcbiAgICAgIHJldHVybiAoZWxlbWVudCA9IGRvY3VtZW50LmJvZHkpO1xuICAgIH1cbiAgICBsZXQgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgaWZyYW1lLnN0eWxlLmhlaWdodCA9ICcxcHgnO1xuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIGxldCBkb2MgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgICBkb2Mud3JpdGUoJzwhRE9DVFlQRSBodG1sPjxkaXYgc3R5bGU9XCJoZWlnaHQ6OTk5OWVtXCI+eDwvZGl2PicpO1xuICAgIGRvYy5jbG9zZSgpO1xuICAgIGxldCBpc0NvbXBsaWFudCA9IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gZG9jLmJvZHkuc2Nyb2xsSGVpZ2h0O1xuICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgcmV0dXJuIChlbGVtZW50ID0gaXNDb21wbGlhbnQgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiBkb2N1bWVudC5ib2R5KTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkb2N1bWVudCwgJ3Njcm9sbGluZ0VsZW1lbnQnLCB7XG4gICAgZ2V0OiBzY3JvbGxpbmdFbGVtZW50XG4gIH0pXG59KSgpO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBhcHBlbmQgcG9seWZpbGxcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9QYXJlbnROb2RlL2FwcGVuZFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4oZnVuY3Rpb24gKGFycikge1xuICBhcnIuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtLmhhc093blByb3BlcnR5KCdhcHBlbmQnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaXRlbSwgJ2FwcGVuZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmQoKSB7XG4gICAgICAgIGxldCBhcmdBcnIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgIGRvY0ZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICAgICAgYXJnQXJyLmZvckVhY2goZnVuY3Rpb24gKGFyZ0l0ZW0pIHtcbiAgICAgICAgICBsZXQgaXNOb2RlID0gYXJnSXRlbSBpbnN0YW5jZW9mIE5vZGU7XG4gICAgICAgICAgZG9jRnJhZy5hcHBlbmRDaGlsZChpc05vZGUgPyBhcmdJdGVtIDogZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGFyZ0l0ZW0pKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZG9jRnJhZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufSkoW0VsZW1lbnQucHJvdG90eXBlLCBEb2N1bWVudC5wcm90b3R5cGUsIERvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlXSk7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGJlZm9yZSBwb2x5ZmlsbFxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NoaWxkTm9kZS9iZWZvcmVcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuKGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbS5oYXNPd25Qcm9wZXJ0eSgnYmVmb3JlJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0ZW0sICdiZWZvcmUnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYmVmb3JlKCkge1xuICAgICAgICBsZXQgYXJnQXJyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgICAgICBkb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgICAgIGFyZ0Fyci5mb3JFYWNoKGZ1bmN0aW9uIChhcmdJdGVtKSB7XG4gICAgICAgICAgbGV0IGlzTm9kZSA9IGFyZ0l0ZW0gaW5zdGFuY2VvZiBOb2RlO1xuICAgICAgICAgIGRvY0ZyYWcuYXBwZW5kQ2hpbGQoaXNOb2RlID8gYXJnSXRlbSA6IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhhcmdJdGVtKSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGRvY0ZyYWcsIHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn0pKFtFbGVtZW50LnByb3RvdHlwZSwgQ2hhcmFjdGVyRGF0YS5wcm90b3R5cGUsIERvY3VtZW50VHlwZS5wcm90b3R5cGVdKTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gZW50cmllcyBwb2x5ZmlsbFxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2VudHJpZXNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuKGZ1bmN0aW9uIChvYmopIHtcbiAgaWYgKCFvYmouZW50cmllcykge1xuICAgIG9iai5lbnRyaWVzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgbGV0IG93blByb3BzID0gT2JqZWN0LmtleXMob2JqKSxcbiAgICAgICAgaSA9IG93blByb3BzLmxlbmd0aCxcbiAgICAgICAgcmVzQXJyYXkgPSBuZXcgQXJyYXkoaSk7IC8vIHByZWFsbG9jYXRlIHRoZSBBcnJheVxuICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAgcmVzQXJyYXlbaV0gPSBbb3duUHJvcHNbaV0sIG9ialtvd25Qcm9wc1tpXV1dO1xuXG4gICAgICByZXR1cm4gcmVzQXJyYXk7XG4gICAgfTtcbiAgfVxufSkoT2JqZWN0KTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQXJyYXkuZnJvbSBwb2x5ZmlsbFxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZnJvbVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4oZnVuY3Rpb24gKGFycikge1xuICBpZiAoIWFyci5mcm9tKSB7XG4gICAgYXJyLmZyb20gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICAgIHZhciBpc0NhbGxhYmxlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgfHwgdG9TdHIuY2FsbChmbikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgICB9O1xuICAgICAgdmFyIHRvSW50ZWdlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgbnVtYmVyID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgaWYgKGlzTmFOKG51bWJlcikpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtYmVyID09PSAwIHx8ICFpc0Zpbml0ZShudW1iZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG51bWJlciA+IDAgPyAxIDogLTEpICogTWF0aC5mbG9vcihNYXRoLmFicyhudW1iZXIpKTtcbiAgICAgIH07XG4gICAgICB2YXIgbWF4U2FmZUludGVnZXIgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuICAgICAgdmFyIHRvTGVuZ3RoID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBsZW4gPSB0b0ludGVnZXIodmFsdWUpO1xuICAgICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobGVuLCAwKSwgbWF4U2FmZUludGVnZXIpO1xuICAgICAgfTtcblxuICAgICAgLy8gVGhlIGxlbmd0aCBwcm9wZXJ0eSBvZiB0aGUgZnJvbSBtZXRob2QgaXMgMS5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZS8qLCBtYXBGbiwgdGhpc0FyZyAqLykge1xuICAgICAgICAvLyAxLiBMZXQgQyBiZSB0aGUgdGhpcyB2YWx1ZS5cbiAgICAgICAgdmFyIEMgPSB0aGlzO1xuXG4gICAgICAgIC8vIDIuIExldCBpdGVtcyBiZSBUb09iamVjdChhcnJheUxpa2UpLlxuICAgICAgICB2YXIgaXRlbXMgPSBPYmplY3QoYXJyYXlMaWtlKTtcblxuICAgICAgICAvLyAzLiBSZXR1cm5JZkFicnVwdChpdGVtcykuXG4gICAgICAgIGlmIChhcnJheUxpa2UgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LmZyb20gcmVxdWlyZXMgYW4gYXJyYXktbGlrZSBvYmplY3QgLSBub3QgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDQuIElmIG1hcGZuIGlzIHVuZGVmaW5lZCwgdGhlbiBsZXQgbWFwcGluZyBiZSBmYWxzZS5cbiAgICAgICAgdmFyIG1hcEZuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB2b2lkIHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIFQ7XG4gICAgICAgIGlmICh0eXBlb2YgbWFwRm4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gNS4gZWxzZVxuICAgICAgICAgIC8vIDUuIGEgSWYgSXNDYWxsYWJsZShtYXBmbikgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgICBpZiAoIWlzQ2FsbGFibGUobWFwRm4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5mcm9tOiB3aGVuIHByb3ZpZGVkLCB0aGUgc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDUuIGIuIElmIHRoaXNBcmcgd2FzIHN1cHBsaWVkLCBsZXQgVCBiZSB0aGlzQXJnOyBlbHNlIGxldCBUIGJlIHVuZGVmaW5lZC5cbiAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIFQgPSBhcmd1bWVudHNbMl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMTAuIExldCBsZW5WYWx1ZSBiZSBHZXQoaXRlbXMsIFwibGVuZ3RoXCIpLlxuICAgICAgICAvLyAxMS4gTGV0IGxlbiBiZSBUb0xlbmd0aChsZW5WYWx1ZSkuXG4gICAgICAgIHZhciBsZW4gPSB0b0xlbmd0aChpdGVtcy5sZW5ndGgpO1xuXG4gICAgICAgIC8vIDEzLiBJZiBJc0NvbnN0cnVjdG9yKEMpIGlzIHRydWUsIHRoZW5cbiAgICAgICAgLy8gMTMuIGEuIExldCBBIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2RcbiAgICAgICAgLy8gb2YgQyB3aXRoIGFuIGFyZ3VtZW50IGxpc3QgY29udGFpbmluZyB0aGUgc2luZ2xlIGl0ZW0gbGVuLlxuICAgICAgICAvLyAxNC4gYS4gRWxzZSwgTGV0IEEgYmUgQXJyYXlDcmVhdGUobGVuKS5cbiAgICAgICAgdmFyIEEgPSBpc0NhbGxhYmxlKEMpID8gT2JqZWN0KG5ldyBDKGxlbikpIDogbmV3IEFycmF5KGxlbik7XG5cbiAgICAgICAgLy8gMTYuIExldCBrIGJlIDAuXG4gICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgLy8gMTcuIFJlcGVhdCwgd2hpbGUgayA8IGxlbuKApiAoYWxzbyBzdGVwcyBhIC0gaClcbiAgICAgICAgdmFyIGtWYWx1ZTtcbiAgICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcbiAgICAgICAgICBrVmFsdWUgPSBpdGVtc1trXTtcbiAgICAgICAgICBpZiAobWFwRm4pIHtcbiAgICAgICAgICAgIEFba10gPSB0eXBlb2YgVCA9PT0gJ3VuZGVmaW5lZCcgPyBtYXBGbihrVmFsdWUsIGspIDogbWFwRm4uY2FsbChULCBrVmFsdWUsIGspO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBBW2tdID0ga1ZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMTguIExldCBwdXRTdGF0dXMgYmUgUHV0KEEsIFwibGVuZ3RoXCIsIGxlbiwgdHJ1ZSkuXG4gICAgICAgIEEubGVuZ3RoID0gbGVuO1xuICAgICAgICAvLyAyMC4gUmV0dXJuIEEuXG4gICAgICAgIHJldHVybiBBO1xuICAgICAgfTtcbiAgICB9KCkpO1xuICB9XG59KShBcnJheSk7XG4iLCIvKiB4dGVuZCAoaHR0cHM6Ly9nZXR4dGVuZC5jb20vKVxuQGNvcHlyaWdodCAoYykgMjAxNyAtIDIwMTggUmljY2FyZG8gQ2Fyb2xpXG5AbGljZW5zZSBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS9taW5pbWl0L3h0ZW5kLWxpYnJhcnkvYmxvYi9tYXN0ZXIvTElDRU5TRSkgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgJ2JhYmVsLXBvbHlmaWxsJztcblxuaW1wb3J0IHtYdFV0aWx9IGZyb20gJy4veHRlbmQtdXRpbHMnO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBYdFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5jbGFzcyBYdCB7XG5cbiAgLyoqXG4gICAqIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gb2JqZWN0IEJhc2Ugbm9kZVxuICAgKiBAcGFyYW0ge09iamVjdH0ganNPcHRpb25zIFVzZXIgb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciBBdHRyaWJ1dGUgbmFtZSB3aXRoIGpzb24gb3B0aW9uc1xuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9iamVjdCwganNPcHRpb25zID0ge30sIGF0dHIpIHtcbiAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICBpZiAodGhpcy5vYmplY3QpIHtcbiAgICAgIHRoaXMuZGVmYXVsdHMgPSB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRzO1xuICAgICAgLy8ganMgb3B0aW9uc1xuICAgICAgdGhpcy5vcHRpb25zID0gWHRVdGlsLm1lcmdlKFt0aGlzLmRlZmF1bHRzLCBqc09wdGlvbnNdKTtcbiAgICAgIC8vIG1hcmt1cCBvcHRpb25zXG4gICAgICBsZXQgbWFya3VwT3B0aW9ucyA9IHRoaXMub2JqZWN0LmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IFh0VXRpbC5tZXJnZShbdGhpcy5vcHRpb25zLCBtYXJrdXBPcHRpb25zID8gSlNPTi5wYXJzZShtYXJrdXBPcHRpb25zKSA6IHt9XSk7XG4gICAgICAvLyBjbGFzc2VzXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNsYXNzKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5jbGFzc2VzID0gWy4uLnRoaXMub3B0aW9ucy5jbGFzcy5zcGxpdCgnICcpXTtcbiAgICAgIH1cbiAgICAgIC8vIGluaXRcbiAgICAgIHRoaXMuaW5pdFNldHVwKCk7XG4gICAgICB0aGlzLmluaXRTY29wZSgpO1xuICAgICAgdGhpcy5pbml0RXZlbnRzKCk7XG4gICAgICB0aGlzLmluaXRBcmlhKCk7XG4gICAgfVxuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBpbml0XG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAvKipcbiAgICogc2V0dXAgbmFtZXNwYWNlLCBjb250YWluZXIgYW5kIG9wdGlvbnNcbiAgICovXG4gIGluaXRTZXR1cCgpIHtcbiAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgbGV0IG9wdGlvbnMgPSBzZWxmLm9wdGlvbnM7XG4gICAgLy8gc2V0dXAgKGJhc2VkIG9uIHh0ZW5kIG1vZGUpXG4gICAgaWYgKG9wdGlvbnMudGFyZ2V0cyAmJiBvcHRpb25zLnRhcmdldHMuaW5kZXhPZignIycpICE9PSAtMSkge1xuICAgICAgLy8geHRlbmQgYWxsIG1vZGVcbiAgICAgIHRoaXMubW9kZSA9ICdhbGwnO1xuICAgICAgdGhpcy5jb250YWluZXIgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICBvcHRpb25zLm1heCA9IEluZmluaXR5O1xuICAgICAgdGhpcy5uYW1lc3BhY2UgPSBvcHRpb25zLnRhcmdldHMudG9TdHJpbmcoKSArICctJyArIG9wdGlvbnMuY2xhc3Nlcy50b1N0cmluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB4dGVuZCB1bmlxdWUgbW9kZVxuICAgICAgdGhpcy5tb2RlID0gJ3VuaXF1ZSc7XG4gICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMub2JqZWN0O1xuICAgICAgdGhpcy5uYW1lc3BhY2UgPSBYdFV0aWwuZ2V0VW5pcXVlSUQoKTtcbiAgICB9XG4gICAgLy8gZmluYWwgbmFtZXNwYWNlXG4gICAgdGhpcy5uYW1lc3BhY2UgPSB0aGlzLm5hbWVzcGFjZS5yZXBsYWNlKC9cXFcrL2csICcnKTtcbiAgICAvLyBjdXJyZW50cyBhcnJheSBiYXNlZCBvbiBuYW1lc3BhY2UgKHNvIHNoYXJlZCBiZXR3ZWVuIFh0IG9iamVjdHMpXG4gICAgaWYgKCF0aGlzLmdldEN1cnJlbnRzKCkpIHtcbiAgICAgIHRoaXMuc2V0Q3VycmVudHMoW10pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBpbml0IGVsZW1lbnRzLCB0YXJnZXRzIGFuZCBjdXJyZW50c1xuICAgKi9cbiAgaW5pdFNjb3BlKCkge1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBsZXQgb3B0aW9ucyA9IHNlbGYub3B0aW9ucztcbiAgICAvLyBlbGVtZW50c1xuICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcbiAgICBpZiAob3B0aW9ucy5lbGVtZW50cykge1xuICAgICAgdGhpcy5lbGVtZW50cyA9IFh0VXRpbC5hcnJTaW5nbGUodGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChvcHRpb25zLmVsZW1lbnRzKSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5lbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZWxlbWVudHMgPSBYdFV0aWwuYXJyU2luZ2xlKHRoaXMub2JqZWN0KTtcbiAgICAgIC8vIEBGSVggb24gbmV4dCBmcmFtZSBzZXQgYWxsIGVsZW1lbnRzIHF1ZXJ5aW5nIHRoZSBuYW1lc3BhY2VcbiAgICAgIFh0VXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuY2FsbCh3aW5kb3csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IG5hbWVzcGFjZVF1ZXJ5ID0gJ1tkYXRhLXh0LWlkPScgKyBzZWxmLm5hbWVzcGFjZSArICddJztcbiAgICAgICAgc2VsZi5lbGVtZW50cyA9IFh0VXRpbC5hcnJTaW5nbGUoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChuYW1lc3BhY2VRdWVyeSkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHRhcmdldHNcbiAgICBpZiAob3B0aW9ucy50YXJnZXRzKSB7XG4gICAgICBsZXQgYXJyID0gQXJyYXkuZnJvbSh0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKG9wdGlvbnMudGFyZ2V0cykpO1xuICAgICAgYXJyID0gYXJyLmZpbHRlcih4ID0+ICFYdFV0aWwucGFyZW50cyh4LCBvcHRpb25zLnRhcmdldHMpLmxlbmd0aCk7IC8vIGZpbHRlciBvdXQgcGFyZW50XG4gICAgICB0aGlzLnRhcmdldHMgPSBhcnI7XG4gICAgfVxuICAgIC8vIGFwcGVuZFRvXG4gICAgaWYgKG9wdGlvbnMuYXBwZW5kVG8pIHtcbiAgICAgIGxldCBhcHBlbmRUb1RhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwob3B0aW9ucy5hcHBlbmRUbyk7XG4gICAgICBpZiAoYXBwZW5kVG9UYXJnZXQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIGFwcGVuZFRvVGFyZ2V0WzBdLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEBGSVggc2V0IG5hbWVzcGFjZSBmb3IgbmV4dCBmcmFtZVxuICAgIGZvciAobGV0IGVsIG9mIHRoaXMuZWxlbWVudHMpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS14dC1pZCcsIHNlbGYubmFtZXNwYWNlKTtcbiAgICB9XG4gICAgLy8gY3VycmVudHNcbiAgICBYdFV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmNhbGwod2luZG93LCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5lbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgLy8gYWN0aXZhdGUgb3B0aW9ucy5jbGFzc1xuICAgICAgICBmb3IgKGxldCBlbCBvZiBzZWxmLmVsZW1lbnRzKSB7XG4gICAgICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucyguLi5vcHRpb25zLmNsYXNzZXMpKSB7XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKC4uLm9wdGlvbnMuY2xhc3Nlcyk7IC8vIHJlbW92ZSB0byBhY3RpdmF0ZSBhbHNvIHRhcmdldHNcbiAgICAgICAgICAgIHNlbGYuZXZlbnRPbihlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGN1cnJlbnRzIDwgbWluXG4gICAgICAgIGxldCB0b2RvID0gb3B0aW9ucy5taW4gLSBzZWxmLmdldEN1cnJlbnRzKCkubGVuZ3RoO1xuICAgICAgICBpZiAodG9kbykge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9kbzsgaSsrKSB7XG4gICAgICAgICAgICBzZWxmLmV2ZW50T24oc2VsZi5lbGVtZW50c1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogaW5pdCBhcmlhXG4gICAqL1xuICBpbml0QXJpYSgpIHtcbiAgICBpZiAodGhpcy50YXJnZXRzKSB7XG4gICAgICBmb3IgKGxldCB0ciBvZiB0aGlzLnRhcmdldHMpIHtcbiAgICAgICAgLy8gYXJpYS1sYWJlbFxuICAgICAgICBsZXQgaGVhZGVycyA9IHRyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2gxLCBoMiwgaDMsIGg0LCBoNSwgaDYnKTtcbiAgICAgICAgbGV0IGxhYmVsID0gaGVhZGVycy5sZW5ndGggPyBoZWFkZXJzIDogdGhpcy5nZXRFbGVtZW50c0Zyb21UYXJnZXQodHIpO1xuICAgICAgICBpZiAobGFiZWwubGVuZ3RoKSB7XG4gICAgICAgICAgbGFiZWwgPSBsYWJlbFswXS5pbm5lclRleHQucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKTtcbiAgICAgICAgICB0ci5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBsYWJlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogaW5pdCBldmVudHNcbiAgICovXG4gIGluaXRFdmVudHMoKSB7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBvcHRpb25zID0gc2VsZi5vcHRpb25zO1xuICAgIC8vIGV2ZW50c1xuICAgIGZvciAobGV0IGVsIG9mIHRoaXMuZWxlbWVudHMpIHtcbiAgICAgIGlmIChvcHRpb25zLm9uKSB7XG4gICAgICAgIC8vIGhhbmRsZXJcbiAgICAgICAgbGV0IHh0T25IYW5kbGVyID0gWHRVdGlsLmRhdGFTdG9yYWdlLnB1dChlbCwgJ3h0T25IYW5kbGVyJywgc2VsZi5ldmVudE9uSGFuZGxlci5iaW5kKHNlbGYpLmJpbmQoc2VsZiwgZWwpKTtcbiAgICAgICAgLy8gZXZlbnRcbiAgICAgICAgbGV0IGV2ZW50cyA9IFsuLi5vcHRpb25zLm9uLnNwbGl0KCcgJyldO1xuICAgICAgICBmb3IgKGxldCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCB4dE9uSGFuZGxlcik7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgeHRPbkhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxpc3RlbmVyXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ29uLnRyaWdnZXInLCB4dE9uSGFuZGxlcik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5vZmYpIHtcbiAgICAgICAgLy8gaGFuZGxlclxuICAgICAgICBsZXQgeHRPZmZIYW5kbGVyID0gWHRVdGlsLmRhdGFTdG9yYWdlLnB1dChlbCwgJ3h0T2ZmSGFuZGxlcicsIHNlbGYuZXZlbnRPZmZIYW5kbGVyLmJpbmQoc2VsZikuYmluZChzZWxmLCBlbCkpO1xuICAgICAgICAvLyBldmVudFxuICAgICAgICBsZXQgZXZlbnRzID0gWy4uLm9wdGlvbnMub2ZmLnNwbGl0KCcgJyldO1xuICAgICAgICBmb3IgKGxldCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCB4dE9mZkhhbmRsZXIpO1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIHh0T2ZmSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbGlzdGVuZXJcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignb2ZmLnRyaWdnZXInLCB4dE9mZkhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBsaXN0ZW5lclxuICAgIGZvciAobGV0IHRyIG9mIHRoaXMudGFyZ2V0cykge1xuICAgICAgbGV0IGVsID0gdGhpcy5nZXRFbGVtZW50c0Zyb21UYXJnZXQodHIpWzBdO1xuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIC8vIGhhbmRsZXJcbiAgICAgICAgbGV0IHh0T25IYW5kbGVyID0gWHRVdGlsLmRhdGFTdG9yYWdlLnB1dChlbCwgJ3h0T25IYW5kbGVyJywgc2VsZi5ldmVudE9uSGFuZGxlci5iaW5kKHNlbGYpLmJpbmQoc2VsZiwgZWwpKTtcbiAgICAgICAgbGV0IHh0T2ZmSGFuZGxlciA9IFh0VXRpbC5kYXRhU3RvcmFnZS5wdXQoZWwsICd4dE9mZkhhbmRsZXInLCBzZWxmLmV2ZW50T2ZmSGFuZGxlci5iaW5kKHNlbGYpLmJpbmQoc2VsZiwgZWwpKTtcbiAgICAgICAgLy8gbGlzdGVuZXJcbiAgICAgICAgdHIuYWRkRXZlbnRMaXN0ZW5lcignb24udHJpZ2dlcicsIHh0T25IYW5kbGVyKTtcbiAgICAgICAgdHIuYWRkRXZlbnRMaXN0ZW5lcignb2ZmLnRyaWdnZXInLCB4dE9mZkhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBhdXRvXG4gICAgaWYgKG9wdGlvbnMuYXV0bykge1xuICAgICAgdGhpcy5hdXRvKCk7XG4gICAgICAvLyBmb2N1cyBhbmQgYmx1clxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmF1dG8oKTtcbiAgICAgIH0pO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuYXV0b1N0b3AoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBlbGVtZW50IG9uIGhhbmRsZXJcbiAgICogQHBhcmFtIHtOb2RlfEhUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICovXG4gIGV2ZW50T25IYW5kbGVyKGVsZW1lbnQsIGUpIHtcbiAgICBsZXQgZXZlbnRMaW1pdCA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5ldmVudC1saW1pdCcpO1xuICAgIGlmIChldmVudExpbWl0Lmxlbmd0aCkge1xuICAgICAgaWYgKFh0VXRpbC5jaGVja091dHNpZGUoZSwgZXZlbnRMaW1pdCkpIHtcbiAgICAgICAgdGhpcy5ldmVudE9uKGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV2ZW50T24oZWxlbWVudCk7XG4gICAgfVxuICAgIC8vIGF1dG9cbiAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9QYXVzZSkge1xuICAgICAgdGhpcy5hdXRvUGF1c2UoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5hdXRvKSB7XG4gICAgICB0aGlzLmF1dG8oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZWxlbWVudCBvZmYgaGFuZGxlclxuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgZXZlbnRPZmZIYW5kbGVyKGVsZW1lbnQsIGUpIHtcbiAgICBsZXQgZXZlbnRMaW1pdCA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5ldmVudC1saW1pdCcpO1xuICAgIGlmIChldmVudExpbWl0Lmxlbmd0aCkge1xuICAgICAgaWYgKFh0VXRpbC5jaGVja091dHNpZGUoZSwgZXZlbnRMaW1pdCkpIHtcbiAgICAgICAgdGhpcy5ldmVudE9mZihlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ldmVudE9mZihlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogc2V0IGF1dG8gY2hhbmdlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5zdGFudFxuICAgKi9cbiAgYXV0byhpbnN0YW50ID0gZmFsc2UpIHtcbiAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgbGV0IG9wdGlvbnMgPSBzZWxmLm9wdGlvbnM7XG4gICAgLy8gYXV0b1xuICAgIHRoaXMuYXV0b1N0b3AoKTtcbiAgICBsZXQgdGltZSA9ICFpbnN0YW50ID8gb3B0aW9ucy5hdXRvIDogMDtcbiAgICBzZWxmLmF1dG9JbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghb3B0aW9ucy5hdXRvQWx3YXlzICYmIHNlbGYub2JqZWN0Lm9mZnNldFBhcmVudCA9PT0gbnVsbCkgeyAvLyBpZiBub3QgOnZpc2libGUgZG9uJ3QgY2hhbmdlXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHNlbGYuYXV0b0N1cnJlbnQgPSBzZWxmLmF1dG9DdXJyZW50ICE9PSB1bmRlZmluZWQgPyBzZWxmLmF1dG9DdXJyZW50ICsgMSA6IDA7XG4gICAgICBzZWxmLmF1dG9DdXJyZW50ID0gc2VsZi5hdXRvQ3VycmVudCA+PSBzZWxmLmVsZW1lbnRzLmxlbmd0aCA/IDAgOiBzZWxmLmF1dG9DdXJyZW50O1xuICAgICAgc2VsZi5ldmVudE9uKHNlbGYuZWxlbWVudHNbc2VsZi5hdXRvQ3VycmVudF0pO1xuICAgIH0sIHRpbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIHNldCBhdXRvUGF1c2UgY2hhbmdlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5zdGFudFxuICAgKi9cbiAgYXV0b1BhdXNlKGluc3RhbnQgPSBmYWxzZSkge1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBsZXQgb3B0aW9ucyA9IHNlbGYub3B0aW9ucztcbiAgICAvLyBhdXRvUGF1c2VcbiAgICB0aGlzLmF1dG9TdG9wKCk7XG4gICAgbGV0IHRpbWUgPSAhaW5zdGFudCA/IG9wdGlvbnMuYXV0b1BhdXNlIDogMDtcbiAgICBpZiAodGltZSAhPT0gJ3N0b3AnKSB7XG4gICAgICBzZWxmLmF1dG9QYXVzZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5hdXRvKHRydWUpO1xuICAgICAgICBzZWxmLmF1dG8oKTtcbiAgICAgIH0sIHRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBzdG9wIGF1dG8gY2hhbmdlXG4gICAqL1xuICBhdXRvU3RvcCgpIHtcbiAgICBjbGVhckludGVydmFsKHRoaXMuYXV0b0ludGVydmFsKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5hdXRvUGF1c2VUaW1lb3V0KTtcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gdXRpbHNcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIC8qKlxuICAgKiBjaG9vc2Ugd2hpY2ggZWxlbWVudHMgdG8gYWN0aXZhdGUvZGVhY3RpdmF0ZSAoYmFzZWQgb24geHRlbmQgbW9kZSBhbmQgY29udGFpbmVycylcbiAgICogQHBhcmFtIHtOb2RlfEhUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCB0cmlnZ2VyZWQgaW50ZXJhY3Rpb25cbiAgICogQHJldHVybnMge09iamVjdH0gb2JqZWN0LmFsbCBhbmQgb2JqZWN0LnNpbmdsZVxuICAgKi9cbiAgZ2V0RWxlbWVudHMoZWxlbWVudCkge1xuICAgIGlmICghdGhpcy5lbGVtZW50cyB8fCAhdGhpcy5lbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7YWxsOiBbXSwgc2luZ2xlOiBudWxsfTtcbiAgICB9XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ2FsbCcpIHtcbiAgICAgIC8vIGNob29zZSBhbGwgZWxlbWVudHNcbiAgICAgIHJldHVybiB7YWxsOiB0aGlzLmVsZW1lbnRzLCBzaW5nbGU6IHRoaXMuZWxlbWVudHNbMF19O1xuICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSAndW5pcXVlJykge1xuICAgICAgLy8gY2hvb3NlIGVsZW1lbnQgYnkgZ3JvdXBcbiAgICAgIGxldCBncm91cCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWdyb3VwJyk7XG4gICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgLy8gYWxsIGdyb3VwIGVsZW1lbnRzIGlmIGdyb3VwXG4gICAgICAgIGxldCBncm91cEVsZW1lbnRzID0gQXJyYXkuZnJvbSh0aGlzLmVsZW1lbnRzKS5maWx0ZXIoeCA9PiB4LmdldEF0dHJpYnV0ZSgnZGF0YS1ncm91cCcpID09PSBncm91cCk7XG4gICAgICAgIGxldCBmaW5hbCA9IFh0VXRpbC5hcnJTaW5nbGUoZ3JvdXBFbGVtZW50cyk7XG4gICAgICAgIHJldHVybiB7YWxsOiBmaW5hbCwgc2luZ2xlOiBmaW5hbFswXX07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlbGVtZW50IGlmIG5vdCBncm91cFxuICAgICAgICBsZXQgZmluYWwgPSBlbGVtZW50O1xuICAgICAgICByZXR1cm4ge2FsbDogWHRVdGlsLmFyclNpbmdsZShmaW5hbCksIHNpbmdsZTogZmluYWx9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBjaG9vc2Ugd2hpY2ggdGFyZ2V0cyB0byBhY3RpdmF0ZS9kZWFjdGl2YXRlIChiYXNlZCBvbiB4dGVuZCBtb2RlIGFuZCBjb250YWluZXJzKVxuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHRyaWdnZXJlZCBpbnRlcmFjdGlvblxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuICBnZXRUYXJnZXRzKGVsZW1lbnQpIHtcbiAgICBpZiAoIXRoaXMudGFyZ2V0cyB8fCAhdGhpcy50YXJnZXRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAodGhpcy5tb2RlID09PSAnYWxsJykge1xuICAgICAgLy8gY2hvb3NlIGFsbCB0YXJnZXRzXG4gICAgICByZXR1cm4gdGhpcy50YXJnZXRzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSAndW5pcXVlJykge1xuICAgICAgLy8gY2hvb3NlIG9ubHkgdGFyZ2V0IGJ5IGdyb3VwXG4gICAgICBsZXQgZ3JvdXAgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1ncm91cCcpO1xuICAgICAgbGV0IGdyb3VwRWxlbWVudHMgPSBBcnJheS5mcm9tKHRoaXMuZWxlbWVudHMpLmZpbHRlcih4ID0+IHguZ2V0QXR0cmlidXRlKCdkYXRhLWdyb3VwJykgPT09IGdyb3VwKTtcbiAgICAgIGxldCBncm91cFRhcmdldHMgPSBBcnJheS5mcm9tKHRoaXMudGFyZ2V0cykuZmlsdGVyKHggPT4geC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZ3JvdXAnKSA9PT0gZ3JvdXApO1xuICAgICAgbGV0IGZpbmFsO1xuICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgIC8vIGFsbCBncm91cCB0YXJnZXRzIGlmIGdyb3VwXG4gICAgICAgIGZpbmFsID0gZ3JvdXBUYXJnZXRzO1xuICAgICAgICByZXR1cm4gWHRVdGlsLmFyclNpbmdsZShmaW5hbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3QgZ3JvdXAgdGFyZ2V0cyBieSBpbmRleCBpZiBub3QgZ3JvdXBcbiAgICAgICAgbGV0IGluZGV4ID0gZ3JvdXBFbGVtZW50cy5maW5kSW5kZXgoeCA9PiB4ID09PSBlbGVtZW50KTtcbiAgICAgICAgZmluYWwgPSBncm91cFRhcmdldHNbaW5kZXhdO1xuICAgICAgICByZXR1cm4gWHRVdGlsLmFyclNpbmdsZShmaW5hbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGNob29zZSB3aGljaCBlbGVtZW50cyB0byBhY3RpdmF0ZS9kZWFjdGl2YXRlIGZyb20gdGFyZ2V0IChiYXNlZCBvbiB4dGVuZCBtb2RlIGFuZCBjb250YWluZXJzKVxuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGFyZ2V0IHRvIHRyaWdnZXIgaW50ZXJhY3Rpb24gb25cbiAgICogQHJldHVybnMge0FycmF5fVxuICAgKi9cbiAgZ2V0RWxlbWVudHNGcm9tVGFyZ2V0KHRhcmdldCkge1xuICAgIGlmICghdGhpcy5lbGVtZW50cyB8fCAhdGhpcy5lbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLy8gY2hvb3NlIG9ubHkgdGFyZ2V0IGJ5IGdyb3VwXG4gICAgbGV0IGdyb3VwID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1ncm91cCcpO1xuICAgIGxldCBncm91cEVsZW1lbnRzID0gQXJyYXkuZnJvbSh0aGlzLmVsZW1lbnRzKS5maWx0ZXIoeCA9PiB4LmdldEF0dHJpYnV0ZSgnZGF0YS1ncm91cCcpID09PSBncm91cCk7XG4gICAgbGV0IGdyb3VwVGFyZ2V0cyA9IEFycmF5LmZyb20odGhpcy50YXJnZXRzKS5maWx0ZXIoeCA9PiB4LmdldEF0dHJpYnV0ZSgnZGF0YS1ncm91cCcpID09PSBncm91cCk7XG4gICAgbGV0IGZpbmFsO1xuICAgIGlmIChncm91cCkge1xuICAgICAgLy8gYWxsIGdyb3VwIHRhcmdldHMgaWYgZ3JvdXBcbiAgICAgIGZpbmFsID0gZ3JvdXBFbGVtZW50cztcbiAgICAgIHJldHVybiBYdFV0aWwuYXJyU2luZ2xlKGZpbmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm90IGdyb3VwIHRhcmdldHMgYnkgaW5kZXggaWYgbm90IGdyb3VwXG4gICAgICBsZXQgaW5kZXggPSBncm91cFRhcmdldHMuZmluZEluZGV4KHggPT4geCA9PT0gdGFyZ2V0KTtcbiAgICAgIGZpbmFsID0gZ3JvdXBFbGVtZW50c1tpbmRleF07XG4gICAgICByZXR1cm4gWHRVdGlsLmFyclNpbmdsZShmaW5hbCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGFkZGl0aW9uYWwgZWxlbWVudHMgdG8gYWN0aXZhdGUvZGVhY3RpdmF0ZVxuICAgKiBAcmV0dXJucyB7Tm9kZUxpc3R8QXJyYXl9XG4gICAqL1xuICBnZXRBZGRpdGlvbmFsKCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLmFkZGl0aW9uYWwpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMub2JqZWN0LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5vcHRpb25zLmFkZGl0aW9uYWwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgY3VycmVudHMgYmFzZWQgb24gbmFtZXNwYWNlIChzbyBzaGFyZWQgYmV0d2VlbiBYdCBvYmplY3RzKVxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuICBnZXRDdXJyZW50cygpIHtcbiAgICByZXR1cm4gWHRVdGlsLmN1cnJlbnRzW3RoaXMubmFtZXNwYWNlXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZXQgY3VycmVudHMgYmFzZWQgb24gbmFtZXNwYWNlIChzbyBzaGFyZWQgYmV0d2VlbiBYdCBvYmplY3RzKVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICovXG4gIHNldEN1cnJlbnRzKGFycikge1xuICAgIFh0VXRpbC5jdXJyZW50c1t0aGlzLm5hbWVzcGFjZV0gPSBhcnI7XG4gIH1cblxuICAvKipcbiAgICogYWRkIGN1cnJlbnQgYmFzZWQgb24gbmFtZXNwYWNlIChzbyBzaGFyZWQgYmV0d2VlbiBYdCBvYmplY3RzKVxuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IGVsZW1lbnQgVG8gYmUgYWRkZWRcbiAgICovXG4gIGFkZEN1cnJlbnQoZWxlbWVudCkge1xuICAgIGxldCBhcnIgPSBYdFV0aWwuY3VycmVudHNbdGhpcy5uYW1lc3BhY2VdO1xuICAgIGFyci5wdXNoKGVsZW1lbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlbW92ZSBjdXJyZW50cyBiYXNlZCBvbiBuYW1lc3BhY2UgKHNvIHNoYXJlZCBiZXR3ZWVuIFh0IG9iamVjdHMpXG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gZWxlbWVudCBUbyBiZSByZW1vdmVkXG4gICAqL1xuICByZW1vdmVDdXJyZW50KGVsZW1lbnQpIHtcbiAgICBYdFV0aWwuY3VycmVudHNbdGhpcy5uYW1lc3BhY2VdID0gWHRVdGlsLmN1cnJlbnRzW3RoaXMubmFtZXNwYWNlXS5maWx0ZXIoeCA9PiB4ICE9PSBlbGVtZW50KTtcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gZXZlbnRzXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAvKipcbiAgICogY2hlY2sgZWxlbWVudCBvblxuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IGVsZW1lbnQgVG8gYmUgYWN0aXZhdGVkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiBldmVudE9uIGNoYW5nZXMgYWN0aXZhdGlvblxuICAgKi9cbiAgY2hlY2tPbihlbGVtZW50KSB7XG4gICAgaWYgKCghZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoLi4udGhpcy5vcHRpb25zLmNsYXNzZXMpIHx8IGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdvZmYtYmxvY2snKSkgJiYgIWVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdvbi1ibG9jaycpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBjaGVjayBlbGVtZW50IG9mZlxuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IGVsZW1lbnQgVG8gYmUgYWN0aXZhdGVkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiBldmVudE9mZiBjaGFuZ2VzIGFjdGl2YXRpb25cbiAgICovXG4gIGNoZWNrT2ZmKGVsZW1lbnQpIHtcbiAgICAvLyBpZiBjdXJyZW50cyA8IG1pblxuICAgIGxldCB0b2RvID0gdGhpcy5vcHRpb25zLm1pbiAtIHRoaXMuZ2V0Q3VycmVudHMoKS5sZW5ndGg7XG4gICAgaWYgKCF0b2RvKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoLi4udGhpcy5vcHRpb25zLmNsYXNzZXMpIHx8IGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdvbi1ibG9jaycpKSAmJiAhZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ29mZi1ibG9jaycpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBlbGVtZW50IG9uXG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gZWxlbWVudCBUbyBiZSBhY3RpdmF0ZWRcbiAgICovXG4gIGV2ZW50T24oZWxlbWVudCkge1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBsZXQgb3B0aW9ucyA9IHNlbGYub3B0aW9ucztcbiAgICAvLyBhY3RpdmF0ZSBvciBkZWFjdGl2YXRlXG4gICAgaWYgKHRoaXMuY2hlY2tPbihlbGVtZW50KSkge1xuICAgICAgbGV0IGZFbGVtZW50cyA9IHRoaXMuZ2V0RWxlbWVudHMoZWxlbWVudCk7XG4gICAgICB0aGlzLmFkZEN1cnJlbnQoZkVsZW1lbnRzLnNpbmdsZSk7XG4gICAgICBsZXQgdGFyZ2V0cyA9IHRoaXMuZ2V0VGFyZ2V0cyhlbGVtZW50KTtcbiAgICAgIGxldCBhZGRpdGlvbmFsID0gdGhpcy5nZXRBZGRpdGlvbmFsKCk7XG4gICAgICBsZXQgYWN0aXZhdGlvbkRlbGF5ID0ge1xuICAgICAgICBlbGVtZW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYuYWN0aXZhdGlvbk9uKGZFbGVtZW50cy5hbGwsIGZFbGVtZW50cywgJ2VsZW1lbnRzJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHRhcmdldHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZWxmLmFjdGl2YXRpb25Pbih0YXJnZXRzLCBmRWxlbWVudHMsICd0YXJnZXRzJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZGl0aW9uYWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZWxmLmFjdGl2YXRpb25PbihhZGRpdGlvbmFsLCBmRWxlbWVudHMsICdhZGRpdGlvbmFsJyk7XG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgICAgLy8gc2V0IGF1dG9DdXJyZW50XG4gICAgICBpZiAob3B0aW9ucy5hdXRvKSB7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGZvciAobGV0IFtpLCBlbF0gb2Ygc2VsZi5lbGVtZW50cy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICBpZiAoZWwgPT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZWxmLmF1dG9DdXJyZW50ID0gaW5kZXg7XG4gICAgICB9XG4gICAgICAvLyBpZiBjdXJyZW50cyA+IG1heFxuICAgICAgbGV0IGN1cnJlbnRzID0gdGhpcy5nZXRDdXJyZW50cygpO1xuICAgICAgaWYgKGN1cnJlbnRzLmxlbmd0aCA+IG9wdGlvbnMubWF4KSB7XG4gICAgICAgIHRoaXMuZXZlbnRPZmYoY3VycmVudHNbMF0sIGFjdGl2YXRpb25EZWxheSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmF0aW9uRGVsYXkuZWxlbWVudHMoKTtcbiAgICAgICAgYWN0aXZhdGlvbkRlbGF5LnRhcmdldHMoKTtcbiAgICAgICAgYWN0aXZhdGlvbkRlbGF5LmFkZGl0aW9uYWwoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMudG9nZ2xlKSB7XG4gICAgICAvLyB0b2dnbGVcbiAgICAgIHRoaXMuZXZlbnRPZmYoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGVsZW1lbnQgb2ZmXG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gZWxlbWVudCBUbyBiZSBkZWFjdGl2YXRlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gYWN0aXZhdGlvbkRlbGF5IE9iamVjdCB3aXRoIGRlbGF5ZWQgYWN0aXZhdGlvbnNcbiAgICovXG4gIGV2ZW50T2ZmKGVsZW1lbnQsIGFjdGl2YXRpb25EZWxheSA9IG51bGwpIHtcbiAgICAvLyBkZWFjdGl2YXRlXG4gICAgaWYgKHRoaXMuY2hlY2tPZmYoZWxlbWVudCkpIHtcbiAgICAgIGxldCBmRWxlbWVudHMgPSB0aGlzLmdldEVsZW1lbnRzKGVsZW1lbnQpO1xuICAgICAgdGhpcy5yZW1vdmVDdXJyZW50KGZFbGVtZW50cy5zaW5nbGUpO1xuICAgICAgdGhpcy5hY3RpdmF0aW9uT2ZmKGZFbGVtZW50cy5hbGwsIGZFbGVtZW50cywgJ2VsZW1lbnRzJywgYWN0aXZhdGlvbkRlbGF5KTtcbiAgICAgIGxldCB0YXJnZXRzID0gdGhpcy5nZXRUYXJnZXRzKGVsZW1lbnQpO1xuICAgICAgdGhpcy5hY3RpdmF0aW9uT2ZmKHRhcmdldHMsIGZFbGVtZW50cywgJ3RhcmdldHMnLCBhY3RpdmF0aW9uRGVsYXkpO1xuICAgICAgbGV0IGFkZGl0aW9uYWwgPSB0aGlzLmdldEFkZGl0aW9uYWwoKTtcbiAgICAgIHRoaXMuYWN0aXZhdGlvbk9mZihhZGRpdGlvbmFsLCBmRWxlbWVudHMsICdhZGRpdGlvbmFsJywgYWN0aXZhdGlvbkRlbGF5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZWxlbWVudCBvbiBhY3RpdmF0aW9uXG4gICAqIEBwYXJhbSB7Tm9kZUxpc3R8QXJyYXl9IGVscyBFbGVtZW50cyB0byBiZSBhY3RpdmF0ZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IGZFbGVtZW50cyBBZGRpdGlvbmFsIGVsZW1lbnRzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFR5cGUgb2YgZWxlbWVudHNcbiAgICovXG4gIGFjdGl2YXRpb25PbihlbHMsIGZFbGVtZW50cywgdHlwZSkge1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBsZXQgb3B0aW9ucyA9IHNlbGYub3B0aW9ucztcbiAgICAvLyBhY3RpdmF0ZVxuICAgIGxldCBhY3RpdmF0ZSA9IGZ1bmN0aW9uIChzZWxmLCBlbCwgZkVsZW1lbnRzLCB0eXBlKSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKC4uLm9wdGlvbnMuY2xhc3Nlcyk7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdvdXQnKTtcbiAgICAgIHNlbGYuYWN0aXZhdGlvbk9uQW5pbWF0ZShlbCwgdHlwZSk7XG4gICAgICAvLyBzcGVjaWFsc1xuICAgICAgaWYgKHR5cGUgPT09ICd0YXJnZXRzJykge1xuICAgICAgICBzZWxmLnNwZWNpYWxDbGFzc0h0bWxPbigpO1xuICAgICAgICBzZWxmLnNwZWNpYWxCYWNrZHJvcChlbCk7XG4gICAgICAgIHNlbGYuc3BlY2lhbENlbnRlck9uKGVsKTtcbiAgICAgICAgc2VsZi5zcGVjaWFsTWlkZGxlT24oZWwpO1xuICAgICAgICBzZWxmLnNwZWNpYWxDb2xsYXBzZU9uKGVsKTtcbiAgICAgICAgc2VsZi5zcGVjaWFsQ2xvc2VPbihlbCwgZkVsZW1lbnRzLnNpbmdsZSk7XG4gICAgICAgIHNlbGYuc3BlY2lhbFNjcm9sbGJhck9uKCk7XG4gICAgICB9XG4gICAgICAvLyBkaXNwYXRjaFxuICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ29uJykpO1xuICAgIH07XG4gICAgLy8gZGVsYXlcbiAgICBmb3IgKGxldCBlbCBvZiBlbHMpIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ29mZi1ibG9jaycpO1xuICAgICAgY2xlYXJUaW1lb3V0KGVsLmRhdGFzZXQueHREZWxheVRpbWVvdXQpO1xuICAgICAgY2xlYXJUaW1lb3V0KGVsLmRhdGFzZXQueHRBbmltVGltZW91dCk7XG4gICAgICBsZXQgZGVsYXkgPSBlbC5kYXRhc2V0Lnh0T25EZWxheTtcbiAgICAgIGlmIChkZWxheSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdvbi1ibG9jaycpO1xuICAgICAgICBlbC5kYXRhc2V0Lnh0RGVsYXlUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoc2VsZiwgZWwsIGZFbGVtZW50cywgdHlwZSkge1xuICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ29uLWJsb2NrJyk7XG4gICAgICAgICAgYWN0aXZhdGUoc2VsZiwgZWwsIGZFbGVtZW50cywgdHlwZSk7XG4gICAgICAgIH0sIHBhcnNlRmxvYXQoZGVsYXkpLCBzZWxmLCBlbCwgZkVsZW1lbnRzLCB0eXBlKS50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZhdGUoc2VsZiwgZWwsIGZFbGVtZW50cywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGVsZW1lbnQgb2ZmIGFjdGl2YXRpb25cbiAgICogQHBhcmFtIHtOb2RlTGlzdHxBcnJheX0gZWxzIEVsZW1lbnRzIHRvIGJlIGRlYWN0aXZhdGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmRWxlbWVudHMgQWRkaXRpb25hbCBlbGVtZW50c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIG9mIGVsZW1lbnRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY3RpdmF0aW9uRGVsYXkgT2JqZWN0IHdpdGggZGVsYXllZCBhY3RpdmF0aW9uc1xuICAgKi9cbiAgYWN0aXZhdGlvbk9mZihlbHMsIGZFbGVtZW50cywgdHlwZSwgYWN0aXZhdGlvbkRlbGF5KSB7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBvcHRpb25zID0gc2VsZi5vcHRpb25zO1xuICAgIC8vIGRlYWN0aXZhdGVcbiAgICBsZXQgZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIChzZWxmLCBlbCwgZkVsZW1lbnRzLCB0eXBlLCBhY3RpdmF0aW9uRGVsYXkpIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoLi4ub3B0aW9ucy5jbGFzc2VzKTtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ291dCcpO1xuICAgICAgc2VsZi5hY3RpdmF0aW9uT2ZmQW5pbWF0ZShlbCwgdHlwZSwgYWN0aXZhdGlvbkRlbGF5KTtcbiAgICAgIC8vIGFjdGl2YXRpb25EZWxheVxuICAgICAgaWYgKGFjdGl2YXRpb25EZWxheSAmJiBhY3RpdmF0aW9uRGVsYXlbdHlwZV0gJiYgIWFjdGl2YXRpb25EZWxheVt0eXBlICsgJ2RvbmUnXSkge1xuICAgICAgICBpZiAob3B0aW9ucy5pbnN0YW50ICYmIG9wdGlvbnMuaW5zdGFudFt0eXBlXSkge1xuICAgICAgICAgIGFjdGl2YXRpb25EZWxheVt0eXBlXSgpO1xuICAgICAgICAgIGFjdGl2YXRpb25EZWxheVt0eXBlICsgJ2RvbmUnXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHNwZWNpYWxzXG4gICAgICBpZiAodHlwZSA9PT0gJ3RhcmdldHMnKSB7XG4gICAgICAgIHNlbGYuc3BlY2lhbENsYXNzSHRtbE9mZigpO1xuICAgICAgICBzZWxmLnNwZWNpYWxDb2xsYXBzZU9mZihlbCk7XG4gICAgICAgIHNlbGYuc3BlY2lhbENsb3NlT2ZmKGVsKTtcbiAgICAgIH1cbiAgICAgIC8vIGRpc3BhdGNoXG4gICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnb2ZmJykpO1xuICAgIH07XG4gICAgLy8gZGVsYXlcbiAgICBmb3IgKGxldCBlbCBvZiBlbHMpIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ29uLWJsb2NrJyk7XG4gICAgICBjbGVhclRpbWVvdXQoZWwuZGF0YXNldC54dERlbGF5VGltZW91dCk7XG4gICAgICBjbGVhclRpbWVvdXQoZWwuZGF0YXNldC54dEFuaW1UaW1lb3V0KTtcbiAgICAgIGxldCBkZWxheSA9IGVsLmRhdGFzZXQueHRPZmZEZWxheTtcbiAgICAgIGlmIChkZWxheSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdvZmYtYmxvY2snKTtcbiAgICAgICAgZWwuZGF0YXNldC54dERlbGF5VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKHNlbGYsIGVsLCBmRWxlbWVudHMsIHR5cGUsIGFjdGl2YXRpb25EZWxheSkge1xuICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ29mZi1ibG9jaycpO1xuICAgICAgICAgIGRlYWN0aXZhdGUoc2VsZiwgZWwsIGZFbGVtZW50cywgdHlwZSwgYWN0aXZhdGlvbkRlbGF5KTtcbiAgICAgICAgfSwgcGFyc2VGbG9hdChkZWxheSksIHNlbGYsIGVsLCBmRWxlbWVudHMsIHR5cGUsIGFjdGl2YXRpb25EZWxheSkudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYWN0aXZhdGUoc2VsZiwgZWwsIGZFbGVtZW50cywgdHlwZSwgYWN0aXZhdGlvbkRlbGF5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZWxlbWVudCBvbiBhbmltYXRpb25cbiAgICogQHBhcmFtIHtOb2RlfEhUTUxFbGVtZW50fSBlbCBFbGVtZW50IHRvIGJlIGFuaW1hdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFR5cGUgb2YgZWxlbWVudFxuICAgKi9cbiAgYWN0aXZhdGlvbk9uQW5pbWF0ZShlbCwgdHlwZSkge1xuICAgIC8vIG9uRG9uZVxuICAgIGxldCBvbkRvbmUgPSBmdW5jdGlvbiAoZWwsIHR5cGUpIHtcbiAgICAgIC8vIGNvbGxhcHNlLXdpZHRoIGFuZCBjb2xsYXBzZS1oZWlnaHRcbiAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2NvbGxhcHNlLWhlaWdodCcpKSB7XG4gICAgICAgIGVsLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICAgIH1cbiAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2NvbGxhcHNlLXdpZHRoJykpIHtcbiAgICAgICAgZWwuc3R5bGUud2lkdGggPSAnYXV0byc7XG4gICAgICB9XG4gICAgfTtcbiAgICAvLyBkZWxheSBvbkRvbmVcbiAgICBsZXQgdGltaW5nID0gdGhpcy5hY3RpdmF0aW9uVGltaW5nKGVsKTtcbiAgICBjbGVhclRpbWVvdXQoZWwuZGF0YXNldC54dEFuaW1UaW1lb3V0KTtcbiAgICBpZiAoIXRpbWluZykge1xuICAgICAgb25Eb25lKGVsLCB0eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuZGF0YXNldC54dEFuaW1UaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoZWwsIHR5cGUpIHtcbiAgICAgICAgb25Eb25lKGVsLCB0eXBlKTtcbiAgICAgIH0sIHRpbWluZywgZWwsIHR5cGUpLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGVsZW1lbnQgb2ZmIGFuaW1hdGlvblxuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IGVsIEVsZW1lbnQgdG8gYmUgYW5pbWF0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSBvZiBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY3RpdmF0aW9uRGVsYXkgT2JqZWN0IHdpdGggZGVsYXllZCBhY3RpdmF0aW9uc1xuICAgKi9cbiAgYWN0aXZhdGlvbk9mZkFuaW1hdGUoZWwsIHR5cGUsIGFjdGl2YXRpb25EZWxheSkge1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBsZXQgb3B0aW9ucyA9IHNlbGYub3B0aW9ucztcbiAgICAvLyBvbkRvbmVcbiAgICBsZXQgb25Eb25lID0gZnVuY3Rpb24gKGVsLCB0eXBlKSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdvdXQnKTtcbiAgICAgIC8vIHNwZWNpYWxzXG4gICAgICBpZiAodHlwZSA9PT0gJ3RhcmdldHMnKSB7XG4gICAgICAgIHNlbGYuc3BlY2lhbFNjcm9sbGJhck9mZigpO1xuICAgICAgfVxuICAgICAgLy8gYWN0aXZhdGlvbkRlbGF5XG4gICAgICBpZiAoYWN0aXZhdGlvbkRlbGF5ICYmIGFjdGl2YXRpb25EZWxheVt0eXBlXSAmJiAhYWN0aXZhdGlvbkRlbGF5W3R5cGUgKyAnZG9uZSddKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5pbnN0YW50IHx8ICFvcHRpb25zLmluc3RhbnRbdHlwZV0pIHtcbiAgICAgICAgICBhY3RpdmF0aW9uRGVsYXlbdHlwZV0oKTtcbiAgICAgICAgICBhY3RpdmF0aW9uRGVsYXlbdHlwZSArICdkb25lJ10gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICAvLyBkZWxheSBvbkRvbmVcbiAgICBsZXQgdGltaW5nID0gdGhpcy5hY3RpdmF0aW9uVGltaW5nKGVsKTtcbiAgICBjbGVhclRpbWVvdXQoZWwuZGF0YXNldC54dEFuaW1UaW1lb3V0KTtcbiAgICBpZiAoIXRpbWluZykge1xuICAgICAgb25Eb25lKGVsLCB0eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuZGF0YXNldC54dEFuaW1UaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoZWwsIHR5cGUpIHtcbiAgICAgICAgb25Eb25lKGVsLCB0eXBlKTtcbiAgICAgIH0sIHRpbWluZywgZWwsIHR5cGUpLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0cmFuc2l0aW9uIG9yIGFuaW1hdGlvbiB0aW1pbmdcbiAgICogQHBhcmFtIHtOb2RlfEhUTUxFbGVtZW50fSBlbCBUbyBiZSBhbmltYXRlZFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaW1lIGluIG1pbGxpc2Vjb25kc1xuICAgKi9cbiAgYWN0aXZhdGlvblRpbWluZyhlbCkge1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBsZXQgb3B0aW9ucyA9IHNlbGYub3B0aW9ucztcbiAgICAvLyB0aW1pbmdcbiAgICBsZXQgdGltaW5nID0gb3B0aW9ucy50aW1pbmc7XG4gICAgaWYgKHRpbWluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGltaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAgIGxldCB0cmFuc2l0aW9uID0gcGFyc2VGbG9hdChzdHlsZS50cmFuc2l0aW9uRHVyYXRpb24pICsgcGFyc2VGbG9hdChzdHlsZS50cmFuc2l0aW9uRGVsYXkpO1xuICAgICAgbGV0IGFuaW1hdGlvbiA9IHBhcnNlRmxvYXQoc3R5bGUuYW5pbWF0aW9uRHVyYXRpb24pICsgcGFyc2VGbG9hdChzdHlsZS5hbmltYXRpb25EZWxheSk7XG4gICAgICBpZiAodHJhbnNpdGlvbiB8fCBhbmltYXRpb24pIHtcbiAgICAgICAgdGltaW5nID0gTWF0aC5tYXgodHJhbnNpdGlvbiwgYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aW1pbmcgKiAxMDAwO1xuICAgIH1cbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gYWN0aXZhdGlvbiBzcGVjaWFsc1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgLyoqXG4gICAqIGFkZCBodG1sIGNsYXNzXG4gICAqL1xuICBzcGVjaWFsQ2xhc3NIdG1sT24oKSB7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBvcHRpb25zID0gc2VsZi5vcHRpb25zO1xuICAgIC8vXG4gICAgaWYgKG9wdGlvbnMuY2xhc3NIdG1sKSB7XG4gICAgICBsZXQgY29udGFpbmVyID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoLi4ub3B0aW9ucy5jbGFzc0h0bWwuc3BsaXQoJyAnKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHJlbW92ZSBodG1sIGNsYXNzXG4gICAqL1xuICBzcGVjaWFsQ2xhc3NIdG1sT2ZmKCkge1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBsZXQgb3B0aW9ucyA9IHNlbGYub3B0aW9ucztcbiAgICAvL1xuICAgIGlmIChvcHRpb25zLmNsYXNzSHRtbCkge1xuICAgICAgbGV0IGNvbnRhaW5lciA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKC4uLm9wdGlvbnMuY2xhc3NIdG1sLnNwbGl0KCcgJykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBiYWNrZHJvcCBhcHBlbmQgdG8gZWxlbWVudFxuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IGVsIEVsZW1lbnRcbiAgICovXG4gIHNwZWNpYWxCYWNrZHJvcChlbCkge1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBsZXQgb3B0aW9ucyA9IHNlbGYub3B0aW9ucztcbiAgICAvL1xuICAgIGlmIChvcHRpb25zLmJhY2tkcm9wKSB7XG4gICAgICBsZXQgZWxlbWVudHM7XG4gICAgICBpZiAob3B0aW9ucy5iYWNrZHJvcCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZWxlbWVudHMgPSBYdFV0aWwuYXJyU2luZ2xlKHRoaXMub2JqZWN0KTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5iYWNrZHJvcCA9PT0gJ3RhcmdldHMnKSB7XG4gICAgICAgIGVsZW1lbnRzID0gWHRVdGlsLmFyclNpbmdsZShlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50cyA9IGVsLnF1ZXJ5U2VsZWN0b3JBbGwob3B0aW9ucy5iYWNrZHJvcCk7XG4gICAgICAgIGlmICghZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgZWxlbWVudHMgPSB0aGlzLm9iamVjdC5xdWVyeVNlbGVjdG9yQWxsKG9wdGlvbnMuYmFja2Ryb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGxldCBiYWNrZHJvcCA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnh0LWJhY2tkcm9wJyk7XG4gICAgICAgIGlmICghYmFja2Ryb3AubGVuZ3RoKSB7XG4gICAgICAgICAgYmFja2Ryb3AgPSBYdFV0aWwuY3JlYXRlRWxlbWVudCgnPGRpdiBjbGFzcz1cInh0LWJhY2tkcm9wXCI+PC9kaXY+Jyk7XG4gICAgICAgICAgZWxlbWVudC5hcHBlbmQoYmFja2Ryb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGNlbnRlciBwb3NpdGlvbiBvbiBhY3RpdmF0aW9uXG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gZWwgRWxlbWVudFxuICAgKi9cbiAgc3BlY2lhbENlbnRlck9uKGVsKSB7XG4gICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnZHJvcC1jZW50ZXInKSkge1xuICAgICAgbGV0IGFkZCA9IHRoaXMub2JqZWN0LmNsaWVudFdpZHRoO1xuICAgICAgbGV0IHJlbW92ZSA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgZWwuc3R5bGUubGVmdCA9ICgoYWRkIC0gcmVtb3ZlKSAvIDIpICsgJ3B4JztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogbWlkZGxlIHBvc2l0aW9uIG9uIGFjdGl2YXRpb25cbiAgICogQHBhcmFtIHtOb2RlfEhUTUxFbGVtZW50fSBlbCBFbGVtZW50XG4gICAqL1xuICBzcGVjaWFsTWlkZGxlT24oZWwpIHtcbiAgICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdkcm9wLW1pZGRsZScpKSB7XG4gICAgICBsZXQgYWRkID0gdGhpcy5vYmplY3QuY2xpZW50SGVpZ2h0O1xuICAgICAgbGV0IHJlbW92ZSA9IGVsLmNsaWVudEhlaWdodDtcbiAgICAgIGVsLnN0eWxlLnRvcCA9ICgoYWRkIC0gcmVtb3ZlKSAvIDIpICsgJ3B4JztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogb3BlbiBjb2xsYXBzZSBvbiBhY3RpdmF0aW9uXG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gZWwgRWxlbWVudFxuICAgKi9cbiAgc3BlY2lhbENvbGxhcHNlT24oZWwpIHtcbiAgICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdjb2xsYXBzZS1oZWlnaHQnKSkge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnbm8tdHJhbnNpdGlvbicpO1xuICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgZWwuc3R5bGUucGFkZGluZ1RvcCA9ICcnO1xuICAgICAgZWwuc3R5bGUucGFkZGluZ0JvdHRvbSA9ICcnO1xuICAgICAgbGV0IGggPSBlbC5jbGllbnRIZWlnaHQgKyAncHgnO1xuICAgICAgbGV0IHB0ID0gZWwuc3R5bGUucGFkZGluZ1RvcDtcbiAgICAgIGxldCBwYiA9IGVsLnN0eWxlLnBhZGRpbmdCb3R0b207XG4gICAgICBYdFV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmNhbGwod2luZG93LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLnN0eWxlLmhlaWdodCA9ICcwJztcbiAgICAgICAgZWwuc3R5bGUucGFkZGluZ1RvcCA9ICcwJztcbiAgICAgICAgZWwuc3R5bGUucGFkZGluZ0JvdHRvbSA9ICcwJztcbiAgICAgICAgWHRVdGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZS5jYWxsKHdpbmRvdywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ25vLXRyYW5zaXRpb24nKTtcbiAgICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSBoO1xuICAgICAgICAgIGVsLnN0eWxlLnBhZGRpbmdUb3AgPSBwdDtcbiAgICAgICAgICBlbC5zdHlsZS5wYWRkaW5nQm90dG9tID0gcGI7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2NvbGxhcHNlLXdpZHRoJykpIHtcbiAgICAgIGVsLnN0eWxlLndpZHRoID0gJ2F1dG8nO1xuICAgICAgZWwuc3R5bGUucGFkZGluZ0xlZnQgPSAnJztcbiAgICAgIGVsLnN0eWxlLnBhZGRpbmdSaWdodCA9ICcnO1xuICAgICAgbGV0IHcgPSBlbC5jbGllbnRIZWlnaHQgKyAncHgnO1xuICAgICAgbGV0IHBsID0gZWwuc3R5bGUucGFkZGluZ0xlZnQ7XG4gICAgICBsZXQgcHIgPSBlbC5zdHlsZS5wYWRkaW5nUmlnaHQ7XG4gICAgICBYdFV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmNhbGwod2luZG93LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLnN0eWxlLndpZHRoID0gJzAnO1xuICAgICAgICBlbC5zdHlsZS5wYWRkaW5nTGVmdCA9ICcwJztcbiAgICAgICAgZWwuc3R5bGUucGFkZGluZ1JpZ2h0ID0gJzAnO1xuICAgICAgICBYdFV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmNhbGwod2luZG93LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnbm8tdHJhbnNpdGlvbicpO1xuICAgICAgICAgIGVsLnN0eWxlLndpZHRoID0gdztcbiAgICAgICAgICBlbC5zdHlsZS5wYWRkaW5nTGVmdCA9IHBsO1xuICAgICAgICAgIGVsLnN0eWxlLnBhZGRpbmdSaWdodCA9IHByO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBjbG9zZSBjb2xsYXBzZSBvbiBkZWFjdGl2YXRpb25cbiAgICogQHBhcmFtIHtOb2RlfEhUTUxFbGVtZW50fSBlbCBFbGVtZW50XG4gICAqL1xuICBzcGVjaWFsQ29sbGFwc2VPZmYoZWwpIHtcbiAgICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdjb2xsYXBzZS1oZWlnaHQnKSkge1xuICAgICAgbGV0IGggPSBlbC5jbGllbnRIZWlnaHQgKyAncHgnO1xuICAgICAgbGV0IHB0ID0gZWwuc3R5bGUucGFkZGluZ1RvcDtcbiAgICAgIGxldCBwYiA9IGVsLnN0eWxlLnBhZGRpbmdCb3R0b207XG4gICAgICBYdFV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmNhbGwod2luZG93LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IGg7XG4gICAgICAgIGVsLnN0eWxlLnBhZGRpbmdUb3AgPSBwdDtcbiAgICAgICAgZWwuc3R5bGUucGFkZGluZ0JvdHRvbSA9IHBiO1xuICAgICAgICBYdFV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmNhbGwod2luZG93LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gJzAnO1xuICAgICAgICAgIGVsLnN0eWxlLnBhZGRpbmdUb3AgPSAnMCc7XG4gICAgICAgICAgZWwuc3R5bGUucGFkZGluZ0JvdHRvbSA9ICcwJztcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnY29sbGFwc2Utd2lkdGgnKSkge1xuICAgICAgbGV0IHcgPSBlbC5jbGllbnRXaWR0aCArICdweCc7XG4gICAgICBsZXQgcGwgPSBlbC5zdHlsZS5wYWRkaW5nTGVmdDtcbiAgICAgIGxldCBwciA9IGVsLnN0eWxlLnBhZGRpbmdSaWdodDtcbiAgICAgIFh0VXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuY2FsbCh3aW5kb3csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc3R5bGUud2lkdGggPSB3O1xuICAgICAgICBlbC5zdHlsZS5wYWRkaW5nTGVmdCA9IHBsO1xuICAgICAgICBlbC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBwcjtcbiAgICAgICAgWHRVdGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZS5jYWxsKHdpbmRvdywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLndpZHRoID0gJzAnO1xuICAgICAgICAgIGVsLnN0eWxlLnBhZGRpbmdMZWZ0ID0gJzAnO1xuICAgICAgICAgIGVsLnN0eWxlLnBhZGRpbmdSaWdodCA9ICcwJztcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogYWRkIGNsb3NlIGV2ZW50cyBvbiBlbGVtZW50XG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gZWwgRWxlbWVudFxuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IHNpbmdsZSBFbGVtZW50IHRvIHRvZ2dsZVxuICAgKi9cbiAgc3BlY2lhbENsb3NlT24oZWwsIHNpbmdsZSkge1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBsZXQgb3B0aW9ucyA9IHNlbGYub3B0aW9ucztcbiAgICAvLyBjbG9zZUluc2lkZVxuICAgIGlmIChvcHRpb25zLmNsb3NlSW5zaWRlKSB7XG4gICAgICBsZXQgY2xvc2VFbGVtZW50cyA9IGVsLnF1ZXJ5U2VsZWN0b3JBbGwob3B0aW9ucy5jbG9zZUluc2lkZSk7XG4gICAgICBYdFV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmNhbGwod2luZG93LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAobGV0IGNsb3NlRWxlbWVudCBvZiBjbG9zZUVsZW1lbnRzKSB7XG4gICAgICAgICAgLy8gaGFuZGxlclxuICAgICAgICAgIGxldCBzcGVjaWFsQ2xvc2VPbkhhbmRsZXIgPSBYdFV0aWwuZGF0YVN0b3JhZ2UucHV0KGVsLCAnc3BlY2lhbENsb3NlT25IYW5kbGVyJywgc2VsZi5zcGVjaWFsQ2xvc2VPbkhhbmRsZXIuYmluZChzZWxmKS5iaW5kKHNlbGYsIGNsb3NlRWxlbWVudCwgc2luZ2xlKSk7XG4gICAgICAgICAgLy8gZXZlbnRcbiAgICAgICAgICBjbG9zZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzcGVjaWFsQ2xvc2VPbkhhbmRsZXIpO1xuICAgICAgICAgIGNsb3NlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHNwZWNpYWxDbG9zZU9uSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBjbG9zZU91dHNpZGVcbiAgICBpZiAob3B0aW9ucy5jbG9zZU91dHNpZGUpIHtcbiAgICAgIGxldCBjbG9zZUVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChvcHRpb25zLmNsb3NlT3V0c2lkZSk7XG4gICAgICBYdFV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmNhbGwod2luZG93LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAobGV0IGNsb3NlRWxlbWVudCBvZiBjbG9zZUVsZW1lbnRzKSB7XG4gICAgICAgICAgLy8gaGFuZGxlclxuICAgICAgICAgIGxldCBzcGVjaWFsQ2xvc2VPZmZIYW5kbGVyID0gWHRVdGlsLmRhdGFTdG9yYWdlLnB1dChlbCwgJ3NwZWNpYWxDbG9zZU9mZkhhbmRsZXInLCBzZWxmLnNwZWNpYWxDbG9zZU9mZkhhbmRsZXIuYmluZChzZWxmKS5iaW5kKHNlbGYsIGVsLCBzaW5nbGUpKTtcbiAgICAgICAgICAvLyBldmVudFxuICAgICAgICAgIGNsb3NlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHNwZWNpYWxDbG9zZU9mZkhhbmRsZXIpO1xuICAgICAgICAgIGNsb3NlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHNwZWNpYWxDbG9zZU9mZkhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogcmVtb3ZlIGNsb3NlIGV2ZW50cyBvbiBlbGVtZW50XG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gZWwgRWxlbWVudFxuICAgKi9cbiAgc3BlY2lhbENsb3NlT2ZmKGVsKSB7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBvcHRpb25zID0gc2VsZi5vcHRpb25zO1xuICAgIC8vIGNsb3NlSW5zaWRlXG4gICAgaWYgKG9wdGlvbnMuY2xvc2VJbnNpZGUpIHtcbiAgICAgIGxldCBjbG9zZUVsZW1lbnRzID0gZWwucXVlcnlTZWxlY3RvckFsbChvcHRpb25zLmNsb3NlSW5zaWRlKTtcbiAgICAgIGZvciAobGV0IGNsb3NlRWxlbWVudCBvZiBjbG9zZUVsZW1lbnRzKSB7XG4gICAgICAgIC8vIGhhbmRsZXJcbiAgICAgICAgbGV0IHNwZWNpYWxDbG9zZU9uSGFuZGxlciA9IFh0VXRpbC5kYXRhU3RvcmFnZS5nZXQoZWwsICdzcGVjaWFsQ2xvc2VPbkhhbmRsZXInKTtcbiAgICAgICAgY2xvc2VFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc3BlY2lhbENsb3NlT25IYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gY2xvc2VPdXRzaWRlXG4gICAgaWYgKG9wdGlvbnMuY2xvc2VPdXRzaWRlKSB7XG4gICAgICBsZXQgY2xvc2VFbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwob3B0aW9ucy5jbG9zZU91dHNpZGUpO1xuICAgICAgZm9yIChsZXQgY2xvc2VFbGVtZW50IG9mIGNsb3NlRWxlbWVudHMpIHtcbiAgICAgICAgbGV0IHNwZWNpYWxDbG9zZU9mZkhhbmRsZXIgPSBYdFV0aWwuZGF0YVN0b3JhZ2UuZ2V0KGVsLCAnc3BlY2lhbENsb3NlT2ZmSGFuZGxlcicpO1xuICAgICAgICBjbG9zZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzcGVjaWFsQ2xvc2VPZmZIYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZWxlbWVudCBvbiBoYW5kbGVyXG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gY2hlY2tFbFxuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IHNpbmdsZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqL1xuICBzcGVjaWFsQ2xvc2VPbkhhbmRsZXIoY2hlY2tFbCwgc2luZ2xlLCBlKSB7XG4gICAgaWYgKFh0VXRpbC5jaGVja0luc2lkZShlLCBYdFV0aWwuYXJyU2luZ2xlKGNoZWNrRWwpKSkge1xuICAgICAgdGhpcy5ldmVudE9mZihzaW5nbGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBlbGVtZW50IG9mZiBoYW5kbGVyXG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gY2hlY2tFbFxuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IHNpbmdsZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqL1xuICBzcGVjaWFsQ2xvc2VPZmZIYW5kbGVyKGNoZWNrRWwsIHNpbmdsZSwgZSkge1xuICAgIGlmIChYdFV0aWwuY2hlY2tPdXRzaWRlKGUsIFh0VXRpbC5hcnJTaW5nbGUoY2hlY2tFbCkpKSB7XG4gICAgICB0aGlzLmV2ZW50T2ZmKHNpbmdsZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHNjcm9sbGJhciBhY3RpdmF0aW9uXG4gICAqL1xuICBzcGVjaWFsU2Nyb2xsYmFyT24oKSB7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBvcHRpb25zID0gc2VsZi5vcHRpb25zO1xuICAgIC8vXG4gICAgaWYgKG9wdGlvbnMuc2Nyb2xsYmFyKSB7XG4gICAgICBsZXQgZWxlbWVudHM7XG4gICAgICBsZXQgd2lkdGggPSBYdFV0aWwuc2Nyb2xsYmFyV2lkdGgoKTtcbiAgICAgIC8vIGNoZWNrIGZpeGVkXG4gICAgICBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy54dC1jaGVjay1maXhlZCA+IConKTtcbiAgICAgIGZvciAobGV0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgbGV0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICAgICAgaWYgKHN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCd4dC1maXhlZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgneHQtZml4ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZml4ZWRcbiAgICAgIGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnh0LWZpeGVkJyk7XG4gICAgICBmb3IgKGxldCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gJyc7XG4gICAgICAgIGlmIChzZWxmLm5vcm1hbGl6ZVdpZHRoKGVsZW1lbnQuY2xpZW50V2lkdGgpID09PSAnJykge1xuICAgICAgICAgIGxldCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgICAgICAgbGV0IHBhZGRpbmcgPSBzdHlsZS5wYWRkaW5nUmlnaHQ7XG4gICAgICAgICAgbGV0IHN0ciA9ICdjYWxjKCcgKyBwYWRkaW5nICsgJyArICcgKyB3aWR0aCArICdweCknO1xuICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbm8tdHJhbnNpdGlvbicpO1xuICAgICAgICAgIFh0VXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuY2FsbCh3aW5kb3csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gc3RyO1xuICAgICAgICAgICAgWHRVdGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZS5jYWxsKHdpbmRvdywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ25vLXRyYW5zaXRpb24nKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBiYWNrZHJvcFxuICAgICAgZWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcueHQtYmFja2Ryb3AnKTtcbiAgICAgIGZvciAobGV0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5yaWdodCA9IHdpZHRoICsgJ3B4JztcbiAgICAgIH1cbiAgICAgIC8vIHNjcm9sbFxuICAgICAgbGV0IGNvbnRhaW5lciA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgIGNvbnRhaW5lci5zdHlsZS5wYWRkaW5nUmlnaHQgPSB3aWR0aCArICdweCc7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgneHQtc2Nyb2xsYmFyJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHNjcm9sbGJhciBkZWFjdGl2YXRpb25cbiAgICovXG4gIHNwZWNpYWxTY3JvbGxiYXJPZmYoKSB7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBvcHRpb25zID0gc2VsZi5vcHRpb25zO1xuICAgIC8vXG4gICAgaWYgKG9wdGlvbnMuc2Nyb2xsYmFyKSB7XG4gICAgICBsZXQgZWxlbWVudHM7XG4gICAgICAvLyBzY3JvbGxcbiAgICAgIGxldCBjb250YWluZXIgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICBjb250YWluZXIuc3R5bGUucGFkZGluZ1JpZ2h0ID0gJyc7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgneHQtc2Nyb2xsYmFyJyk7XG4gICAgICAvLyBmaXhlZFxuICAgICAgZWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcueHQtZml4ZWQnKTtcbiAgICAgIGZvciAobGV0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCduby10cmFuc2l0aW9uJyk7XG4gICAgICAgIFh0VXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuY2FsbCh3aW5kb3csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9ICcnO1xuICAgICAgICAgIFh0VXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuY2FsbCh3aW5kb3csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnbm8tdHJhbnNpdGlvbicpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIGJhY2tkcm9wXG4gICAgICBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy54dC1iYWNrZHJvcCcpO1xuICAgICAgZm9yIChsZXQgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBlbGVtZW50LnN0eWxlLnJpZ2h0ID0gJyc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGlmIGZ1bGwgd2lkdGggcmV0dXJuICcnIGVsc2UgcmV0dXJuIHZhbHVlIGluIHB4XG4gICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gd2lkdGhcbiAgICogQHJldHVybnMge1N0cmluZ30gVmFsdWUgaW4gcHhcbiAgICovXG4gIG5vcm1hbGl6ZVdpZHRoKHdpZHRoKSB7XG4gICAgd2lkdGggPSBwYXJzZUZsb2F0KHdpZHRoKTtcbiAgICBpZiAod2lkdGggKyBYdFV0aWwuc2Nyb2xsYmFyV2lkdGgoKSA+PSB3aW5kb3cuaW5uZXJXaWR0aCkge1xuICAgICAgd2lkdGggPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgd2lkdGggKz0gJ3B4JztcbiAgICB9XG4gICAgcmV0dXJuIHdpZHRoO1xuICB9XG5cbn1cblxuLy8gZGVmYXVsdFxuXG5YdC5kZWZhdWx0cyA9IHtcbiAgXCJhdXRvXCI6IGZhbHNlLFxuICBcImF1dG9QYXVzZVwiOiBmYWxzZSxcbiAgXCJhdXRvQWx3YXlzXCI6IGZhbHNlXG59O1xuXG4vLyBleHBvcnRcblxud2luZG93Llh0ID0gWHQ7XG5leHBvcnQge1h0fTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gWHRUb2dnbGVcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuY2xhc3MgWHRUb2dnbGUgZXh0ZW5kcyBYdCB7XG5cbiAgLyoqXG4gICAqIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gb2JqZWN0IEJhc2Ugbm9kZVxuICAgKiBAcGFyYW0ge09iamVjdH0ganNPcHRpb25zIFVzZXIgb3B0aW9uc1xuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9iamVjdCwganNPcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihvYmplY3QsIGpzT3B0aW9ucywgJ2RhdGEteHQtdG9nZ2xlJyk7XG4gIH1cblxufVxuXG4vLyBkZWZhdWx0XG5cblh0VG9nZ2xlLmRlZmF1bHRzID0ge1xuICBcImVsZW1lbnRzXCI6IFwiOnNjb3BlID4gYSwgOnNjb3BlID4gYnV0dG9uXCIsXG4gIFwidGFyZ2V0c1wiOiBcIjpzY29wZSA+IFtjbGFzc149XFxcInRvZ2dsZS1cXFwiXSwgOnNjb3BlID4gW2NsYXNzKj1cXFwiIHRvZ2dsZS1cXFwiXVwiLFxuICBcImNsYXNzXCI6IFwiYWN0aXZlXCIsXG4gIFwiaW5zdGFudFwiOiB7XCJlbGVtZW50c1wiOiB0cnVlfSxcbiAgXCJvblwiOiBcImNsaWNrXCIsXG4gIFwidG9nZ2xlXCI6IHRydWUsXG4gIFwibWluXCI6IDAsXG4gIFwibWF4XCI6IDFcbn07XG5cbi8vIGV4cG9ydFxuXG53aW5kb3cuWHRUb2dnbGUgPSBYdFRvZ2dsZTtcbmV4cG9ydCB7WHRUb2dnbGV9O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBYdERyb3Bcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuY2xhc3MgWHREcm9wIGV4dGVuZHMgWHQge1xuXG4gIC8qKlxuICAgKiBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IG9iamVjdCBCYXNlIG5vZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGpzT3B0aW9ucyBVc2VyIG9wdGlvbnNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvYmplY3QsIGpzT3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob2JqZWN0LCBqc09wdGlvbnMsICdkYXRhLXh0LWRyb3AnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpbml0IGFyaWFcbiAgICovXG4gIGluaXRBcmlhKCkge1xuICAgIGlmICh0aGlzLnRhcmdldHMpIHtcbiAgICAgIGZvciAobGV0IHRyIG9mIHRoaXMudGFyZ2V0cykge1xuICAgICAgICAvLyBhcmlhLWxhYmVsXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWRkaXRpb25hbCkge1xuICAgICAgICAgIGxldCBsYWJlbCA9IHRoaXMuZ2V0QWRkaXRpb25hbCgpO1xuICAgICAgICAgIGlmIChsYWJlbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxhYmVsID0gbGFiZWxbMF0uaW5uZXJUZXh0LnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKCk7XG4gICAgICAgICAgICB0ci5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBsYWJlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cblxuLy8gZGVmYXVsdFxuXG5YdERyb3AuZGVmYXVsdHMgPSB7XG4gIFwiZWxlbWVudHNcIjogXCI6c2NvcGVcIixcbiAgXCJ0YXJnZXRzXCI6IFwiOnNjb3BlID4gLmRyb3BcIixcbiAgXCJhZGRpdGlvbmFsXCI6IFwiOnNjb3BlID4gYSwgOnNjb3BlID4gYnV0dG9uXCIsXG4gIFwiY2xhc3NcIjogXCJhY3RpdmVcIixcbiAgXCJpbnN0YW50XCI6IHtcImVsZW1lbnRzXCI6IHRydWV9LFxuICBcIm9uXCI6IFwiY2xpY2tcIixcbiAgXCJ0b2dnbGVcIjogdHJ1ZSxcbiAgXCJtaW5cIjogMCxcbiAgXCJtYXhcIjogMSxcbiAgXCJjbG9zZU91dHNpZGVcIjogXCJib2R5XCJcbn07XG5cbi8vIGV4cG9ydFxuXG53aW5kb3cuWHREcm9wID0gWHREcm9wO1xuZXhwb3J0IHtYdERyb3B9O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBYdE92ZXJsYXlcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuY2xhc3MgWHRPdmVybGF5IGV4dGVuZHMgWHQge1xuXG4gIC8qKlxuICAgKiBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IG9iamVjdCBCYXNlIG5vZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGpzT3B0aW9ucyBVc2VyIG9wdGlvbnNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvYmplY3QsIGpzT3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob2JqZWN0LCBqc09wdGlvbnMsICdkYXRhLXh0LW92ZXJsYXknKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpbml0IGFyaWFcbiAgICovXG4gIGluaXRBcmlhKCkge1xuICAgIHN1cGVyLmluaXRBcmlhKCk7XG4gICAgaWYgKHRoaXMudGFyZ2V0cykge1xuICAgICAgZm9yIChsZXQgdHIgb2YgdGhpcy50YXJnZXRzKSB7XG4gICAgICAgIC8vIHJvbGVcbiAgICAgICAgdHIuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2RpYWxvZycpO1xuICAgICAgICB0ci5zZXRBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnLCAndHJ1ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG5cbi8vIGRlZmF1bHRcblxuWHRPdmVybGF5LmRlZmF1bHRzID0ge1xuICBcImVsZW1lbnRzXCI6IFwiOnNjb3BlID4gYSwgOnNjb3BlID4gYnV0dG9uXCIsXG4gIFwidGFyZ2V0c1wiOiBcIjpzY29wZSA+IC5vdmVybGF5LW91dGVyXCIsXG4gIFwiY2xhc3NcIjogXCJhY3RpdmVcIixcbiAgXCJpbnN0YW50XCI6IHtcImVsZW1lbnRzXCI6IHRydWV9LFxuICBcIm9uXCI6IFwiY2xpY2tcIixcbiAgXCJ0b2dnbGVcIjogdHJ1ZSxcbiAgXCJtaW5cIjogMCxcbiAgXCJtYXhcIjogMSxcbiAgXCJhcHBlbmRUb1wiOiBcImJvZHlcIixcbiAgXCJiYWNrZHJvcFwiOiBcInRhcmdldHNcIixcbiAgXCJjbGFzc0h0bWxcIjogXCJ4dC1vdmVybGF5XCIsXG4gIFwiY2xvc2VJbnNpZGVcIjogXCIub3ZlcmxheS1kaXNtaXNzLCA6c2NvcGUgPiAueHQtYmFja2Ryb3AsIDpzY29wZSAub3ZlcmxheS1pbm5lciA+IC5idG4tY2xvc2VcIixcbiAgXCJzY3JvbGxiYXJcIjogdHJ1ZVxufTtcblxuLy8gZXhwb3J0XG5cbndpbmRvdy5YdE92ZXJsYXkgPSBYdE92ZXJsYXk7XG5leHBvcnQge1h0T3ZlcmxheX07XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFh0U3RpY2t5XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmNsYXNzIFh0U3RpY2t5IGV4dGVuZHMgWHQge1xuXG4gIC8qKlxuICAgKiBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IG9iamVjdCBCYXNlIG5vZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGpzT3B0aW9ucyBVc2VyIG9wdGlvbnNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvYmplY3QsIGpzT3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob2JqZWN0LCBqc09wdGlvbnMsICdkYXRhLXh0LXN0aWNreScpO1xuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBpbml0XG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAvKipcbiAgICogaW5pdCBlbGVtZW50cywgdGFyZ2V0cyBhbmQgY3VycmVudHNcbiAgICovXG4gIGluaXRTY29wZSgpIHtcbiAgICBzdXBlci5pbml0U2NvcGUoKTtcbiAgICAvLyBtb2RlXG4gICAgdGhpcy5tb2RlID0gJ2FsbCc7XG4gICAgLy8gY29udGFpbmVyXG4gICAgdGhpcy5jb250YWluZXIgPSBYdFV0aWwucGFyZW50cyh0aGlzLm9iamVjdCwgJy54dC1jb250YWluZXInKTtcbiAgICBpZiAoIXRoaXMuY29udGFpbmVyLmxlbmd0aCkge1xuICAgICAgdGhpcy5jb250YWluZXIgPSBYdFV0aWwuY3JlYXRlRWxlbWVudCgnPGRpdiBjbGFzcz1cInh0LWNvbnRhaW5lciB4dC1jaGVjay1maXhlZFwiPjwvZGl2PicpO1xuICAgICAgdGhpcy5vYmplY3QuYmVmb3JlKHRoaXMuY29udGFpbmVyKTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZCh0aGlzLm9iamVjdCk7XG4gICAgICB0aGlzLmNvbnRhaW5lciA9IFh0VXRpbC5wYXJlbnRzKHRoaXMub2JqZWN0LCAnLnh0LWNvbnRhaW5lcicpO1xuICAgIH1cbiAgICAvLyB0YXJnZXRzXG4gICAgdGhpcy50YXJnZXRzID0gdGhpcy5jb250YWluZXJbMF0ucXVlcnlTZWxlY3RvckFsbCgnLnh0LWNsb25lJyk7XG4gICAgaWYgKCF0aGlzLnRhcmdldHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnRhcmdldHMgPSB0aGlzLm9iamVjdC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICB0aGlzLnRhcmdldHMuY2xhc3NMaXN0LmFkZCgneHQtY2xvbmUnKTtcbiAgICAgIHRoaXMudGFyZ2V0cy5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgIGZvciAobGV0IGVsSWQgb2YgdGhpcy50YXJnZXRzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpZF0nKSkge1xuICAgICAgICBlbElkLnNldEF0dHJpYnV0ZSgnaWQnLCBlbElkLmdldEF0dHJpYnV0ZSgnaWQnKSArICctY2xvbmUnKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGVsTmFtZSBvZiB0aGlzLnRhcmdldHMucXVlcnlTZWxlY3RvckFsbCgnW25hbWVdJykpIHtcbiAgICAgICAgZWxOYW1lLnNldEF0dHJpYnV0ZSgnbmFtZScsIGVsTmFtZS5nZXRBdHRyaWJ1dGUoJ25hbWUnKSArICctY2xvbmUnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGFpbmVyWzBdLmFwcGVuZCh0aGlzLnRhcmdldHMpO1xuICAgIH1cbiAgICB0aGlzLnRhcmdldHMgPSBYdFV0aWwuYXJyU2luZ2xlKHRoaXMudGFyZ2V0cyk7XG4gICAgLy8geHQtZml4ZWRcbiAgICB0aGlzLm9iamVjdC5jbGFzc0xpc3QuYWRkKCd4dC1maXhlZCcpO1xuICAgIC8vIGhpZGVcbiAgICBpZiAodGhpcy5vcHRpb25zLmhpZGUgPT09ICdkb3duJykge1xuICAgICAgdGhpcy5vYmplY3QuY2xhc3NMaXN0LmFkZCgnc3RpY2t5LWhpZGUtZG93bicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9iamVjdC5jbGFzc0xpc3QucmVtb3ZlKCdzdGlja3ktaGlkZS1kb3duJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuaGlkZSA9PT0gJ3VwJykge1xuICAgICAgdGhpcy5vYmplY3QuY2xhc3NMaXN0LmFkZCgnc3RpY2t5LWhpZGUtdXAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vYmplY3QuY2xhc3NMaXN0LnJlbW92ZSgnc3RpY2t5LWhpZGUtdXAnKTtcbiAgICB9XG4gICAgLy8gei1pbmRleFxuICAgIHRoaXMudW5pcXVlID0gWHRVdGlsLmdldFVuaXF1ZU51bSgpO1xuICAgIHRoaXMub2JqZWN0LnN0eWxlLnpJbmRleCA9ICcnICsgKDEwMCAtIHRoaXMudW5pcXVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpbml0IGV2ZW50c1xuICAgKi9cbiAgaW5pdEV2ZW50cygpIHtcbiAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgbGV0IG9wdGlvbnMgPSBzZWxmLm9wdGlvbnM7XG4gICAgLy8gZXZlbnRzXG4gICAgaWYgKG9wdGlvbnMub24pIHtcbiAgICAgIC8vIGhhbmRsZXJcbiAgICAgIGxldCBzdGlja3lIYW5kbGVyID0gWHRVdGlsLmRhdGFTdG9yYWdlLnB1dCh3aW5kb3csICdzdGlja3lIYW5kbGVyJywgc2VsZi5ldmVudE9uSGFuZGxlci5iaW5kKHNlbGYpKTtcbiAgICAgIC8vIGV2ZW50XG4gICAgICBsZXQgZXZlbnRzID0gWy4uLm9wdGlvbnMub24uc3BsaXQoJyAnKV07XG4gICAgICBmb3IgKGxldCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIHN0aWNreUhhbmRsZXIpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgc3RpY2t5SGFuZGxlcik7XG4gICAgICB9XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb24uc3RpY2t5Jywgc3RpY2t5SGFuZGxlcik7XG4gICAgfVxuICAgIC8vIHRyaWdnZXIgaW5pdGlhbFxuICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnb24uc3RpY2t5JykpO1xuICB9XG5cbiAgLyoqXG4gICAqIGVsZW1lbnQgb24gaGFuZGxlclxuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgZXZlbnRPbkhhbmRsZXIoZWxlbWVudCwgZSkge1xuICAgIHRoaXMuZXZlbnRTY3JvbGwodGhpcy5vYmplY3QpO1xuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBldmVudHNcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIC8qKlxuICAgKiB3aW5kb3cgc2Nyb2xsXG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gZWxlbWVudCBUbyBiZSBhY3RpdmF0ZWQgb3IgZGVhY3RpdmF0ZWRcbiAgICovXG4gIGV2ZW50U2Nyb2xsKGVsZW1lbnQpIHtcbiAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgbGV0IG9wdGlvbnMgPSBzZWxmLm9wdGlvbnM7XG4gICAgLy8gdmFyc1xuICAgIGxldCBhbmltID0gdHJ1ZTtcbiAgICBsZXQgaGlkZSA9IGZhbHNlO1xuICAgIGxldCBzY3JvbGxJbnZlcnNlID0gZmFsc2U7XG4gICAgbGV0IGFkZCA9IDA7XG4gICAgbGV0IGFkZEhpZGUgPSAwO1xuICAgIGxldCB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgbGV0IGVsID0gc2VsZi5vYmplY3Q7XG4gICAgbGV0IHJlY3RFbFRvcCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICBsZXQgaGVpZ2h0RWwgPSBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUoZWwpLmhlaWdodCk7XG4gICAgbGV0IGhlaWdodFRhcmdldCA9IHBhcnNlRmxvYXQoZ2V0Q29tcHV0ZWRTdHlsZShzZWxmLnRhcmdldHNbMF0pLmhlaWdodCk7XG4gICAgbGV0IHJlY3RDb250YWluZXJUb3AgPSBzZWxmLmNvbnRhaW5lclswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgbGV0IHNjcm9sbGluZ0VsZW1lbnQgPSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50O1xuICAgIGxldCBzY3JvbGxIZWlnaHQgPSBzY3JvbGxpbmdFbGVtZW50LnNjcm9sbEhlaWdodDtcbiAgICBsZXQgc2Nyb2xsVG9wID0gc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3A7XG4gICAgbGV0IHNjcm9sbFRvcE9sZCA9IHNlbGYuc2Nyb2xsVG9wT2xkO1xuICAgIC8vIGRpcmVjdGlvblxuICAgIGlmIChzY3JvbGxUb3AgPCBzY3JvbGxUb3BPbGQpIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ3N0aWNreS1kb3duJyk7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKCdzdGlja3ktdXAnKTtcbiAgICAgIHNjcm9sbEludmVyc2UgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKCdzdGlja3ktZG93bicpO1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnc3RpY2t5LXVwJyk7XG4gICAgfVxuICAgIC8vIGhpZGVcbiAgICBpZiAob3B0aW9ucy5oaWRlID09PSAnZG93bicpIHtcbiAgICAgIGlmICghc2Nyb2xsSW52ZXJzZSkge1xuICAgICAgICBhZGRIaWRlID0gaGVpZ2h0VGFyZ2V0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5oaWRlID09PSAndXAnKSB7XG4gICAgICBpZiAoc2Nyb2xsSW52ZXJzZSkge1xuICAgICAgICBhZGRIaWRlID0gaGVpZ2h0VGFyZ2V0O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBzY3JvbGxcbiAgICBsZXQgdG9wID0gc2VsZi5ldmVudFNjcm9sbFBvcyhvcHRpb25zLmxpbWl0Wyd0b3AnXSB8fCBzZWxmLnRhcmdldHMsIHNjcm9sbFRvcCwgcmVjdENvbnRhaW5lclRvcCk7XG4gICAgbGV0IGJvdHRvbSA9IHNlbGYuZXZlbnRTY3JvbGxQb3Mob3B0aW9ucy5saW1pdFsnYm90dG9tJ10sIHNjcm9sbFRvcCwgSW5maW5pdHkpO1xuICAgIGlmIChvcHRpb25zLnBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgYm90dG9tIC09IGhlaWdodFRhcmdldDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICB0b3AgLT0gd2luZG93SGVpZ2h0IC0gaGVpZ2h0VGFyZ2V0O1xuICAgICAgYm90dG9tID0gTWF0aC5hYnMoc2Nyb2xsSGVpZ2h0IC0gd2luZG93SGVpZ2h0IC0gYm90dG9tKTtcbiAgICB9XG4gICAgLy8gY29udGFpbiBhbmQgYWRkXG4gICAgbGV0IGFkZFRvcCA9IDA7XG4gICAgbGV0IGFkZEJvdHRvbSA9IDA7XG4gICAgaWYgKG9wdGlvbnMuY29udGFpbikge1xuICAgICAgaWYgKG9wdGlvbnMuY29udGFpblsndG9wJ10pIHtcbiAgICAgICAgbGV0IGFkZFRvcE9iaiA9IHNlbGYuZXZlbnRTY3JvbGxIZWlnaHQob3B0aW9ucy5jb250YWluWyd0b3AnXSwgc2Nyb2xsSW52ZXJzZSk7XG4gICAgICAgIGFkZFRvcCA9IGFkZFRvcE9iai52YWw7XG4gICAgICAgIGlmIChhZGRUb3AgIT09IG51bGwgJiYgYWRkVG9wID4gcmVjdENvbnRhaW5lclRvcCkge1xuICAgICAgICAgIGFkZCA9IGFkZFRvcDtcbiAgICAgICAgICBpZiAoIWFkZFRvcE9iai5mb3VuZEhpZGUpIHtcbiAgICAgICAgICAgIGFuaW0gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkVG9wID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuY29udGFpblsnYm90dG9tJ10pIHtcbiAgICAgICAgYWRkQm90dG9tID0gc2VsZi5ldmVudFNjcm9sbFBvcyhvcHRpb25zLmNvbnRhaW5bJ2JvdHRvbSddKTtcbiAgICAgICAgaWYgKGFkZEJvdHRvbSAhPT0gbnVsbCAmJiBhZGRCb3R0b20gPCBoZWlnaHRFbCArIGFkZFRvcCkge1xuICAgICAgICAgIGFkZCA9IGFkZEJvdHRvbSAtIGhlaWdodEVsO1xuICAgICAgICAgIGFuaW0gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRCb3R0b20gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHNhdmUgcmVhbCBhZGQgZm9yIGNhbGN1bGF0aW9uXG4gICAgZWwuZGF0YXNldC54dEFkZFN0aWNreSA9IGFkZC50b1N0cmluZygpO1xuICAgIC8vIGFjdGl2YXRpb25cbiAgICBsZXQgY2hlY2tUb3AgPSBzY3JvbGxUb3AgPj0gdG9wIC0gYWRkICsgYWRkSGlkZTtcbiAgICBsZXQgY2hlY2tCb3R0b20gPSBzY3JvbGxUb3AgPCBib3R0b20gKyBhZGQgLSBhZGRIaWRlO1xuICAgIGlmIChjaGVja1RvcCAmJiBjaGVja0JvdHRvbSkge1xuICAgICAgLy8gaW5zaWRlXG4gICAgICBzZWxmLmV2ZW50T24oZWxlbWVudCk7XG4gICAgICAvLyBoaWRlXG4gICAgICBpZiAoYWRkSGlkZSkge1xuICAgICAgICBoaWRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3V0c2lkZVxuICAgICAgc2VsZi5ldmVudE9mZihlbGVtZW50KTtcbiAgICB9XG4gICAgLy8gYWZ0ZXIgYWN0aXZlXG4gICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykpIHtcbiAgICAgIC8vIGhpZGVcbiAgICAgIGlmIChoaWRlKSB7XG4gICAgICAgIGFkZCA9IC1oZWlnaHRFbDtcbiAgICAgICAgaWYgKCFlbC5jbGFzc0xpc3QuY29udGFpbnMoJ3N0aWNreS1oaWRlJykpIHtcbiAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdzdGlja3ktaGlkZScpO1xuICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdzdGlja3kuaGlkZScpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnc3RpY2t5LWhpZGUnKSkge1xuICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ3N0aWNreS1oaWRlJyk7XG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3N0aWNreS5zaG93JykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlc2V0XG4gICAgICBhZGQgPSAwO1xuICAgICAgYW5pbSA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBhbmltXG4gICAgaWYgKGFuaW0gJiYgc2Nyb2xsVG9wT2xkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdzdGlja3ktYW5pbScpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ3N0aWNreS1hbmltJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ3N0aWNreS1hbmltJykpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnc3RpY2t5LWFuaW0nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdG9wIGFuZCBib3R0b21cbiAgICBpZiAoIWNoZWNrVG9wKSB7XG4gICAgICBpZiAoIWVsLmNsYXNzTGlzdC5jb250YWlucygnc3RpY2t5LXRvcCcpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ3N0aWNreS10b3AnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnc3RpY2t5LXRvcCcpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ3N0aWNreS10b3AnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjaGVja0JvdHRvbSkge1xuICAgICAgaWYgKCFlbC5jbGFzc0xpc3QuY29udGFpbnMoJ3N0aWNreS1ib3R0b20nKSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdzdGlja3ktYm90dG9tJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ3N0aWNreS1ib3R0b20nKSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdzdGlja3ktYm90dG9tJyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHNldCBhZGRcbiAgICBpZiAoYWRkICE9PSBzZWxmLmFkZE9sZCkge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnbm8tdHJhbnNpdGlvbicpO1xuICAgICAgaWYgKHNlbGYuYWRkT2xkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWwuc3R5bGVbb3B0aW9ucy5wb3NpdGlvbl0gPSByZWN0RWxUb3AgKyAncHgnO1xuICAgICAgfVxuICAgICAgWHRVdGlsLmNhbmNlbEFuaW1hdGlvbkZyYW1lLmNhbGwod2luZG93LCBzZWxmLmV2ZW50RnJhbWUpO1xuICAgICAgc2VsZi5ldmVudEZyYW1lID0gWHRVdGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZS5jYWxsKHdpbmRvdywgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCduby10cmFuc2l0aW9uJyk7XG4gICAgICAgIGVsLnN0eWxlW29wdGlvbnMucG9zaXRpb25dID0gYWRkICsgJ3B4JztcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBmaXggcG9zaXRpb24gZml4ZWQgd2lkdGggMTAwJSBvZiBwYXJlbnRcbiAgICBsZXQgd2lkdGggPSBzZWxmLm5vcm1hbGl6ZVdpZHRoKHNlbGYuY29udGFpbmVyWzBdLmNsaWVudFdpZHRoKTtcbiAgICBpZiAoZWwuc3R5bGUud2lkdGggIT09IHdpZHRoKSB7XG4gICAgICBlbC5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgIH1cbiAgICAvLyBzYXZlIGZvciBkaXJlY3Rpb25cbiAgICBzZWxmLmFkZE9sZCA9IGFkZDtcbiAgICBzZWxmLnNjcm9sbFRvcE9sZCA9IHNjcm9sbFRvcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgcG9zaXRpb24gb2Ygb3B0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxFbGVtZW50fSBvcHRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbCBEZWZhdWx0IHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY3JvbGxUb3AgV2luZG93J3Mgc2Nyb2xsVG9wXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHZhbHVlIE9wdGlvbidzIHBvc2l0aW9uIChweClcbiAgICovXG4gIGV2ZW50U2Nyb2xsUG9zKG9wdGlvbiwgc2Nyb2xsVG9wID0gMCwgdmFsID0gbnVsbCkge1xuICAgIGlmICghaXNOYU4ocGFyc2VGbG9hdChvcHRpb24pKSkge1xuICAgICAgdmFsID0gb3B0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZWxlbWVudHMgPSBBcnJheS5pc0FycmF5KG9wdGlvbikgPyBvcHRpb24gOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKG9wdGlvbik7XG4gICAgICBpZiAoZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICB2YWwgPSAwO1xuICAgICAgICBmb3IgKGxldCBlbCBvZiBlbGVtZW50cykge1xuICAgICAgICAgIGxldCBhZGRTdGlja3kgPSBwYXJzZUZsb2F0KGVsLmRhdGFzZXQueHRBZGRTdGlja3kpO1xuICAgICAgICAgIGlmIChhZGRTdGlja3kpIHsgLy8gaWYgc3RpY2t5LWhpZGUgZ2V0IHJlYWwgYWRkXG4gICAgICAgICAgICBsZXQgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAgICAgICAgIGlmIChzdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgdmFsICs9IGFkZFN0aWNreTtcbiAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFsICs9IHJlY3QudG9wO1xuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICB2YWwgKz0gc2Nyb2xsVG9wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgaGVpZ2h0IG9mIG9wdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8RWxlbWVudH0gb3B0aW9uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2Nyb2xsSW52ZXJzZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsIERlZmF1bHQgdmFsdWVcbiAgICogQHJldHVybnMge09iamVjdH0gb2JqIE9wdGlvbidzIGhlaWdodCAocHgpIGFuZCBpZiBmb3VuZCBoaWRlIGVsZW1lbnRcbiAgICovXG4gIGV2ZW50U2Nyb2xsSGVpZ2h0KG9wdGlvbiwgc2Nyb2xsSW52ZXJzZSwgdmFsID0gbnVsbCkge1xuICAgIGxldCBmb3VuZEhpZGUgPSBmYWxzZTtcbiAgICBpZiAoIWlzTmFOKHBhcnNlRmxvYXQob3B0aW9uKSkpIHtcbiAgICAgIHZhbCA9IG9wdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGVsZW1lbnRzID0gQXJyYXkuaXNBcnJheShvcHRpb24pID8gb3B0aW9uIDogZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChvcHRpb24pO1xuICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBlbCBvZiBlbGVtZW50cykge1xuICAgICAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ3N0aWNreS1oaWRlLWRvd24nKSAmJiBlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpKSB7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsSW52ZXJzZSkge1xuICAgICAgICAgICAgICB2YWwgKz0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICBmb3VuZEhpZGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdzdGlja3ktaGlkZS11cCcpICYmIGVsLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykpIHtcbiAgICAgICAgICAgIGlmICghc2Nyb2xsSW52ZXJzZSkge1xuICAgICAgICAgICAgICB2YWwgKz0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICBmb3VuZEhpZGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWwgKz0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge3ZhbDogdmFsLCBmb3VuZEhpZGU6IGZvdW5kSGlkZX07XG4gIH1cblxufVxuYWxlcnQoJ2NjY2MnKTtcbi8vIGRlZmF1bHRcblxuWHRTdGlja3kuZGVmYXVsdHMgPSB7XG4gIFwiY2xhc3NcIjogXCJhY3RpdmVcIixcbiAgXCJvblwiOiBcInNjcm9sbCByZXNpemVcIixcbiAgXCJtaW5cIjogMCxcbiAgXCJtYXhcIjogSW5maW5pdHksXG4gIFwicG9zaXRpb25cIjogXCJ0b3BcIixcbiAgXCJsaW1pdFwiOiB7XCJib3R0b21cIjogSW5maW5pdHl9LFxuICBcImNvbnRhaW5cIjogZmFsc2UsXG4gIFwiaGlkZVwiOiBmYWxzZVxufTtcblxuLy8gZXhwb3J0XG5cbndpbmRvdy5YdFN0aWNreSA9IFh0U3RpY2t5O1xuZXhwb3J0IHtYdFN0aWNreX07XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFh0RmFkZVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5jbGFzcyBYdEZhZGUgZXh0ZW5kcyBYdCB7XG5cbiAgLyoqXG4gICAqIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gb2JqZWN0IEJhc2Ugbm9kZVxuICAgKiBAcGFyYW0ge09iamVjdH0ganNPcHRpb25zIFVzZXIgb3B0aW9uc1xuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9iamVjdCwganNPcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihvYmplY3QsIGpzT3B0aW9ucywgJ2RhdGEteHQtZmFkZScpO1xuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBpbml0XG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAvKipcbiAgICogaW5pdCBldmVudHNcbiAgICovXG4gIGluaXRFdmVudHMoKSB7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBvcHRpb25zID0gc2VsZi5vcHRpb25zO1xuICAgIC8vIGV2ZW50c1xuICAgIGlmIChvcHRpb25zLm9uKSB7XG4gICAgICAvLyBoYW5kbGVyXG4gICAgICBsZXQgZmFkZUhhbmRsZXIgPSBYdFV0aWwuZGF0YVN0b3JhZ2UucHV0KHdpbmRvdywgJ2ZhZGVIYW5kbGVyJywgc2VsZi5ldmVudE9uSGFuZGxlci5iaW5kKHNlbGYpKTtcbiAgICAgIC8vIGV2ZW50XG4gICAgICBsZXQgZXZlbnRzID0gWy4uLm9wdGlvbnMub24uc3BsaXQoJyAnKV07XG4gICAgICBmb3IgKGxldCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGZhZGVIYW5kbGVyKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZhZGVIYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvbi5mYWRlJywgZmFkZUhhbmRsZXIpO1xuICAgIH1cbiAgICAvLyB0cmlnZ2VyIGluaXRpYWxcbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ29uLmZhZGUnKSk7XG4gIH1cblxuICAvKipcbiAgICogZWxlbWVudCBvbiBoYW5kbGVyXG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqL1xuICBldmVudE9uSGFuZGxlcihlbGVtZW50LCBlKSB7XG4gICAgdGhpcy5ldmVudFNjcm9sbCh0aGlzLm9iamVjdCk7XG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIGV2ZW50c1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgLyoqXG4gICAqIHdpbmRvdyBzY3JvbGxcbiAgICovXG4gIGV2ZW50U2Nyb2xsKCkge1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBsZXQgb3B0aW9ucyA9IHNlbGYub3B0aW9ucztcbiAgICAvLyB2YXJzXG4gICAgbGV0IGN1cnJlbnQgPSAwO1xuICAgIGxldCBjdXJyZW50cyA9IFtdO1xuICAgIGxldCBzY3JvbGxJbnZlcnNlID0gZmFsc2U7XG4gICAgbGV0IHdpbmRvd0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICBsZXQgc2Nyb2xsaW5nRWxlbWVudCA9IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQ7XG4gICAgbGV0IHNjcm9sbFRvcCA9IHNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsVG9wO1xuICAgIGxldCBzY3JvbGxUb3BPbGQgPSBzZWxmLnNjcm9sbFRvcE9sZDtcbiAgICAvLyBkaXJlY3Rpb25cbiAgICBpZiAoc2Nyb2xsVG9wIDwgc2Nyb2xsVG9wT2xkKSB7XG4gICAgICBzY3JvbGxJbnZlcnNlID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gY29yZVxuICAgIGZvciAobGV0IGVsIG9mIHNlbGYuZWxlbWVudHMpIHtcbiAgICAgIGlmIChlbC5vZmZzZXRQYXJlbnQgJiYgIWVsLmNsYXNzTGlzdC5jb250YWlucygnZmFkZS1ibG9jaycpKSB7XG4gICAgICAgIC8vIHZhcnNcbiAgICAgICAgbGV0IHJlY3RFbFRvcCA9IGVsLm9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyBlbC5vZmZzZXRUb3A7IC8vIHdlIHVzZSBwYXJlbnRzIHRvIG5vdCBpbmNsdWRlIHRyYW5zZm9ybXMgYW5pbWF0aW9uc1xuICAgICAgICBsZXQgaGVpZ2h0RWwgPSBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUoZWwpLmhlaWdodCk7XG4gICAgICAgIC8vIHNjcm9sbFxuICAgICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgdG9wID0gcmVjdEVsVG9wICsgc2Nyb2xsVG9wO1xuICAgICAgICBsZXQgYm90dG9tID0gdG9wICsgaGVpZ2h0RWw7XG4gICAgICAgIGxldCBkaXN0ID0gd2luZG93SGVpZ2h0ICogb3B0aW9ucy5kaXN0YW5jZTtcbiAgICAgICAgLy8gYWN0aXZhdGlvblxuICAgICAgICBsZXQgY2hlY2tUb3AgPSBzY3JvbGxUb3AgKyB3aW5kb3dIZWlnaHQgPj0gdG9wICsgZGlzdDtcbiAgICAgICAgbGV0IGNoZWNrQm90dG9tID0gc2Nyb2xsVG9wIDwgYm90dG9tIC0gZGlzdDtcbiAgICAgICAgaWYgKGNoZWNrVG9wICYmIGNoZWNrQm90dG9tKSB7XG4gICAgICAgICAgLy8gaW5zaWRlXG4gICAgICAgICAgY2hhbmdlZCA9IHNlbGYuY2hlY2tPbihlbCk7XG4gICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRzLnB1c2goZWwpO1xuICAgICAgICAgICAgWHRVdGlsLmNhbmNlbEFuaW1hdGlvbkZyYW1lLmNhbGwod2luZG93LCBlbC5kYXRhc2V0LmV2ZW50RnJhbWUpO1xuICAgICAgICAgICAgZWwuZGF0YXNldC5ldmVudEZyYW1lID0gWHRVdGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZS5jYWxsKHdpbmRvdywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWxheU9uKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZ1bmMgPSBuZXcgRnVuY3Rpb24oJ2N1cnJlbnQnLCAndG90YWwnLCBvcHRpb25zLmRlbGF5T24pO1xuICAgICAgICAgICAgICAgIGVsLmRhdGFzZXQueHRPbkRlbGF5ID0gZnVuYyhjdXJyZW50LCBjdXJyZW50cy5sZW5ndGgpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNlbGYuZXZlbnRPbihlbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb3V0c2lkZVxuICAgICAgICAgIGNoYW5nZWQgPSBzZWxmLmNoZWNrT2ZmKGVsKTtcbiAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdmYWRlLXZpc2libGUnKTtcbiAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnZmFkZS1zY3JvbGwnKTtcbiAgICAgICAgICAgIGN1cnJlbnRzLnB1c2goZWwpO1xuICAgICAgICAgICAgWHRVdGlsLmNhbmNlbEFuaW1hdGlvbkZyYW1lLmNhbGwod2luZG93LCBlbC5kYXRhc2V0LmV2ZW50RnJhbWUpO1xuICAgICAgICAgICAgZWwuZGF0YXNldC5ldmVudEZyYW1lID0gWHRVdGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZS5jYWxsKHdpbmRvdywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWxheU9mZikge1xuICAgICAgICAgICAgICAgIGxldCBmdW5jID0gbmV3IEZ1bmN0aW9uKCdjdXJyZW50JywgJ3RvdGFsJywgb3B0aW9ucy5kZWxheU9mZik7XG4gICAgICAgICAgICAgICAgZWwuZGF0YXNldC54dE9mZkRlbGF5ID0gZnVuYyhjdXJyZW50LCBjdXJyZW50cy5sZW5ndGgpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoYW5nZWQgPSBzZWxmLmV2ZW50T2ZmKGVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBkaXJlY3Rpb25cbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICBpZiAoc2Nyb2xsSW52ZXJzZSkge1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnZmFkZS1kb3duJyk7XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdmYWRlLXVwJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2ZhZGUtZG93bicpO1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnZmFkZS11cCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBzYXZlIGZvciBkaXJlY3Rpb25cbiAgICBzZWxmLnNjcm9sbFRvcE9sZCA9IHNjcm9sbFRvcDtcbiAgfVxuXG59XG5cbi8vIGRlZmF1bHRcblxuWHRGYWRlLmRlZmF1bHRzID0ge1xuICBcImVsZW1lbnRzXCI6IFwiLmZhZGVcIixcbiAgXCJjbGFzc1wiOiBcImluXCIsXG4gIFwib25cIjogXCJzY3JvbGwgcmVzaXplXCIsXG4gIFwibWluXCI6IDAsXG4gIFwibWF4XCI6IEluZmluaXR5LFxuICBcImRpc3RhbmNlXCI6IDAuMixcbiAgXCJkZWxheU9uXCI6IGZhbHNlLFxuICBcImRlbGF5T2ZmXCI6IGZhbHNlXG59O1xuXG4vLyBleHBvcnRcblxud2luZG93Llh0RmFkZSA9IFh0RmFkZTtcbmV4cG9ydCB7WHRGYWRlfTtcbiJdfQ=="}