{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/core-js/modules/_a-function.js","node_modules/core-js/modules/_add-to-unscopables.js","node_modules/core-js/modules/_an-instance.js","node_modules/core-js/modules/_an-object.js","node_modules/core-js/modules/_array-copy-within.js","node_modules/core-js/modules/_array-fill.js","node_modules/core-js/modules/_array-includes.js","node_modules/core-js/modules/_array-methods.js","node_modules/core-js/modules/_array-species-constructor.js","node_modules/core-js/modules/_array-species-create.js","node_modules/core-js/modules/_bind.js","node_modules/core-js/modules/_classof.js","node_modules/core-js/modules/_cof.js","node_modules/core-js/modules/_collection-strong.js","node_modules/core-js/modules/_collection-weak.js","node_modules/core-js/modules/_collection.js","node_modules/core-js/modules/_core.js","node_modules/core-js/modules/_create-property.js","node_modules/core-js/modules/_ctx.js","node_modules/core-js/modules/_defined.js","node_modules/core-js/modules/_descriptors.js","node_modules/core-js/modules/_dom-create.js","node_modules/core-js/modules/_enum-bug-keys.js","node_modules/core-js/modules/_enum-keys.js","node_modules/core-js/modules/_export.js","node_modules/core-js/modules/_fails-is-regexp.js","node_modules/core-js/modules/_fails.js","node_modules/core-js/modules/_fix-re-wks.js","node_modules/core-js/modules/_flags.js","node_modules/core-js/modules/_for-of.js","node_modules/core-js/modules/_global.js","node_modules/core-js/modules/_has.js","node_modules/core-js/modules/_hide.js","node_modules/core-js/modules/_html.js","node_modules/core-js/modules/_ie8-dom-define.js","node_modules/core-js/modules/_inherit-if-required.js","node_modules/core-js/modules/_invoke.js","node_modules/core-js/modules/_iobject.js","node_modules/core-js/modules/_is-array-iter.js","node_modules/core-js/modules/_is-array.js","node_modules/core-js/modules/_is-integer.js","node_modules/core-js/modules/_is-object.js","node_modules/core-js/modules/_is-regexp.js","node_modules/core-js/modules/_iter-call.js","node_modules/core-js/modules/_iter-create.js","node_modules/core-js/modules/_iter-define.js","node_modules/core-js/modules/_iter-detect.js","node_modules/core-js/modules/_iter-step.js","node_modules/core-js/modules/_iterators.js","node_modules/core-js/modules/_library.js","node_modules/core-js/modules/_math-expm1.js","node_modules/core-js/modules/_math-fround.js","node_modules/core-js/modules/_math-log1p.js","node_modules/core-js/modules/_math-sign.js","node_modules/core-js/modules/_meta.js","node_modules/core-js/modules/_microtask.js","node_modules/core-js/modules/_new-promise-capability.js","node_modules/core-js/modules/_object-assign.js","node_modules/core-js/modules/_object-create.js","node_modules/core-js/modules/_object-dp.js","node_modules/core-js/modules/_object-dps.js","node_modules/core-js/modules/_object-gopd.js","node_modules/core-js/modules/_object-gopn-ext.js","node_modules/core-js/modules/_object-gopn.js","node_modules/core-js/modules/_object-gops.js","node_modules/core-js/modules/_object-gpo.js","node_modules/core-js/modules/_object-keys-internal.js","node_modules/core-js/modules/_object-keys.js","node_modules/core-js/modules/_object-pie.js","node_modules/core-js/modules/_object-sap.js","node_modules/core-js/modules/_object-to-array.js","node_modules/core-js/modules/_own-keys.js","node_modules/core-js/modules/_perform.js","node_modules/core-js/modules/_promise-resolve.js","node_modules/core-js/modules/_property-desc.js","node_modules/core-js/modules/_redefine-all.js","node_modules/core-js/modules/_redefine.js","node_modules/core-js/modules/_same-value.js","node_modules/core-js/modules/_set-proto.js","node_modules/core-js/modules/_set-species.js","node_modules/core-js/modules/_set-to-string-tag.js","node_modules/core-js/modules/_shared-key.js","node_modules/core-js/modules/_shared.js","node_modules/core-js/modules/_species-constructor.js","node_modules/core-js/modules/_string-at.js","node_modules/core-js/modules/_string-context.js","node_modules/core-js/modules/_string-pad.js","node_modules/core-js/modules/_string-repeat.js","node_modules/core-js/modules/_task.js","node_modules/core-js/modules/_to-absolute-index.js","node_modules/core-js/modules/_to-index.js","node_modules/core-js/modules/_to-integer.js","node_modules/core-js/modules/_to-iobject.js","node_modules/core-js/modules/_to-length.js","node_modules/core-js/modules/_to-object.js","node_modules/core-js/modules/_to-primitive.js","node_modules/core-js/modules/_typed-array.js","node_modules/core-js/modules/_typed-buffer.js","node_modules/core-js/modules/_typed.js","node_modules/core-js/modules/_uid.js","node_modules/core-js/modules/_user-agent.js","node_modules/core-js/modules/_validate-collection.js","node_modules/core-js/modules/_wks-define.js","node_modules/core-js/modules/_wks-ext.js","node_modules/core-js/modules/_wks.js","node_modules/core-js/modules/core.get-iterator-method.js","node_modules/core-js/modules/es6.array.copy-within.js","node_modules/core-js/modules/es6.array.fill.js","node_modules/core-js/modules/es6.array.find-index.js","node_modules/core-js/modules/es6.array.find.js","node_modules/core-js/modules/es6.array.from.js","node_modules/core-js/modules/es6.array.iterator.js","node_modules/core-js/modules/es6.array.of.js","node_modules/core-js/modules/es6.function.name.js","node_modules/core-js/modules/es6.map.js","node_modules/core-js/modules/es6.math.acosh.js","node_modules/core-js/modules/es6.math.asinh.js","node_modules/core-js/modules/es6.math.atanh.js","node_modules/core-js/modules/es6.math.cbrt.js","node_modules/core-js/modules/es6.math.clz32.js","node_modules/core-js/modules/es6.math.cosh.js","node_modules/core-js/modules/es6.math.expm1.js","node_modules/core-js/modules/es6.math.fround.js","node_modules/core-js/modules/es6.math.hypot.js","node_modules/core-js/modules/es6.math.imul.js","node_modules/core-js/modules/es6.math.log10.js","node_modules/core-js/modules/es6.math.log1p.js","node_modules/core-js/modules/es6.math.log2.js","node_modules/core-js/modules/es6.math.sign.js","node_modules/core-js/modules/es6.math.sinh.js","node_modules/core-js/modules/es6.math.tanh.js","node_modules/core-js/modules/es6.math.trunc.js","node_modules/core-js/modules/es6.number.epsilon.js","node_modules/core-js/modules/es6.number.is-finite.js","node_modules/core-js/modules/es6.number.is-integer.js","node_modules/core-js/modules/es6.number.is-nan.js","node_modules/core-js/modules/es6.number.is-safe-integer.js","node_modules/core-js/modules/es6.number.max-safe-integer.js","node_modules/core-js/modules/es6.number.min-safe-integer.js","node_modules/core-js/modules/es6.object.assign.js","node_modules/core-js/modules/es6.object.freeze.js","node_modules/core-js/modules/es6.object.get-own-property-descriptor.js","node_modules/core-js/modules/es6.object.get-own-property-names.js","node_modules/core-js/modules/es6.object.get-prototype-of.js","node_modules/core-js/modules/es6.object.is-extensible.js","node_modules/core-js/modules/es6.object.is-frozen.js","node_modules/core-js/modules/es6.object.is-sealed.js","node_modules/core-js/modules/es6.object.is.js","node_modules/core-js/modules/es6.object.keys.js","node_modules/core-js/modules/es6.object.prevent-extensions.js","node_modules/core-js/modules/es6.object.seal.js","node_modules/core-js/modules/es6.object.set-prototype-of.js","node_modules/core-js/modules/es6.promise.js","node_modules/core-js/modules/es6.reflect.apply.js","node_modules/core-js/modules/es6.reflect.construct.js","node_modules/core-js/modules/es6.reflect.define-property.js","node_modules/core-js/modules/es6.reflect.delete-property.js","node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js","node_modules/core-js/modules/es6.reflect.get-prototype-of.js","node_modules/core-js/modules/es6.reflect.get.js","node_modules/core-js/modules/es6.reflect.has.js","node_modules/core-js/modules/es6.reflect.is-extensible.js","node_modules/core-js/modules/es6.reflect.own-keys.js","node_modules/core-js/modules/es6.reflect.prevent-extensions.js","node_modules/core-js/modules/es6.reflect.set-prototype-of.js","node_modules/core-js/modules/es6.reflect.set.js","node_modules/core-js/modules/es6.regexp.flags.js","node_modules/core-js/modules/es6.regexp.match.js","node_modules/core-js/modules/es6.regexp.replace.js","node_modules/core-js/modules/es6.regexp.search.js","node_modules/core-js/modules/es6.regexp.split.js","node_modules/core-js/modules/es6.set.js","node_modules/core-js/modules/es6.string.code-point-at.js","node_modules/core-js/modules/es6.string.ends-with.js","node_modules/core-js/modules/es6.string.from-code-point.js","node_modules/core-js/modules/es6.string.includes.js","node_modules/core-js/modules/es6.string.raw.js","node_modules/core-js/modules/es6.string.repeat.js","node_modules/core-js/modules/es6.string.starts-with.js","node_modules/core-js/modules/es6.symbol.js","node_modules/core-js/modules/es6.typed.array-buffer.js","node_modules/core-js/modules/es6.typed.float32-array.js","node_modules/core-js/modules/es6.typed.float64-array.js","node_modules/core-js/modules/es6.typed.int16-array.js","node_modules/core-js/modules/es6.typed.int32-array.js","node_modules/core-js/modules/es6.typed.int8-array.js","node_modules/core-js/modules/es6.typed.uint16-array.js","node_modules/core-js/modules/es6.typed.uint32-array.js","node_modules/core-js/modules/es6.typed.uint8-array.js","node_modules/core-js/modules/es6.typed.uint8-clamped-array.js","node_modules/core-js/modules/es6.weak-map.js","node_modules/core-js/modules/es6.weak-set.js","node_modules/core-js/modules/es7.array.includes.js","node_modules/core-js/modules/es7.object.entries.js","node_modules/core-js/modules/es7.object.get-own-property-descriptors.js","node_modules/core-js/modules/es7.object.values.js","node_modules/core-js/modules/es7.string.pad-end.js","node_modules/core-js/modules/es7.string.pad-start.js","node_modules/core-js/modules/web.dom.iterable.js","node_modules/core-js/modules/web.immediate.js","node_modules/core-js/modules/web.timers.js","node_modules/regenerator-runtime/runtime.js","src/docs/assets/scripts/xtend.js","src/scripts/xtend-utils.js","src/scripts/xtend.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;;ACFA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;;ACHA;AACA;;ACDA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACheA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACntBA;;;ACJA;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;;AAEA;AACA;AACA;;AAEA,IAAM,S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","file":"xtend.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","module.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n","// 22.1.3.31 Array.prototype[@@unscopables]\nvar UNSCOPABLES = require('./_wks')('unscopables');\nvar ArrayProto = Array.prototype;\nif (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});\nmodule.exports = function (key) {\n  ArrayProto[UNSCOPABLES][key] = true;\n};\n","module.exports = function (it, Constructor, name, forbiddenField) {\n  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {\n    throw TypeError(name + ': incorrect invocation!');\n  } return it;\n};\n","var isObject = require('./_is-object');\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n","// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)\n'use strict';\nvar toObject = require('./_to-object');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nvar toLength = require('./_to-length');\n\nmodule.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {\n  var O = toObject(this);\n  var len = toLength(O.length);\n  var to = toAbsoluteIndex(target, len);\n  var from = toAbsoluteIndex(start, len);\n  var end = arguments.length > 2 ? arguments[2] : undefined;\n  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);\n  var inc = 1;\n  if (from < to && to < from + count) {\n    inc = -1;\n    from += count - 1;\n    to += count - 1;\n  }\n  while (count-- > 0) {\n    if (from in O) O[to] = O[from];\n    else delete O[to];\n    to += inc;\n    from += inc;\n  } return O;\n};\n","// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\n'use strict';\nvar toObject = require('./_to-object');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nvar toLength = require('./_to-length');\nmodule.exports = function fill(value /* , start = 0, end = @length */) {\n  var O = toObject(this);\n  var length = toLength(O.length);\n  var aLen = arguments.length;\n  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);\n  var end = aLen > 2 ? arguments[2] : undefined;\n  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);\n  while (endPos > index) O[index++] = value;\n  return O;\n};\n","// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./_to-iobject');\nvar toLength = require('./_to-length');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n","// 0 -> Array#forEach\n// 1 -> Array#map\n// 2 -> Array#filter\n// 3 -> Array#some\n// 4 -> Array#every\n// 5 -> Array#find\n// 6 -> Array#findIndex\nvar ctx = require('./_ctx');\nvar IObject = require('./_iobject');\nvar toObject = require('./_to-object');\nvar toLength = require('./_to-length');\nvar asc = require('./_array-species-create');\nmodule.exports = function (TYPE, $create) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  var create = $create || asc;\n  return function ($this, callbackfn, that) {\n    var O = toObject($this);\n    var self = IObject(O);\n    var f = ctx(callbackfn, that, 3);\n    var length = toLength(self.length);\n    var index = 0;\n    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;\n    var val, res;\n    for (;length > index; index++) if (NO_HOLES || index in self) {\n      val = self[index];\n      res = f(val, index, O);\n      if (TYPE) {\n        if (IS_MAP) result[index] = res;   // map\n        else if (res) switch (TYPE) {\n          case 3: return true;             // some\n          case 5: return val;              // find\n          case 6: return index;            // findIndex\n          case 2: result.push(val);        // filter\n        } else if (IS_EVERY) return false; // every\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;\n  };\n};\n","var isObject = require('./_is-object');\nvar isArray = require('./_is-array');\nvar SPECIES = require('./_wks')('species');\n\nmodule.exports = function (original) {\n  var C;\n  if (isArray(original)) {\n    C = original.constructor;\n    // cross-realm fallback\n    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;\n    if (isObject(C)) {\n      C = C[SPECIES];\n      if (C === null) C = undefined;\n    }\n  } return C === undefined ? Array : C;\n};\n","// 9.4.2.3 ArraySpeciesCreate(originalArray, length)\nvar speciesConstructor = require('./_array-species-constructor');\n\nmodule.exports = function (original, length) {\n  return new (speciesConstructor(original))(length);\n};\n","'use strict';\nvar aFunction = require('./_a-function');\nvar isObject = require('./_is-object');\nvar invoke = require('./_invoke');\nvar arraySlice = [].slice;\nvar factories = {};\n\nvar construct = function (F, len, args) {\n  if (!(len in factories)) {\n    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';\n    // eslint-disable-next-line no-new-func\n    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');\n  } return factories[len](F, args);\n};\n\nmodule.exports = Function.bind || function bind(that /* , ...args */) {\n  var fn = aFunction(this);\n  var partArgs = arraySlice.call(arguments, 1);\n  var bound = function (/* args... */) {\n    var args = partArgs.concat(arraySlice.call(arguments));\n    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);\n  };\n  if (isObject(fn.prototype)) bound.prototype = fn.prototype;\n  return bound;\n};\n","// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = require('./_cof');\nvar TAG = require('./_wks')('toStringTag');\n// ES3 wrong here\nvar ARG = cof(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (e) { /* empty */ }\n};\n\nmodule.exports = function (it) {\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n","var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n","'use strict';\nvar dP = require('./_object-dp').f;\nvar create = require('./_object-create');\nvar redefineAll = require('./_redefine-all');\nvar ctx = require('./_ctx');\nvar anInstance = require('./_an-instance');\nvar forOf = require('./_for-of');\nvar $iterDefine = require('./_iter-define');\nvar step = require('./_iter-step');\nvar setSpecies = require('./_set-species');\nvar DESCRIPTORS = require('./_descriptors');\nvar fastKey = require('./_meta').fastKey;\nvar validate = require('./_validate-collection');\nvar SIZE = DESCRIPTORS ? '_s' : 'size';\n\nvar getEntry = function (that, key) {\n  // fast case\n  var index = fastKey(key);\n  var entry;\n  if (index !== 'F') return that._i[index];\n  // frozen object case\n  for (entry = that._f; entry; entry = entry.n) {\n    if (entry.k == key) return entry;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {\n    var C = wrapper(function (that, iterable) {\n      anInstance(that, C, NAME, '_i');\n      that._t = NAME;         // collection type\n      that._i = create(null); // index\n      that._f = undefined;    // first entry\n      that._l = undefined;    // last entry\n      that[SIZE] = 0;         // size\n      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.1.3.1 Map.prototype.clear()\n      // 23.2.3.2 Set.prototype.clear()\n      clear: function clear() {\n        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {\n          entry.r = true;\n          if (entry.p) entry.p = entry.p.n = undefined;\n          delete data[entry.i];\n        }\n        that._f = that._l = undefined;\n        that[SIZE] = 0;\n      },\n      // 23.1.3.3 Map.prototype.delete(key)\n      // 23.2.3.4 Set.prototype.delete(value)\n      'delete': function (key) {\n        var that = validate(this, NAME);\n        var entry = getEntry(that, key);\n        if (entry) {\n          var next = entry.n;\n          var prev = entry.p;\n          delete that._i[entry.i];\n          entry.r = true;\n          if (prev) prev.n = next;\n          if (next) next.p = prev;\n          if (that._f == entry) that._f = next;\n          if (that._l == entry) that._l = prev;\n          that[SIZE]--;\n        } return !!entry;\n      },\n      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\n      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\n      forEach: function forEach(callbackfn /* , that = undefined */) {\n        validate(this, NAME);\n        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n        var entry;\n        while (entry = entry ? entry.n : this._f) {\n          f(entry.v, entry.k, this);\n          // revert to the last existing entry\n          while (entry && entry.r) entry = entry.p;\n        }\n      },\n      // 23.1.3.7 Map.prototype.has(key)\n      // 23.2.3.7 Set.prototype.has(value)\n      has: function has(key) {\n        return !!getEntry(validate(this, NAME), key);\n      }\n    });\n    if (DESCRIPTORS) dP(C.prototype, 'size', {\n      get: function () {\n        return validate(this, NAME)[SIZE];\n      }\n    });\n    return C;\n  },\n  def: function (that, key, value) {\n    var entry = getEntry(that, key);\n    var prev, index;\n    // change existing entry\n    if (entry) {\n      entry.v = value;\n    // create new entry\n    } else {\n      that._l = entry = {\n        i: index = fastKey(key, true), // <- index\n        k: key,                        // <- key\n        v: value,                      // <- value\n        p: prev = that._l,             // <- previous entry\n        n: undefined,                  // <- next entry\n        r: false                       // <- removed\n      };\n      if (!that._f) that._f = entry;\n      if (prev) prev.n = entry;\n      that[SIZE]++;\n      // add to index\n      if (index !== 'F') that._i[index] = entry;\n    } return that;\n  },\n  getEntry: getEntry,\n  setStrong: function (C, NAME, IS_MAP) {\n    // add .keys, .values, .entries, [@@iterator]\n    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\n    $iterDefine(C, NAME, function (iterated, kind) {\n      this._t = validate(iterated, NAME); // target\n      this._k = kind;                     // kind\n      this._l = undefined;                // previous\n    }, function () {\n      var that = this;\n      var kind = that._k;\n      var entry = that._l;\n      // revert to the last existing entry\n      while (entry && entry.r) entry = entry.p;\n      // get next entry\n      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {\n        // or finish the iteration\n        that._t = undefined;\n        return step(1);\n      }\n      // return step by kind\n      if (kind == 'keys') return step(0, entry.k);\n      if (kind == 'values') return step(0, entry.v);\n      return step(0, [entry.k, entry.v]);\n    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);\n\n    // add [@@species], 23.1.2.2, 23.2.2.2\n    setSpecies(NAME);\n  }\n};\n","'use strict';\nvar redefineAll = require('./_redefine-all');\nvar getWeak = require('./_meta').getWeak;\nvar anObject = require('./_an-object');\nvar isObject = require('./_is-object');\nvar anInstance = require('./_an-instance');\nvar forOf = require('./_for-of');\nvar createArrayMethod = require('./_array-methods');\nvar $has = require('./_has');\nvar validate = require('./_validate-collection');\nvar arrayFind = createArrayMethod(5);\nvar arrayFindIndex = createArrayMethod(6);\nvar id = 0;\n\n// fallback for uncaught frozen keys\nvar uncaughtFrozenStore = function (that) {\n  return that._l || (that._l = new UncaughtFrozenStore());\n};\nvar UncaughtFrozenStore = function () {\n  this.a = [];\n};\nvar findUncaughtFrozen = function (store, key) {\n  return arrayFind(store.a, function (it) {\n    return it[0] === key;\n  });\n};\nUncaughtFrozenStore.prototype = {\n  get: function (key) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) return entry[1];\n  },\n  has: function (key) {\n    return !!findUncaughtFrozen(this, key);\n  },\n  set: function (key, value) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) entry[1] = value;\n    else this.a.push([key, value]);\n  },\n  'delete': function (key) {\n    var index = arrayFindIndex(this.a, function (it) {\n      return it[0] === key;\n    });\n    if (~index) this.a.splice(index, 1);\n    return !!~index;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {\n    var C = wrapper(function (that, iterable) {\n      anInstance(that, C, NAME, '_i');\n      that._t = NAME;      // collection type\n      that._i = id++;      // collection id\n      that._l = undefined; // leak store for uncaught frozen objects\n      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.3.3.2 WeakMap.prototype.delete(key)\n      // 23.4.3.3 WeakSet.prototype.delete(value)\n      'delete': function (key) {\n        if (!isObject(key)) return false;\n        var data = getWeak(key);\n        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);\n        return data && $has(data, this._i) && delete data[this._i];\n      },\n      // 23.3.3.4 WeakMap.prototype.has(key)\n      // 23.4.3.4 WeakSet.prototype.has(value)\n      has: function has(key) {\n        if (!isObject(key)) return false;\n        var data = getWeak(key);\n        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);\n        return data && $has(data, this._i);\n      }\n    });\n    return C;\n  },\n  def: function (that, key, value) {\n    var data = getWeak(anObject(key), true);\n    if (data === true) uncaughtFrozenStore(that).set(key, value);\n    else data[that._i] = value;\n    return that;\n  },\n  ufstore: uncaughtFrozenStore\n};\n","'use strict';\nvar global = require('./_global');\nvar $export = require('./_export');\nvar redefine = require('./_redefine');\nvar redefineAll = require('./_redefine-all');\nvar meta = require('./_meta');\nvar forOf = require('./_for-of');\nvar anInstance = require('./_an-instance');\nvar isObject = require('./_is-object');\nvar fails = require('./_fails');\nvar $iterDetect = require('./_iter-detect');\nvar setToStringTag = require('./_set-to-string-tag');\nvar inheritIfRequired = require('./_inherit-if-required');\n\nmodule.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {\n  var Base = global[NAME];\n  var C = Base;\n  var ADDER = IS_MAP ? 'set' : 'add';\n  var proto = C && C.prototype;\n  var O = {};\n  var fixMethod = function (KEY) {\n    var fn = proto[KEY];\n    redefine(proto, KEY,\n      KEY == 'delete' ? function (a) {\n        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'has' ? function has(a) {\n        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'get' ? function get(a) {\n        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }\n        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }\n    );\n  };\n  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {\n    new C().entries().next();\n  }))) {\n    // create collection constructor\n    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);\n    redefineAll(C.prototype, methods);\n    meta.NEED = true;\n  } else {\n    var instance = new C();\n    // early implementations not supports chaining\n    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;\n    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false\n    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });\n    // most early implementations doesn't supports iterables, most modern - not close it correctly\n    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new\n    // for early implementations -0 and +0 not the same\n    var BUGGY_ZERO = !IS_WEAK && fails(function () {\n      // V8 ~ Chromium 42- fails only with 5+ elements\n      var $instance = new C();\n      var index = 5;\n      while (index--) $instance[ADDER](index, index);\n      return !$instance.has(-0);\n    });\n    if (!ACCEPT_ITERABLES) {\n      C = wrapper(function (target, iterable) {\n        anInstance(target, C, NAME);\n        var that = inheritIfRequired(new Base(), target, C);\n        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\n        return that;\n      });\n      C.prototype = proto;\n      proto.constructor = C;\n    }\n    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {\n      fixMethod('delete');\n      fixMethod('has');\n      IS_MAP && fixMethod('get');\n    }\n    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);\n    // weak collections should not contains .clear method\n    if (IS_WEAK && proto.clear) delete proto.clear;\n  }\n\n  setToStringTag(C, NAME);\n\n  O[NAME] = C;\n  $export($export.G + $export.W + $export.F * (C != Base), O);\n\n  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);\n\n  return C;\n};\n","var core = module.exports = { version: '2.5.7' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n","'use strict';\nvar $defineProperty = require('./_object-dp');\nvar createDesc = require('./_property-desc');\n\nmodule.exports = function (object, index, value) {\n  if (index in object) $defineProperty.f(object, index, createDesc(0, value));\n  else object[index] = value;\n};\n","// optional / simple context binding\nvar aFunction = require('./_a-function');\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./_fails')(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n","var isObject = require('./_is-object');\nvar document = require('./_global').document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n","// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n","// all enumerable object keys, includes symbols\nvar getKeys = require('./_object-keys');\nvar gOPS = require('./_object-gops');\nvar pIE = require('./_object-pie');\nmodule.exports = function (it) {\n  var result = getKeys(it);\n  var getSymbols = gOPS.f;\n  if (getSymbols) {\n    var symbols = getSymbols(it);\n    var isEnum = pIE.f;\n    var i = 0;\n    var key;\n    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);\n  } return result;\n};\n","var global = require('./_global');\nvar core = require('./_core');\nvar hide = require('./_hide');\nvar redefine = require('./_redefine');\nvar ctx = require('./_ctx');\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n  var key, own, out, exp;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    // export native or passed\n    out = (own ? target : source)[key];\n    // bind timers to global for call from export context\n    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // extend global\n    if (target) redefine(target, key, out, type & $export.U);\n    // export\n    if (exports[key] != out) hide(exports, key, exp);\n    if (IS_PROTO && expProto[key] != out) expProto[key] = out;\n  }\n};\nglobal.core = core;\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n","var MATCH = require('./_wks')('match');\nmodule.exports = function (KEY) {\n  var re = /./;\n  try {\n    '/./'[KEY](re);\n  } catch (e) {\n    try {\n      re[MATCH] = false;\n      return !'/./'[KEY](re);\n    } catch (f) { /* empty */ }\n  } return true;\n};\n","module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n","'use strict';\nvar hide = require('./_hide');\nvar redefine = require('./_redefine');\nvar fails = require('./_fails');\nvar defined = require('./_defined');\nvar wks = require('./_wks');\n\nmodule.exports = function (KEY, length, exec) {\n  var SYMBOL = wks(KEY);\n  var fns = exec(defined, SYMBOL, ''[KEY]);\n  var strfn = fns[0];\n  var rxfn = fns[1];\n  if (fails(function () {\n    var O = {};\n    O[SYMBOL] = function () { return 7; };\n    return ''[KEY](O) != 7;\n  })) {\n    redefine(String.prototype, KEY, strfn);\n    hide(RegExp.prototype, SYMBOL, length == 2\n      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)\n      // 21.2.5.11 RegExp.prototype[@@split](string, limit)\n      ? function (string, arg) { return rxfn.call(string, this, arg); }\n      // 21.2.5.6 RegExp.prototype[@@match](string)\n      // 21.2.5.9 RegExp.prototype[@@search](string)\n      : function (string) { return rxfn.call(string, this); }\n    );\n  }\n};\n","'use strict';\n// 21.2.5.3 get RegExp.prototype.flags\nvar anObject = require('./_an-object');\nmodule.exports = function () {\n  var that = anObject(this);\n  var result = '';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.unicode) result += 'u';\n  if (that.sticky) result += 'y';\n  return result;\n};\n","var ctx = require('./_ctx');\nvar call = require('./_iter-call');\nvar isArrayIter = require('./_is-array-iter');\nvar anObject = require('./_an-object');\nvar toLength = require('./_to-length');\nvar getIterFn = require('./core.get-iterator-method');\nvar BREAK = {};\nvar RETURN = {};\nvar exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {\n  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);\n  var f = ctx(fn, that, entries ? 2 : 1);\n  var index = 0;\n  var length, step, iterator, result;\n  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {\n    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n    if (result === BREAK || result === RETURN) return result;\n  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {\n    result = call(iterator, f, step.value, entries);\n    if (result === BREAK || result === RETURN) return result;\n  }\n};\nexports.BREAK = BREAK;\nexports.RETURN = RETURN;\n","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n","var dP = require('./_object-dp');\nvar createDesc = require('./_property-desc');\nmodule.exports = require('./_descriptors') ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n","var document = require('./_global').document;\nmodule.exports = document && document.documentElement;\n","module.exports = !require('./_descriptors') && !require('./_fails')(function () {\n  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n","var isObject = require('./_is-object');\nvar setPrototypeOf = require('./_set-proto').set;\nmodule.exports = function (that, target, C) {\n  var S = target.constructor;\n  var P;\n  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {\n    setPrototypeOf(that, P);\n  } return that;\n};\n","// fast apply, http://jsperf.lnkit.com/fast-apply/5\nmodule.exports = function (fn, args, that) {\n  var un = that === undefined;\n  switch (args.length) {\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n  } return fn.apply(that, args);\n};\n","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./_cof');\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n","// check on default Array iterator\nvar Iterators = require('./_iterators');\nvar ITERATOR = require('./_wks')('iterator');\nvar ArrayProto = Array.prototype;\n\nmodule.exports = function (it) {\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};\n","// 7.2.2 IsArray(argument)\nvar cof = require('./_cof');\nmodule.exports = Array.isArray || function isArray(arg) {\n  return cof(arg) == 'Array';\n};\n","// 20.1.2.3 Number.isInteger(number)\nvar isObject = require('./_is-object');\nvar floor = Math.floor;\nmodule.exports = function isInteger(it) {\n  return !isObject(it) && isFinite(it) && floor(it) === it;\n};\n","module.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n","// 7.2.8 IsRegExp(argument)\nvar isObject = require('./_is-object');\nvar cof = require('./_cof');\nvar MATCH = require('./_wks')('match');\nmodule.exports = function (it) {\n  var isRegExp;\n  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');\n};\n","// call something on iterator step with safe closing on error\nvar anObject = require('./_an-object');\nmodule.exports = function (iterator, fn, value, entries) {\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch (e) {\n    var ret = iterator['return'];\n    if (ret !== undefined) anObject(ret.call(iterator));\n    throw e;\n  }\n};\n","'use strict';\nvar create = require('./_object-create');\nvar descriptor = require('./_property-desc');\nvar setToStringTag = require('./_set-to-string-tag');\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nrequire('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });\n\nmodule.exports = function (Constructor, NAME, next) {\n  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n","'use strict';\nvar LIBRARY = require('./_library');\nvar $export = require('./_export');\nvar redefine = require('./_redefine');\nvar hide = require('./_hide');\nvar Iterators = require('./_iterators');\nvar $iterCreate = require('./_iter-create');\nvar setToStringTag = require('./_set-to-string-tag');\nvar getPrototypeOf = require('./_object-gpo');\nvar ITERATOR = require('./_wks')('iterator');\nvar BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\nvar FF_ITERATOR = '@@iterator';\nvar KEYS = 'keys';\nvar VALUES = 'values';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function (kind) {\n    if (!BUGGY && kind in proto) return proto[kind];\n    switch (kind) {\n      case KEYS: return function keys() { return new Constructor(this, kind); };\n      case VALUES: return function values() { return new Constructor(this, kind); };\n    } return function entries() { return new Constructor(this, kind); };\n  };\n  var TAG = NAME + ' Iterator';\n  var DEF_VALUES = DEFAULT == VALUES;\n  var VALUES_BUG = false;\n  var proto = Base.prototype;\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n  var $default = $native || getMethod(DEFAULT);\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n  var methods, key, IteratorPrototype;\n  // Fix native\n  if ($anyNative) {\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\n    VALUES_BUG = true;\n    $default = function values() { return $native.call(this); };\n  }\n  // Define iterator\n  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG] = returnThis;\n  if (DEFAULT) {\n    methods = {\n      values: DEF_VALUES ? $default : getMethod(VALUES),\n      keys: IS_SET ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if (FORCED) for (key in methods) {\n      if (!(key in proto)) redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n","var ITERATOR = require('./_wks')('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR]();\n  riter['return'] = function () { SAFE_CLOSING = true; };\n  // eslint-disable-next-line no-throw-literal\n  Array.from(riter, function () { throw 2; });\n} catch (e) { /* empty */ }\n\nmodule.exports = function (exec, skipClosing) {\n  if (!skipClosing && !SAFE_CLOSING) return false;\n  var safe = false;\n  try {\n    var arr = [7];\n    var iter = arr[ITERATOR]();\n    iter.next = function () { return { done: safe = true }; };\n    arr[ITERATOR] = function () { return iter; };\n    exec(arr);\n  } catch (e) { /* empty */ }\n  return safe;\n};\n","module.exports = function (done, value) {\n  return { value: value, done: !!done };\n};\n","module.exports = {};\n","module.exports = false;\n","// 20.2.2.14 Math.expm1(x)\nvar $expm1 = Math.expm1;\nmodule.exports = (!$expm1\n  // Old FF bug\n  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168\n  // Tor Browser bug\n  || $expm1(-2e-17) != -2e-17\n) ? function expm1(x) {\n  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;\n} : $expm1;\n","// 20.2.2.16 Math.fround(x)\nvar sign = require('./_math-sign');\nvar pow = Math.pow;\nvar EPSILON = pow(2, -52);\nvar EPSILON32 = pow(2, -23);\nvar MAX32 = pow(2, 127) * (2 - EPSILON32);\nvar MIN32 = pow(2, -126);\n\nvar roundTiesToEven = function (n) {\n  return n + 1 / EPSILON - 1 / EPSILON;\n};\n\nmodule.exports = Math.fround || function fround(x) {\n  var $abs = Math.abs(x);\n  var $sign = sign(x);\n  var a, result;\n  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;\n  a = (1 + EPSILON32 / EPSILON) * $abs;\n  result = a - (a - $abs);\n  // eslint-disable-next-line no-self-compare\n  if (result > MAX32 || result != result) return $sign * Infinity;\n  return $sign * result;\n};\n","// 20.2.2.20 Math.log1p(x)\nmodule.exports = Math.log1p || function log1p(x) {\n  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);\n};\n","// 20.2.2.28 Math.sign(x)\nmodule.exports = Math.sign || function sign(x) {\n  // eslint-disable-next-line no-self-compare\n  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;\n};\n","var META = require('./_uid')('meta');\nvar isObject = require('./_is-object');\nvar has = require('./_has');\nvar setDesc = require('./_object-dp').f;\nvar id = 0;\nvar isExtensible = Object.isExtensible || function () {\n  return true;\n};\nvar FREEZE = !require('./_fails')(function () {\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function (it) {\n  setDesc(it, META, { value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  } });\n};\nvar fastKey = function (it, create) {\n  // return primitive with prefix\n  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return 'F';\n    // not necessary to add metadata\n    if (!create) return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function (it, create) {\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return true;\n    // not necessary to add metadata\n    if (!create) return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function (it) {\n  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY: META,\n  NEED: false,\n  fastKey: fastKey,\n  getWeak: getWeak,\n  onFreeze: onFreeze\n};\n","var global = require('./_global');\nvar macrotask = require('./_task').set;\nvar Observer = global.MutationObserver || global.WebKitMutationObserver;\nvar process = global.process;\nvar Promise = global.Promise;\nvar isNode = require('./_cof')(process) == 'process';\n\nmodule.exports = function () {\n  var head, last, notify;\n\n  var flush = function () {\n    var parent, fn;\n    if (isNode && (parent = process.domain)) parent.exit();\n    while (head) {\n      fn = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch (e) {\n        if (head) notify();\n        else last = undefined;\n        throw e;\n      }\n    } last = undefined;\n    if (parent) parent.enter();\n  };\n\n  // Node.js\n  if (isNode) {\n    notify = function () {\n      process.nextTick(flush);\n    };\n  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339\n  } else if (Observer && !(global.navigator && global.navigator.standalone)) {\n    var toggle = true;\n    var node = document.createTextNode('');\n    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new\n    notify = function () {\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if (Promise && Promise.resolve) {\n    // Promise.resolve without an argument throws an error in LG WebOS 2\n    var promise = Promise.resolve(undefined);\n    notify = function () {\n      promise.then(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessag\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    notify = function () {\n      // strange IE + webpack dev server bug - use .call(global)\n      macrotask.call(global, flush);\n    };\n  }\n\n  return function (fn) {\n    var task = { fn: fn, next: undefined };\n    if (last) last.next = task;\n    if (!head) {\n      head = task;\n      notify();\n    } last = task;\n  };\n};\n","'use strict';\n// 25.4.1.5 NewPromiseCapability(C)\nvar aFunction = require('./_a-function');\n\nfunction PromiseCapability(C) {\n  var resolve, reject;\n  this.promise = new C(function ($$resolve, $$reject) {\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject = $$reject;\n  });\n  this.resolve = aFunction(resolve);\n  this.reject = aFunction(reject);\n}\n\nmodule.exports.f = function (C) {\n  return new PromiseCapability(C);\n};\n","'use strict';\n// 19.1.2.1 Object.assign(target, source, ...)\nvar getKeys = require('./_object-keys');\nvar gOPS = require('./_object-gops');\nvar pIE = require('./_object-pie');\nvar toObject = require('./_to-object');\nvar IObject = require('./_iobject');\nvar $assign = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nmodule.exports = !$assign || require('./_fails')(function () {\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line no-undef\n  var S = Symbol();\n  var K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function (k) { B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars\n  var T = toObject(target);\n  var aLen = arguments.length;\n  var index = 1;\n  var getSymbols = gOPS.f;\n  var isEnum = pIE.f;\n  while (aLen > index) {\n    var S = IObject(arguments[index++]);\n    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];\n  } return T;\n} : $assign;\n","// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject = require('./_an-object');\nvar dPs = require('./_object-dps');\nvar enumBugKeys = require('./_enum-bug-keys');\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\nvar Empty = function () { /* empty */ };\nvar PROTOTYPE = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = require('./_dom-create')('iframe');\n  var i = enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  require('./_html').appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n","var anObject = require('./_an-object');\nvar IE8_DOM_DEFINE = require('./_ie8-dom-define');\nvar toPrimitive = require('./_to-primitive');\nvar dP = Object.defineProperty;\n\nexports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n","var dP = require('./_object-dp');\nvar anObject = require('./_an-object');\nvar getKeys = require('./_object-keys');\n\nmodule.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = getKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n","var pIE = require('./_object-pie');\nvar createDesc = require('./_property-desc');\nvar toIObject = require('./_to-iobject');\nvar toPrimitive = require('./_to-primitive');\nvar has = require('./_has');\nvar IE8_DOM_DEFINE = require('./_ie8-dom-define');\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nexports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return gOPD(O, P);\n  } catch (e) { /* empty */ }\n  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);\n};\n","// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar toIObject = require('./_to-iobject');\nvar gOPN = require('./_object-gopn').f;\nvar toString = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function (it) {\n  try {\n    return gOPN(it);\n  } catch (e) {\n    return windowNames.slice();\n  }\n};\n\nmodule.exports.f = function getOwnPropertyNames(it) {\n  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n};\n","// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar $keys = require('./_object-keys-internal');\nvar hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return $keys(O, hiddenKeys);\n};\n","exports.f = Object.getOwnPropertySymbols;\n","// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has = require('./_has');\nvar toObject = require('./_to-object');\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n","var has = require('./_has');\nvar toIObject = require('./_to-iobject');\nvar arrayIndexOf = require('./_array-includes')(false);\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n","// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = require('./_object-keys-internal');\nvar enumBugKeys = require('./_enum-bug-keys');\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n","exports.f = {}.propertyIsEnumerable;\n","// most Object methods by ES6 should accept primitives\nvar $export = require('./_export');\nvar core = require('./_core');\nvar fails = require('./_fails');\nmodule.exports = function (KEY, exec) {\n  var fn = (core.Object || {})[KEY] || Object[KEY];\n  var exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);\n};\n","var getKeys = require('./_object-keys');\nvar toIObject = require('./_to-iobject');\nvar isEnum = require('./_object-pie').f;\nmodule.exports = function (isEntries) {\n  return function (it) {\n    var O = toIObject(it);\n    var keys = getKeys(O);\n    var length = keys.length;\n    var i = 0;\n    var result = [];\n    var key;\n    while (length > i) if (isEnum.call(O, key = keys[i++])) {\n      result.push(isEntries ? [key, O[key]] : O[key]);\n    } return result;\n  };\n};\n","// all object keys, includes non-enumerable and symbols\nvar gOPN = require('./_object-gopn');\nvar gOPS = require('./_object-gops');\nvar anObject = require('./_an-object');\nvar Reflect = require('./_global').Reflect;\nmodule.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {\n  var keys = gOPN.f(anObject(it));\n  var getSymbols = gOPS.f;\n  return getSymbols ? keys.concat(getSymbols(it)) : keys;\n};\n","module.exports = function (exec) {\n  try {\n    return { e: false, v: exec() };\n  } catch (e) {\n    return { e: true, v: e };\n  }\n};\n","var anObject = require('./_an-object');\nvar isObject = require('./_is-object');\nvar newPromiseCapability = require('./_new-promise-capability');\n\nmodule.exports = function (C, x) {\n  anObject(C);\n  if (isObject(x) && x.constructor === C) return x;\n  var promiseCapability = newPromiseCapability.f(C);\n  var resolve = promiseCapability.resolve;\n  resolve(x);\n  return promiseCapability.promise;\n};\n","module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n","var redefine = require('./_redefine');\nmodule.exports = function (target, src, safe) {\n  for (var key in src) redefine(target, key, src[key], safe);\n  return target;\n};\n","var global = require('./_global');\nvar hide = require('./_hide');\nvar has = require('./_has');\nvar SRC = require('./_uid')('src');\nvar TO_STRING = 'toString';\nvar $toString = Function[TO_STRING];\nvar TPL = ('' + $toString).split(TO_STRING);\n\nrequire('./_core').inspectSource = function (it) {\n  return $toString.call(it);\n};\n\n(module.exports = function (O, key, val, safe) {\n  var isFunction = typeof val == 'function';\n  if (isFunction) has(val, 'name') || hide(val, 'name', key);\n  if (O[key] === val) return;\n  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n  if (O === global) {\n    O[key] = val;\n  } else if (!safe) {\n    delete O[key];\n    hide(O, key, val);\n  } else if (O[key]) {\n    O[key] = val;\n  } else {\n    hide(O, key, val);\n  }\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, TO_STRING, function toString() {\n  return typeof this == 'function' && this[SRC] || $toString.call(this);\n});\n","// 7.2.9 SameValue(x, y)\nmodule.exports = Object.is || function is(x, y) {\n  // eslint-disable-next-line no-self-compare\n  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;\n};\n","// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\nvar isObject = require('./_is-object');\nvar anObject = require('./_an-object');\nvar check = function (O, proto) {\n  anObject(O);\n  if (!isObject(proto) && proto !== null) throw TypeError(proto + \": can't set as prototype!\");\n};\nmodule.exports = {\n  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n    function (test, buggy, set) {\n      try {\n        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);\n        set(test, []);\n        buggy = !(test instanceof Array);\n      } catch (e) { buggy = true; }\n      return function setPrototypeOf(O, proto) {\n        check(O, proto);\n        if (buggy) O.__proto__ = proto;\n        else set(O, proto);\n        return O;\n      };\n    }({}, false) : undefined),\n  check: check\n};\n","'use strict';\nvar global = require('./_global');\nvar dP = require('./_object-dp');\nvar DESCRIPTORS = require('./_descriptors');\nvar SPECIES = require('./_wks')('species');\n\nmodule.exports = function (KEY) {\n  var C = global[KEY];\n  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {\n    configurable: true,\n    get: function () { return this; }\n  });\n};\n","var def = require('./_object-dp').f;\nvar has = require('./_has');\nvar TAG = require('./_wks')('toStringTag');\n\nmodule.exports = function (it, tag, stat) {\n  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\n};\n","var shared = require('./_shared')('keys');\nvar uid = require('./_uid');\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n","var core = require('./_core');\nvar global = require('./_global');\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: core.version,\n  mode: require('./_library') ? 'pure' : 'global',\n  copyright: ' 2018 Denis Pushkarev (zloirock.ru)'\n});\n","// 7.3.20 SpeciesConstructor(O, defaultConstructor)\nvar anObject = require('./_an-object');\nvar aFunction = require('./_a-function');\nvar SPECIES = require('./_wks')('species');\nmodule.exports = function (O, D) {\n  var C = anObject(O).constructor;\n  var S;\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n};\n","var toInteger = require('./_to-integer');\nvar defined = require('./_defined');\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function (TO_STRING) {\n  return function (that, pos) {\n    var s = String(defined(that));\n    var i = toInteger(pos);\n    var l = s.length;\n    var a, b;\n    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n","// helper for String#{startsWith, endsWith, includes}\nvar isRegExp = require('./_is-regexp');\nvar defined = require('./_defined');\n\nmodule.exports = function (that, searchString, NAME) {\n  if (isRegExp(searchString)) throw TypeError('String#' + NAME + \" doesn't accept regex!\");\n  return String(defined(that));\n};\n","// https://github.com/tc39/proposal-string-pad-start-end\nvar toLength = require('./_to-length');\nvar repeat = require('./_string-repeat');\nvar defined = require('./_defined');\n\nmodule.exports = function (that, maxLength, fillString, left) {\n  var S = String(defined(that));\n  var stringLength = S.length;\n  var fillStr = fillString === undefined ? ' ' : String(fillString);\n  var intMaxLength = toLength(maxLength);\n  if (intMaxLength <= stringLength || fillStr == '') return S;\n  var fillLen = intMaxLength - stringLength;\n  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));\n  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);\n  return left ? stringFiller + S : S + stringFiller;\n};\n","'use strict';\nvar toInteger = require('./_to-integer');\nvar defined = require('./_defined');\n\nmodule.exports = function repeat(count) {\n  var str = String(defined(this));\n  var res = '';\n  var n = toInteger(count);\n  if (n < 0 || n == Infinity) throw RangeError(\"Count can't be negative\");\n  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;\n  return res;\n};\n","var ctx = require('./_ctx');\nvar invoke = require('./_invoke');\nvar html = require('./_html');\nvar cel = require('./_dom-create');\nvar global = require('./_global');\nvar process = global.process;\nvar setTask = global.setImmediate;\nvar clearTask = global.clearImmediate;\nvar MessageChannel = global.MessageChannel;\nvar Dispatch = global.Dispatch;\nvar counter = 0;\nvar queue = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar defer, channel, port;\nvar run = function () {\n  var id = +this;\n  // eslint-disable-next-line no-prototype-builtins\n  if (queue.hasOwnProperty(id)) {\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\nvar listener = function (event) {\n  run.call(event.data);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!setTask || !clearTask) {\n  setTask = function setImmediate(fn) {\n    var args = [];\n    var i = 1;\n    while (arguments.length > i) args.push(arguments[i++]);\n    queue[++counter] = function () {\n      // eslint-disable-next-line no-new-func\n      invoke(typeof fn == 'function' ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function clearImmediate(id) {\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if (require('./_cof')(process) == 'process') {\n    defer = function (id) {\n      process.nextTick(ctx(run, id, 1));\n    };\n  // Sphere (JS game engine) Dispatch API\n  } else if (Dispatch && Dispatch.now) {\n    defer = function (id) {\n      Dispatch.now(ctx(run, id, 1));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  } else if (MessageChannel) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = ctx(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {\n    defer = function (id) {\n      global.postMessage(id + '', '*');\n    };\n    global.addEventListener('message', listener, false);\n  // IE8-\n  } else if (ONREADYSTATECHANGE in cel('script')) {\n    defer = function (id) {\n      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {\n        html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function (id) {\n      setTimeout(ctx(run, id, 1), 0);\n    };\n  }\n}\nmodule.exports = {\n  set: setTask,\n  clear: clearTask\n};\n","var toInteger = require('./_to-integer');\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n","// https://tc39.github.io/ecma262/#sec-toindex\nvar toInteger = require('./_to-integer');\nvar toLength = require('./_to-length');\nmodule.exports = function (it) {\n  if (it === undefined) return 0;\n  var number = toInteger(it);\n  var length = toLength(number);\n  if (number !== length) throw RangeError('Wrong length!');\n  return length;\n};\n","// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./_iobject');\nvar defined = require('./_defined');\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n","// 7.1.15 ToLength\nvar toInteger = require('./_to-integer');\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n","// 7.1.13 ToObject(argument)\nvar defined = require('./_defined');\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n","// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('./_is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n","'use strict';\nif (require('./_descriptors')) {\n  var LIBRARY = require('./_library');\n  var global = require('./_global');\n  var fails = require('./_fails');\n  var $export = require('./_export');\n  var $typed = require('./_typed');\n  var $buffer = require('./_typed-buffer');\n  var ctx = require('./_ctx');\n  var anInstance = require('./_an-instance');\n  var propertyDesc = require('./_property-desc');\n  var hide = require('./_hide');\n  var redefineAll = require('./_redefine-all');\n  var toInteger = require('./_to-integer');\n  var toLength = require('./_to-length');\n  var toIndex = require('./_to-index');\n  var toAbsoluteIndex = require('./_to-absolute-index');\n  var toPrimitive = require('./_to-primitive');\n  var has = require('./_has');\n  var classof = require('./_classof');\n  var isObject = require('./_is-object');\n  var toObject = require('./_to-object');\n  var isArrayIter = require('./_is-array-iter');\n  var create = require('./_object-create');\n  var getPrototypeOf = require('./_object-gpo');\n  var gOPN = require('./_object-gopn').f;\n  var getIterFn = require('./core.get-iterator-method');\n  var uid = require('./_uid');\n  var wks = require('./_wks');\n  var createArrayMethod = require('./_array-methods');\n  var createArrayIncludes = require('./_array-includes');\n  var speciesConstructor = require('./_species-constructor');\n  var ArrayIterators = require('./es6.array.iterator');\n  var Iterators = require('./_iterators');\n  var $iterDetect = require('./_iter-detect');\n  var setSpecies = require('./_set-species');\n  var arrayFill = require('./_array-fill');\n  var arrayCopyWithin = require('./_array-copy-within');\n  var $DP = require('./_object-dp');\n  var $GOPD = require('./_object-gopd');\n  var dP = $DP.f;\n  var gOPD = $GOPD.f;\n  var RangeError = global.RangeError;\n  var TypeError = global.TypeError;\n  var Uint8Array = global.Uint8Array;\n  var ARRAY_BUFFER = 'ArrayBuffer';\n  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;\n  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';\n  var PROTOTYPE = 'prototype';\n  var ArrayProto = Array[PROTOTYPE];\n  var $ArrayBuffer = $buffer.ArrayBuffer;\n  var $DataView = $buffer.DataView;\n  var arrayForEach = createArrayMethod(0);\n  var arrayFilter = createArrayMethod(2);\n  var arraySome = createArrayMethod(3);\n  var arrayEvery = createArrayMethod(4);\n  var arrayFind = createArrayMethod(5);\n  var arrayFindIndex = createArrayMethod(6);\n  var arrayIncludes = createArrayIncludes(true);\n  var arrayIndexOf = createArrayIncludes(false);\n  var arrayValues = ArrayIterators.values;\n  var arrayKeys = ArrayIterators.keys;\n  var arrayEntries = ArrayIterators.entries;\n  var arrayLastIndexOf = ArrayProto.lastIndexOf;\n  var arrayReduce = ArrayProto.reduce;\n  var arrayReduceRight = ArrayProto.reduceRight;\n  var arrayJoin = ArrayProto.join;\n  var arraySort = ArrayProto.sort;\n  var arraySlice = ArrayProto.slice;\n  var arrayToString = ArrayProto.toString;\n  var arrayToLocaleString = ArrayProto.toLocaleString;\n  var ITERATOR = wks('iterator');\n  var TAG = wks('toStringTag');\n  var TYPED_CONSTRUCTOR = uid('typed_constructor');\n  var DEF_CONSTRUCTOR = uid('def_constructor');\n  var ALL_CONSTRUCTORS = $typed.CONSTR;\n  var TYPED_ARRAY = $typed.TYPED;\n  var VIEW = $typed.VIEW;\n  var WRONG_LENGTH = 'Wrong length!';\n\n  var $map = createArrayMethod(1, function (O, length) {\n    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);\n  });\n\n  var LITTLE_ENDIAN = fails(function () {\n    // eslint-disable-next-line no-undef\n    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;\n  });\n\n  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {\n    new Uint8Array(1).set({});\n  });\n\n  var toOffset = function (it, BYTES) {\n    var offset = toInteger(it);\n    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');\n    return offset;\n  };\n\n  var validate = function (it) {\n    if (isObject(it) && TYPED_ARRAY in it) return it;\n    throw TypeError(it + ' is not a typed array!');\n  };\n\n  var allocate = function (C, length) {\n    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {\n      throw TypeError('It is not a typed array constructor!');\n    } return new C(length);\n  };\n\n  var speciesFromList = function (O, list) {\n    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);\n  };\n\n  var fromList = function (C, list) {\n    var index = 0;\n    var length = list.length;\n    var result = allocate(C, length);\n    while (length > index) result[index] = list[index++];\n    return result;\n  };\n\n  var addGetter = function (it, key, internal) {\n    dP(it, key, { get: function () { return this._d[internal]; } });\n  };\n\n  var $from = function from(source /* , mapfn, thisArg */) {\n    var O = toObject(source);\n    var aLen = arguments.length;\n    var mapfn = aLen > 1 ? arguments[1] : undefined;\n    var mapping = mapfn !== undefined;\n    var iterFn = getIterFn(O);\n    var i, length, values, result, step, iterator;\n    if (iterFn != undefined && !isArrayIter(iterFn)) {\n      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {\n        values.push(step.value);\n      } O = values;\n    }\n    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);\n    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {\n      result[i] = mapping ? mapfn(O[i], i) : O[i];\n    }\n    return result;\n  };\n\n  var $of = function of(/* ...items */) {\n    var index = 0;\n    var length = arguments.length;\n    var result = allocate(this, length);\n    while (length > index) result[index] = arguments[index++];\n    return result;\n  };\n\n  // iOS Safari 6.x fails here\n  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });\n\n  var $toLocaleString = function toLocaleString() {\n    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);\n  };\n\n  var proto = {\n    copyWithin: function copyWithin(target, start /* , end */) {\n      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    every: function every(callbackfn /* , thisArg */) {\n      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars\n      return arrayFill.apply(validate(this), arguments);\n    },\n    filter: function filter(callbackfn /* , thisArg */) {\n      return speciesFromList(this, arrayFilter(validate(this), callbackfn,\n        arguments.length > 1 ? arguments[1] : undefined));\n    },\n    find: function find(predicate /* , thisArg */) {\n      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    findIndex: function findIndex(predicate /* , thisArg */) {\n      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    forEach: function forEach(callbackfn /* , thisArg */) {\n      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    indexOf: function indexOf(searchElement /* , fromIndex */) {\n      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    includes: function includes(searchElement /* , fromIndex */) {\n      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    join: function join(separator) { // eslint-disable-line no-unused-vars\n      return arrayJoin.apply(validate(this), arguments);\n    },\n    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars\n      return arrayLastIndexOf.apply(validate(this), arguments);\n    },\n    map: function map(mapfn /* , thisArg */) {\n      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars\n      return arrayReduce.apply(validate(this), arguments);\n    },\n    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars\n      return arrayReduceRight.apply(validate(this), arguments);\n    },\n    reverse: function reverse() {\n      var that = this;\n      var length = validate(that).length;\n      var middle = Math.floor(length / 2);\n      var index = 0;\n      var value;\n      while (index < middle) {\n        value = that[index];\n        that[index++] = that[--length];\n        that[length] = value;\n      } return that;\n    },\n    some: function some(callbackfn /* , thisArg */) {\n      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    sort: function sort(comparefn) {\n      return arraySort.call(validate(this), comparefn);\n    },\n    subarray: function subarray(begin, end) {\n      var O = validate(this);\n      var length = O.length;\n      var $begin = toAbsoluteIndex(begin, length);\n      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(\n        O.buffer,\n        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,\n        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)\n      );\n    }\n  };\n\n  var $slice = function slice(start, end) {\n    return speciesFromList(this, arraySlice.call(validate(this), start, end));\n  };\n\n  var $set = function set(arrayLike /* , offset */) {\n    validate(this);\n    var offset = toOffset(arguments[1], 1);\n    var length = this.length;\n    var src = toObject(arrayLike);\n    var len = toLength(src.length);\n    var index = 0;\n    if (len + offset > length) throw RangeError(WRONG_LENGTH);\n    while (index < len) this[offset + index] = src[index++];\n  };\n\n  var $iterators = {\n    entries: function entries() {\n      return arrayEntries.call(validate(this));\n    },\n    keys: function keys() {\n      return arrayKeys.call(validate(this));\n    },\n    values: function values() {\n      return arrayValues.call(validate(this));\n    }\n  };\n\n  var isTAIndex = function (target, key) {\n    return isObject(target)\n      && target[TYPED_ARRAY]\n      && typeof key != 'symbol'\n      && key in target\n      && String(+key) == String(key);\n  };\n  var $getDesc = function getOwnPropertyDescriptor(target, key) {\n    return isTAIndex(target, key = toPrimitive(key, true))\n      ? propertyDesc(2, target[key])\n      : gOPD(target, key);\n  };\n  var $setDesc = function defineProperty(target, key, desc) {\n    if (isTAIndex(target, key = toPrimitive(key, true))\n      && isObject(desc)\n      && has(desc, 'value')\n      && !has(desc, 'get')\n      && !has(desc, 'set')\n      // TODO: add validation descriptor w/o calling accessors\n      && !desc.configurable\n      && (!has(desc, 'writable') || desc.writable)\n      && (!has(desc, 'enumerable') || desc.enumerable)\n    ) {\n      target[key] = desc.value;\n      return target;\n    } return dP(target, key, desc);\n  };\n\n  if (!ALL_CONSTRUCTORS) {\n    $GOPD.f = $getDesc;\n    $DP.f = $setDesc;\n  }\n\n  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {\n    getOwnPropertyDescriptor: $getDesc,\n    defineProperty: $setDesc\n  });\n\n  if (fails(function () { arrayToString.call({}); })) {\n    arrayToString = arrayToLocaleString = function toString() {\n      return arrayJoin.call(this);\n    };\n  }\n\n  var $TypedArrayPrototype$ = redefineAll({}, proto);\n  redefineAll($TypedArrayPrototype$, $iterators);\n  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);\n  redefineAll($TypedArrayPrototype$, {\n    slice: $slice,\n    set: $set,\n    constructor: function () { /* noop */ },\n    toString: arrayToString,\n    toLocaleString: $toLocaleString\n  });\n  addGetter($TypedArrayPrototype$, 'buffer', 'b');\n  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');\n  addGetter($TypedArrayPrototype$, 'byteLength', 'l');\n  addGetter($TypedArrayPrototype$, 'length', 'e');\n  dP($TypedArrayPrototype$, TAG, {\n    get: function () { return this[TYPED_ARRAY]; }\n  });\n\n  // eslint-disable-next-line max-statements\n  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {\n    CLAMPED = !!CLAMPED;\n    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';\n    var GETTER = 'get' + KEY;\n    var SETTER = 'set' + KEY;\n    var TypedArray = global[NAME];\n    var Base = TypedArray || {};\n    var TAC = TypedArray && getPrototypeOf(TypedArray);\n    var FORCED = !TypedArray || !$typed.ABV;\n    var O = {};\n    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];\n    var getter = function (that, index) {\n      var data = that._d;\n      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);\n    };\n    var setter = function (that, index, value) {\n      var data = that._d;\n      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;\n      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);\n    };\n    var addElement = function (that, index) {\n      dP(that, index, {\n        get: function () {\n          return getter(this, index);\n        },\n        set: function (value) {\n          return setter(this, index, value);\n        },\n        enumerable: true\n      });\n    };\n    if (FORCED) {\n      TypedArray = wrapper(function (that, data, $offset, $length) {\n        anInstance(that, TypedArray, NAME, '_d');\n        var index = 0;\n        var offset = 0;\n        var buffer, byteLength, length, klass;\n        if (!isObject(data)) {\n          length = toIndex(data);\n          byteLength = length * BYTES;\n          buffer = new $ArrayBuffer(byteLength);\n        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {\n          buffer = data;\n          offset = toOffset($offset, BYTES);\n          var $len = data.byteLength;\n          if ($length === undefined) {\n            if ($len % BYTES) throw RangeError(WRONG_LENGTH);\n            byteLength = $len - offset;\n            if (byteLength < 0) throw RangeError(WRONG_LENGTH);\n          } else {\n            byteLength = toLength($length) * BYTES;\n            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);\n          }\n          length = byteLength / BYTES;\n        } else if (TYPED_ARRAY in data) {\n          return fromList(TypedArray, data);\n        } else {\n          return $from.call(TypedArray, data);\n        }\n        hide(that, '_d', {\n          b: buffer,\n          o: offset,\n          l: byteLength,\n          e: length,\n          v: new $DataView(buffer)\n        });\n        while (index < length) addElement(that, index++);\n      });\n      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);\n      hide(TypedArrayPrototype, 'constructor', TypedArray);\n    } else if (!fails(function () {\n      TypedArray(1);\n    }) || !fails(function () {\n      new TypedArray(-1); // eslint-disable-line no-new\n    }) || !$iterDetect(function (iter) {\n      new TypedArray(); // eslint-disable-line no-new\n      new TypedArray(null); // eslint-disable-line no-new\n      new TypedArray(1.5); // eslint-disable-line no-new\n      new TypedArray(iter); // eslint-disable-line no-new\n    }, true)) {\n      TypedArray = wrapper(function (that, data, $offset, $length) {\n        anInstance(that, TypedArray, NAME);\n        var klass;\n        // `ws` module bug, temporarily remove validation length for Uint8Array\n        // https://github.com/websockets/ws/pull/645\n        if (!isObject(data)) return new Base(toIndex(data));\n        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {\n          return $length !== undefined\n            ? new Base(data, toOffset($offset, BYTES), $length)\n            : $offset !== undefined\n              ? new Base(data, toOffset($offset, BYTES))\n              : new Base(data);\n        }\n        if (TYPED_ARRAY in data) return fromList(TypedArray, data);\n        return $from.call(TypedArray, data);\n      });\n      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {\n        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);\n      });\n      TypedArray[PROTOTYPE] = TypedArrayPrototype;\n      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;\n    }\n    var $nativeIterator = TypedArrayPrototype[ITERATOR];\n    var CORRECT_ITER_NAME = !!$nativeIterator\n      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);\n    var $iterator = $iterators.values;\n    hide(TypedArray, TYPED_CONSTRUCTOR, true);\n    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);\n    hide(TypedArrayPrototype, VIEW, true);\n    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);\n\n    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {\n      dP(TypedArrayPrototype, TAG, {\n        get: function () { return NAME; }\n      });\n    }\n\n    O[NAME] = TypedArray;\n\n    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);\n\n    $export($export.S, NAME, {\n      BYTES_PER_ELEMENT: BYTES\n    });\n\n    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {\n      from: $from,\n      of: $of\n    });\n\n    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);\n\n    $export($export.P, NAME, proto);\n\n    setSpecies(NAME);\n\n    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });\n\n    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);\n\n    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;\n\n    $export($export.P + $export.F * fails(function () {\n      new TypedArray(1).slice();\n    }), NAME, { slice: $slice });\n\n    $export($export.P + $export.F * (fails(function () {\n      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();\n    }) || !fails(function () {\n      TypedArrayPrototype.toLocaleString.call([1, 2]);\n    })), NAME, { toLocaleString: $toLocaleString });\n\n    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;\n    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);\n  };\n} else module.exports = function () { /* empty */ };\n","'use strict';\nvar global = require('./_global');\nvar DESCRIPTORS = require('./_descriptors');\nvar LIBRARY = require('./_library');\nvar $typed = require('./_typed');\nvar hide = require('./_hide');\nvar redefineAll = require('./_redefine-all');\nvar fails = require('./_fails');\nvar anInstance = require('./_an-instance');\nvar toInteger = require('./_to-integer');\nvar toLength = require('./_to-length');\nvar toIndex = require('./_to-index');\nvar gOPN = require('./_object-gopn').f;\nvar dP = require('./_object-dp').f;\nvar arrayFill = require('./_array-fill');\nvar setToStringTag = require('./_set-to-string-tag');\nvar ARRAY_BUFFER = 'ArrayBuffer';\nvar DATA_VIEW = 'DataView';\nvar PROTOTYPE = 'prototype';\nvar WRONG_LENGTH = 'Wrong length!';\nvar WRONG_INDEX = 'Wrong index!';\nvar $ArrayBuffer = global[ARRAY_BUFFER];\nvar $DataView = global[DATA_VIEW];\nvar Math = global.Math;\nvar RangeError = global.RangeError;\n// eslint-disable-next-line no-shadow-restricted-names\nvar Infinity = global.Infinity;\nvar BaseBuffer = $ArrayBuffer;\nvar abs = Math.abs;\nvar pow = Math.pow;\nvar floor = Math.floor;\nvar log = Math.log;\nvar LN2 = Math.LN2;\nvar BUFFER = 'buffer';\nvar BYTE_LENGTH = 'byteLength';\nvar BYTE_OFFSET = 'byteOffset';\nvar $BUFFER = DESCRIPTORS ? '_b' : BUFFER;\nvar $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;\nvar $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;\n\n// IEEE754 conversions based on https://github.com/feross/ieee754\nfunction packIEEE754(value, mLen, nBytes) {\n  var buffer = new Array(nBytes);\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;\n  var i = 0;\n  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n  var e, m, c;\n  value = abs(value);\n  // eslint-disable-next-line no-self-compare\n  if (value != value || value === Infinity) {\n    // eslint-disable-next-line no-self-compare\n    m = value != value ? 1 : 0;\n    e = eMax;\n  } else {\n    e = floor(log(value) / LN2);\n    if (value * (c = pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * pow(2, eBias - 1) * pow(2, mLen);\n      e = 0;\n    }\n  }\n  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);\n  e = e << mLen | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);\n  buffer[--i] |= s * 128;\n  return buffer;\n}\nfunction unpackIEEE754(buffer, mLen, nBytes) {\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = eLen - 7;\n  var i = nBytes - 1;\n  var s = buffer[i--];\n  var e = s & 127;\n  var m;\n  s >>= 7;\n  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);\n  m = e & (1 << -nBits) - 1;\n  e >>= -nBits;\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : s ? -Infinity : Infinity;\n  } else {\n    m = m + pow(2, mLen);\n    e = e - eBias;\n  } return (s ? -1 : 1) * m * pow(2, e - mLen);\n}\n\nfunction unpackI32(bytes) {\n  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];\n}\nfunction packI8(it) {\n  return [it & 0xff];\n}\nfunction packI16(it) {\n  return [it & 0xff, it >> 8 & 0xff];\n}\nfunction packI32(it) {\n  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];\n}\nfunction packF64(it) {\n  return packIEEE754(it, 52, 8);\n}\nfunction packF32(it) {\n  return packIEEE754(it, 23, 4);\n}\n\nfunction addGetter(C, key, internal) {\n  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });\n}\n\nfunction get(view, bytes, index, isLittleEndian) {\n  var numIndex = +index;\n  var intIndex = toIndex(numIndex);\n  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);\n  var store = view[$BUFFER]._b;\n  var start = intIndex + view[$OFFSET];\n  var pack = store.slice(start, start + bytes);\n  return isLittleEndian ? pack : pack.reverse();\n}\nfunction set(view, bytes, index, conversion, value, isLittleEndian) {\n  var numIndex = +index;\n  var intIndex = toIndex(numIndex);\n  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);\n  var store = view[$BUFFER]._b;\n  var start = intIndex + view[$OFFSET];\n  var pack = conversion(+value);\n  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];\n}\n\nif (!$typed.ABV) {\n  $ArrayBuffer = function ArrayBuffer(length) {\n    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);\n    var byteLength = toIndex(length);\n    this._b = arrayFill.call(new Array(byteLength), 0);\n    this[$LENGTH] = byteLength;\n  };\n\n  $DataView = function DataView(buffer, byteOffset, byteLength) {\n    anInstance(this, $DataView, DATA_VIEW);\n    anInstance(buffer, $ArrayBuffer, DATA_VIEW);\n    var bufferLength = buffer[$LENGTH];\n    var offset = toInteger(byteOffset);\n    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');\n    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);\n    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);\n    this[$BUFFER] = buffer;\n    this[$OFFSET] = offset;\n    this[$LENGTH] = byteLength;\n  };\n\n  if (DESCRIPTORS) {\n    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');\n    addGetter($DataView, BUFFER, '_b');\n    addGetter($DataView, BYTE_LENGTH, '_l');\n    addGetter($DataView, BYTE_OFFSET, '_o');\n  }\n\n  redefineAll($DataView[PROTOTYPE], {\n    getInt8: function getInt8(byteOffset) {\n      return get(this, 1, byteOffset)[0] << 24 >> 24;\n    },\n    getUint8: function getUint8(byteOffset) {\n      return get(this, 1, byteOffset)[0];\n    },\n    getInt16: function getInt16(byteOffset /* , littleEndian */) {\n      var bytes = get(this, 2, byteOffset, arguments[1]);\n      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;\n    },\n    getUint16: function getUint16(byteOffset /* , littleEndian */) {\n      var bytes = get(this, 2, byteOffset, arguments[1]);\n      return bytes[1] << 8 | bytes[0];\n    },\n    getInt32: function getInt32(byteOffset /* , littleEndian */) {\n      return unpackI32(get(this, 4, byteOffset, arguments[1]));\n    },\n    getUint32: function getUint32(byteOffset /* , littleEndian */) {\n      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;\n    },\n    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {\n      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);\n    },\n    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {\n      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);\n    },\n    setInt8: function setInt8(byteOffset, value) {\n      set(this, 1, byteOffset, packI8, value);\n    },\n    setUint8: function setUint8(byteOffset, value) {\n      set(this, 1, byteOffset, packI8, value);\n    },\n    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {\n      set(this, 2, byteOffset, packI16, value, arguments[2]);\n    },\n    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {\n      set(this, 2, byteOffset, packI16, value, arguments[2]);\n    },\n    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packI32, value, arguments[2]);\n    },\n    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packI32, value, arguments[2]);\n    },\n    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packF32, value, arguments[2]);\n    },\n    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {\n      set(this, 8, byteOffset, packF64, value, arguments[2]);\n    }\n  });\n} else {\n  if (!fails(function () {\n    $ArrayBuffer(1);\n  }) || !fails(function () {\n    new $ArrayBuffer(-1); // eslint-disable-line no-new\n  }) || fails(function () {\n    new $ArrayBuffer(); // eslint-disable-line no-new\n    new $ArrayBuffer(1.5); // eslint-disable-line no-new\n    new $ArrayBuffer(NaN); // eslint-disable-line no-new\n    return $ArrayBuffer.name != ARRAY_BUFFER;\n  })) {\n    $ArrayBuffer = function ArrayBuffer(length) {\n      anInstance(this, $ArrayBuffer);\n      return new BaseBuffer(toIndex(length));\n    };\n    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];\n    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {\n      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);\n    }\n    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;\n  }\n  // iOS Safari 7.x bug\n  var view = new $DataView(new $ArrayBuffer(2));\n  var $setInt8 = $DataView[PROTOTYPE].setInt8;\n  view.setInt8(0, 2147483648);\n  view.setInt8(1, 2147483649);\n  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {\n    setInt8: function setInt8(byteOffset, value) {\n      $setInt8.call(this, byteOffset, value << 24 >> 24);\n    },\n    setUint8: function setUint8(byteOffset, value) {\n      $setInt8.call(this, byteOffset, value << 24 >> 24);\n    }\n  }, true);\n}\nsetToStringTag($ArrayBuffer, ARRAY_BUFFER);\nsetToStringTag($DataView, DATA_VIEW);\nhide($DataView[PROTOTYPE], $typed.VIEW, true);\nexports[ARRAY_BUFFER] = $ArrayBuffer;\nexports[DATA_VIEW] = $DataView;\n","var global = require('./_global');\nvar hide = require('./_hide');\nvar uid = require('./_uid');\nvar TYPED = uid('typed_array');\nvar VIEW = uid('view');\nvar ABV = !!(global.ArrayBuffer && global.DataView);\nvar CONSTR = ABV;\nvar i = 0;\nvar l = 9;\nvar Typed;\n\nvar TypedArrayConstructors = (\n  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'\n).split(',');\n\nwhile (i < l) {\n  if (Typed = global[TypedArrayConstructors[i++]]) {\n    hide(Typed.prototype, TYPED, true);\n    hide(Typed.prototype, VIEW, true);\n  } else CONSTR = false;\n}\n\nmodule.exports = {\n  ABV: ABV,\n  CONSTR: CONSTR,\n  TYPED: TYPED,\n  VIEW: VIEW\n};\n","var id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n","var global = require('./_global');\nvar navigator = global.navigator;\n\nmodule.exports = navigator && navigator.userAgent || '';\n","var isObject = require('./_is-object');\nmodule.exports = function (it, TYPE) {\n  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');\n  return it;\n};\n","var global = require('./_global');\nvar core = require('./_core');\nvar LIBRARY = require('./_library');\nvar wksExt = require('./_wks-ext');\nvar defineProperty = require('./_object-dp').f;\nmodule.exports = function (name) {\n  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });\n};\n","exports.f = require('./_wks');\n","var store = require('./_shared')('wks');\nvar uid = require('./_uid');\nvar Symbol = require('./_global').Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n","var classof = require('./_classof');\nvar ITERATOR = require('./_wks')('iterator');\nvar Iterators = require('./_iterators');\nmodule.exports = require('./_core').getIteratorMethod = function (it) {\n  if (it != undefined) return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n","// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)\nvar $export = require('./_export');\n\n$export($export.P, 'Array', { copyWithin: require('./_array-copy-within') });\n\nrequire('./_add-to-unscopables')('copyWithin');\n","// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\nvar $export = require('./_export');\n\n$export($export.P, 'Array', { fill: require('./_array-fill') });\n\nrequire('./_add-to-unscopables')('fill');\n","'use strict';\n// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)\nvar $export = require('./_export');\nvar $find = require('./_array-methods')(6);\nvar KEY = 'findIndex';\nvar forced = true;\n// Shouldn't skip holes\nif (KEY in []) Array(1)[KEY](function () { forced = false; });\n$export($export.P + $export.F * forced, 'Array', {\n  findIndex: function findIndex(callbackfn /* , that = undefined */) {\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\nrequire('./_add-to-unscopables')(KEY);\n","'use strict';\n// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)\nvar $export = require('./_export');\nvar $find = require('./_array-methods')(5);\nvar KEY = 'find';\nvar forced = true;\n// Shouldn't skip holes\nif (KEY in []) Array(1)[KEY](function () { forced = false; });\n$export($export.P + $export.F * forced, 'Array', {\n  find: function find(callbackfn /* , that = undefined */) {\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\nrequire('./_add-to-unscopables')(KEY);\n","'use strict';\nvar ctx = require('./_ctx');\nvar $export = require('./_export');\nvar toObject = require('./_to-object');\nvar call = require('./_iter-call');\nvar isArrayIter = require('./_is-array-iter');\nvar toLength = require('./_to-length');\nvar createProperty = require('./_create-property');\nvar getIterFn = require('./core.get-iterator-method');\n\n$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {\n  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n    var O = toObject(arrayLike);\n    var C = typeof this == 'function' ? this : Array;\n    var aLen = arguments.length;\n    var mapfn = aLen > 1 ? arguments[1] : undefined;\n    var mapping = mapfn !== undefined;\n    var index = 0;\n    var iterFn = getIterFn(O);\n    var length, result, step, iterator;\n    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n    // if object isn't iterable or it's array with default iterator - use simple case\n    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {\n      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {\n        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);\n      }\n    } else {\n      length = toLength(O.length);\n      for (result = new C(length); length > index; index++) {\n        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n      }\n    }\n    result.length = index;\n    return result;\n  }\n});\n","'use strict';\nvar addToUnscopables = require('./_add-to-unscopables');\nvar step = require('./_iter-step');\nvar Iterators = require('./_iterators');\nvar toIObject = require('./_to-iobject');\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var kind = this._k;\n  var index = this._i++;\n  if (!O || index >= O.length) {\n    this._t = undefined;\n    return step(1);\n  }\n  if (kind == 'keys') return step(0, index);\n  if (kind == 'values') return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n","'use strict';\nvar $export = require('./_export');\nvar createProperty = require('./_create-property');\n\n// WebKit Array.of isn't generic\n$export($export.S + $export.F * require('./_fails')(function () {\n  function F() { /* empty */ }\n  return !(Array.of.call(F) instanceof F);\n}), 'Array', {\n  // 22.1.2.3 Array.of( ...items)\n  of: function of(/* ...args */) {\n    var index = 0;\n    var aLen = arguments.length;\n    var result = new (typeof this == 'function' ? this : Array)(aLen);\n    while (aLen > index) createProperty(result, index, arguments[index++]);\n    result.length = aLen;\n    return result;\n  }\n});\n","var dP = require('./_object-dp').f;\nvar FProto = Function.prototype;\nvar nameRE = /^\\s*function ([^ (]*)/;\nvar NAME = 'name';\n\n// 19.2.4.2 name\nNAME in FProto || require('./_descriptors') && dP(FProto, NAME, {\n  configurable: true,\n  get: function () {\n    try {\n      return ('' + this).match(nameRE)[1];\n    } catch (e) {\n      return '';\n    }\n  }\n});\n","'use strict';\nvar strong = require('./_collection-strong');\nvar validate = require('./_validate-collection');\nvar MAP = 'Map';\n\n// 23.1 Map Objects\nmodule.exports = require('./_collection')(MAP, function (get) {\n  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.1.3.6 Map.prototype.get(key)\n  get: function get(key) {\n    var entry = strong.getEntry(validate(this, MAP), key);\n    return entry && entry.v;\n  },\n  // 23.1.3.9 Map.prototype.set(key, value)\n  set: function set(key, value) {\n    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);\n  }\n}, strong, true);\n","// 20.2.2.3 Math.acosh(x)\nvar $export = require('./_export');\nvar log1p = require('./_math-log1p');\nvar sqrt = Math.sqrt;\nvar $acosh = Math.acosh;\n\n$export($export.S + $export.F * !($acosh\n  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509\n  && Math.floor($acosh(Number.MAX_VALUE)) == 710\n  // Tor Browser bug: Math.acosh(Infinity) -> NaN\n  && $acosh(Infinity) == Infinity\n), 'Math', {\n  acosh: function acosh(x) {\n    return (x = +x) < 1 ? NaN : x > 94906265.62425156\n      ? Math.log(x) + Math.LN2\n      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));\n  }\n});\n","// 20.2.2.5 Math.asinh(x)\nvar $export = require('./_export');\nvar $asinh = Math.asinh;\n\nfunction asinh(x) {\n  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));\n}\n\n// Tor Browser bug: Math.asinh(0) -> -0\n$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });\n","// 20.2.2.7 Math.atanh(x)\nvar $export = require('./_export');\nvar $atanh = Math.atanh;\n\n// Tor Browser bug: Math.atanh(-0) -> 0\n$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {\n  atanh: function atanh(x) {\n    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;\n  }\n});\n","// 20.2.2.9 Math.cbrt(x)\nvar $export = require('./_export');\nvar sign = require('./_math-sign');\n\n$export($export.S, 'Math', {\n  cbrt: function cbrt(x) {\n    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);\n  }\n});\n","// 20.2.2.11 Math.clz32(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  clz32: function clz32(x) {\n    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;\n  }\n});\n","// 20.2.2.12 Math.cosh(x)\nvar $export = require('./_export');\nvar exp = Math.exp;\n\n$export($export.S, 'Math', {\n  cosh: function cosh(x) {\n    return (exp(x = +x) + exp(-x)) / 2;\n  }\n});\n","// 20.2.2.14 Math.expm1(x)\nvar $export = require('./_export');\nvar $expm1 = require('./_math-expm1');\n\n$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });\n","// 20.2.2.16 Math.fround(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', { fround: require('./_math-fround') });\n","// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])\nvar $export = require('./_export');\nvar abs = Math.abs;\n\n$export($export.S, 'Math', {\n  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars\n    var sum = 0;\n    var i = 0;\n    var aLen = arguments.length;\n    var larg = 0;\n    var arg, div;\n    while (i < aLen) {\n      arg = abs(arguments[i++]);\n      if (larg < arg) {\n        div = larg / arg;\n        sum = sum * div * div + 1;\n        larg = arg;\n      } else if (arg > 0) {\n        div = arg / larg;\n        sum += div * div;\n      } else sum += arg;\n    }\n    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);\n  }\n});\n","// 20.2.2.18 Math.imul(x, y)\nvar $export = require('./_export');\nvar $imul = Math.imul;\n\n// some WebKit versions fails with big numbers, some has wrong arity\n$export($export.S + $export.F * require('./_fails')(function () {\n  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;\n}), 'Math', {\n  imul: function imul(x, y) {\n    var UINT16 = 0xffff;\n    var xn = +x;\n    var yn = +y;\n    var xl = UINT16 & xn;\n    var yl = UINT16 & yn;\n    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);\n  }\n});\n","// 20.2.2.21 Math.log10(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  log10: function log10(x) {\n    return Math.log(x) * Math.LOG10E;\n  }\n});\n","// 20.2.2.20 Math.log1p(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', { log1p: require('./_math-log1p') });\n","// 20.2.2.22 Math.log2(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  log2: function log2(x) {\n    return Math.log(x) / Math.LN2;\n  }\n});\n","// 20.2.2.28 Math.sign(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', { sign: require('./_math-sign') });\n","// 20.2.2.30 Math.sinh(x)\nvar $export = require('./_export');\nvar expm1 = require('./_math-expm1');\nvar exp = Math.exp;\n\n// V8 near Chromium 38 has a problem with very small numbers\n$export($export.S + $export.F * require('./_fails')(function () {\n  return !Math.sinh(-2e-17) != -2e-17;\n}), 'Math', {\n  sinh: function sinh(x) {\n    return Math.abs(x = +x) < 1\n      ? (expm1(x) - expm1(-x)) / 2\n      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);\n  }\n});\n","// 20.2.2.33 Math.tanh(x)\nvar $export = require('./_export');\nvar expm1 = require('./_math-expm1');\nvar exp = Math.exp;\n\n$export($export.S, 'Math', {\n  tanh: function tanh(x) {\n    var a = expm1(x = +x);\n    var b = expm1(-x);\n    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));\n  }\n});\n","// 20.2.2.34 Math.trunc(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  trunc: function trunc(it) {\n    return (it > 0 ? Math.floor : Math.ceil)(it);\n  }\n});\n","// 20.1.2.1 Number.EPSILON\nvar $export = require('./_export');\n\n$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });\n","// 20.1.2.2 Number.isFinite(number)\nvar $export = require('./_export');\nvar _isFinite = require('./_global').isFinite;\n\n$export($export.S, 'Number', {\n  isFinite: function isFinite(it) {\n    return typeof it == 'number' && _isFinite(it);\n  }\n});\n","// 20.1.2.3 Number.isInteger(number)\nvar $export = require('./_export');\n\n$export($export.S, 'Number', { isInteger: require('./_is-integer') });\n","// 20.1.2.4 Number.isNaN(number)\nvar $export = require('./_export');\n\n$export($export.S, 'Number', {\n  isNaN: function isNaN(number) {\n    // eslint-disable-next-line no-self-compare\n    return number != number;\n  }\n});\n","// 20.1.2.5 Number.isSafeInteger(number)\nvar $export = require('./_export');\nvar isInteger = require('./_is-integer');\nvar abs = Math.abs;\n\n$export($export.S, 'Number', {\n  isSafeInteger: function isSafeInteger(number) {\n    return isInteger(number) && abs(number) <= 0x1fffffffffffff;\n  }\n});\n","// 20.1.2.6 Number.MAX_SAFE_INTEGER\nvar $export = require('./_export');\n\n$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });\n","// 20.1.2.10 Number.MIN_SAFE_INTEGER\nvar $export = require('./_export');\n\n$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });\n","// 19.1.3.1 Object.assign(target, source)\nvar $export = require('./_export');\n\n$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });\n","// 19.1.2.5 Object.freeze(O)\nvar isObject = require('./_is-object');\nvar meta = require('./_meta').onFreeze;\n\nrequire('./_object-sap')('freeze', function ($freeze) {\n  return function freeze(it) {\n    return $freeze && isObject(it) ? $freeze(meta(it)) : it;\n  };\n});\n","// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\nvar toIObject = require('./_to-iobject');\nvar $getOwnPropertyDescriptor = require('./_object-gopd').f;\n\nrequire('./_object-sap')('getOwnPropertyDescriptor', function () {\n  return function getOwnPropertyDescriptor(it, key) {\n    return $getOwnPropertyDescriptor(toIObject(it), key);\n  };\n});\n","// 19.1.2.7 Object.getOwnPropertyNames(O)\nrequire('./_object-sap')('getOwnPropertyNames', function () {\n  return require('./_object-gopn-ext').f;\n});\n","// 19.1.2.9 Object.getPrototypeOf(O)\nvar toObject = require('./_to-object');\nvar $getPrototypeOf = require('./_object-gpo');\n\nrequire('./_object-sap')('getPrototypeOf', function () {\n  return function getPrototypeOf(it) {\n    return $getPrototypeOf(toObject(it));\n  };\n});\n","// 19.1.2.11 Object.isExtensible(O)\nvar isObject = require('./_is-object');\n\nrequire('./_object-sap')('isExtensible', function ($isExtensible) {\n  return function isExtensible(it) {\n    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;\n  };\n});\n","// 19.1.2.12 Object.isFrozen(O)\nvar isObject = require('./_is-object');\n\nrequire('./_object-sap')('isFrozen', function ($isFrozen) {\n  return function isFrozen(it) {\n    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;\n  };\n});\n","// 19.1.2.13 Object.isSealed(O)\nvar isObject = require('./_is-object');\n\nrequire('./_object-sap')('isSealed', function ($isSealed) {\n  return function isSealed(it) {\n    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;\n  };\n});\n","// 19.1.3.10 Object.is(value1, value2)\nvar $export = require('./_export');\n$export($export.S, 'Object', { is: require('./_same-value') });\n","// 19.1.2.14 Object.keys(O)\nvar toObject = require('./_to-object');\nvar $keys = require('./_object-keys');\n\nrequire('./_object-sap')('keys', function () {\n  return function keys(it) {\n    return $keys(toObject(it));\n  };\n});\n","// 19.1.2.15 Object.preventExtensions(O)\nvar isObject = require('./_is-object');\nvar meta = require('./_meta').onFreeze;\n\nrequire('./_object-sap')('preventExtensions', function ($preventExtensions) {\n  return function preventExtensions(it) {\n    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;\n  };\n});\n","// 19.1.2.17 Object.seal(O)\nvar isObject = require('./_is-object');\nvar meta = require('./_meta').onFreeze;\n\nrequire('./_object-sap')('seal', function ($seal) {\n  return function seal(it) {\n    return $seal && isObject(it) ? $seal(meta(it)) : it;\n  };\n});\n","// 19.1.3.19 Object.setPrototypeOf(O, proto)\nvar $export = require('./_export');\n$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });\n","'use strict';\nvar LIBRARY = require('./_library');\nvar global = require('./_global');\nvar ctx = require('./_ctx');\nvar classof = require('./_classof');\nvar $export = require('./_export');\nvar isObject = require('./_is-object');\nvar aFunction = require('./_a-function');\nvar anInstance = require('./_an-instance');\nvar forOf = require('./_for-of');\nvar speciesConstructor = require('./_species-constructor');\nvar task = require('./_task').set;\nvar microtask = require('./_microtask')();\nvar newPromiseCapabilityModule = require('./_new-promise-capability');\nvar perform = require('./_perform');\nvar userAgent = require('./_user-agent');\nvar promiseResolve = require('./_promise-resolve');\nvar PROMISE = 'Promise';\nvar TypeError = global.TypeError;\nvar process = global.process;\nvar versions = process && process.versions;\nvar v8 = versions && versions.v8 || '';\nvar $Promise = global[PROMISE];\nvar isNode = classof(process) == 'process';\nvar empty = function () { /* empty */ };\nvar Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;\nvar newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;\n\nvar USE_NATIVE = !!function () {\n  try {\n    // correct subclassing with @@species support\n    var promise = $Promise.resolve(1);\n    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {\n      exec(empty, empty);\n    };\n    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n    return (isNode || typeof PromiseRejectionEvent == 'function')\n      && promise.then(empty) instanceof FakePromise\n      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\n      // we can't detect it synchronously, so just check versions\n      && v8.indexOf('6.6') !== 0\n      && userAgent.indexOf('Chrome/66') === -1;\n  } catch (e) { /* empty */ }\n}();\n\n// helpers\nvar isThenable = function (it) {\n  var then;\n  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\nvar notify = function (promise, isReject) {\n  if (promise._n) return;\n  promise._n = true;\n  var chain = promise._c;\n  microtask(function () {\n    var value = promise._v;\n    var ok = promise._s == 1;\n    var i = 0;\n    var run = function (reaction) {\n      var handler = ok ? reaction.ok : reaction.fail;\n      var resolve = reaction.resolve;\n      var reject = reaction.reject;\n      var domain = reaction.domain;\n      var result, then, exited;\n      try {\n        if (handler) {\n          if (!ok) {\n            if (promise._h == 2) onHandleUnhandled(promise);\n            promise._h = 1;\n          }\n          if (handler === true) result = value;\n          else {\n            if (domain) domain.enter();\n            result = handler(value); // may throw\n            if (domain) {\n              domain.exit();\n              exited = true;\n            }\n          }\n          if (result === reaction.promise) {\n            reject(TypeError('Promise-chain cycle'));\n          } else if (then = isThenable(result)) {\n            then.call(result, resolve, reject);\n          } else resolve(result);\n        } else reject(value);\n      } catch (e) {\n        if (domain && !exited) domain.exit();\n        reject(e);\n      }\n    };\n    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach\n    promise._c = [];\n    promise._n = false;\n    if (isReject && !promise._h) onUnhandled(promise);\n  });\n};\nvar onUnhandled = function (promise) {\n  task.call(global, function () {\n    var value = promise._v;\n    var unhandled = isUnhandled(promise);\n    var result, handler, console;\n    if (unhandled) {\n      result = perform(function () {\n        if (isNode) {\n          process.emit('unhandledRejection', value, promise);\n        } else if (handler = global.onunhandledrejection) {\n          handler({ promise: promise, reason: value });\n        } else if ((console = global.console) && console.error) {\n          console.error('Unhandled promise rejection', value);\n        }\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      promise._h = isNode || isUnhandled(promise) ? 2 : 1;\n    } promise._a = undefined;\n    if (unhandled && result.e) throw result.v;\n  });\n};\nvar isUnhandled = function (promise) {\n  return promise._h !== 1 && (promise._a || promise._c).length === 0;\n};\nvar onHandleUnhandled = function (promise) {\n  task.call(global, function () {\n    var handler;\n    if (isNode) {\n      process.emit('rejectionHandled', promise);\n    } else if (handler = global.onrejectionhandled) {\n      handler({ promise: promise, reason: promise._v });\n    }\n  });\n};\nvar $reject = function (value) {\n  var promise = this;\n  if (promise._d) return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  promise._v = value;\n  promise._s = 2;\n  if (!promise._a) promise._a = promise._c.slice();\n  notify(promise, true);\n};\nvar $resolve = function (value) {\n  var promise = this;\n  var then;\n  if (promise._d) return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  try {\n    if (promise === value) throw TypeError(\"Promise can't be resolved itself\");\n    if (then = isThenable(value)) {\n      microtask(function () {\n        var wrapper = { _w: promise, _d: false }; // wrap\n        try {\n          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\n        } catch (e) {\n          $reject.call(wrapper, e);\n        }\n      });\n    } else {\n      promise._v = value;\n      promise._s = 1;\n      notify(promise, false);\n    }\n  } catch (e) {\n    $reject.call({ _w: promise, _d: false }, e); // wrap\n  }\n};\n\n// constructor polyfill\nif (!USE_NATIVE) {\n  // 25.4.3.1 Promise(executor)\n  $Promise = function Promise(executor) {\n    anInstance(this, $Promise, PROMISE, '_h');\n    aFunction(executor);\n    Internal.call(this);\n    try {\n      executor(ctx($resolve, this, 1), ctx($reject, this, 1));\n    } catch (err) {\n      $reject.call(this, err);\n    }\n  };\n  // eslint-disable-next-line no-unused-vars\n  Internal = function Promise(executor) {\n    this._c = [];             // <- awaiting reactions\n    this._a = undefined;      // <- checked in isUnhandled reactions\n    this._s = 0;              // <- state\n    this._d = false;          // <- done\n    this._v = undefined;      // <- value\n    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\n    this._n = false;          // <- notify\n  };\n  Internal.prototype = require('./_redefine-all')($Promise.prototype, {\n    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n    then: function then(onFulfilled, onRejected) {\n      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));\n      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;\n      reaction.fail = typeof onRejected == 'function' && onRejected;\n      reaction.domain = isNode ? process.domain : undefined;\n      this._c.push(reaction);\n      if (this._a) this._a.push(reaction);\n      if (this._s) notify(this, false);\n      return reaction.promise;\n    },\n    // 25.4.5.1 Promise.prototype.catch(onRejected)\n    'catch': function (onRejected) {\n      return this.then(undefined, onRejected);\n    }\n  });\n  OwnPromiseCapability = function () {\n    var promise = new Internal();\n    this.promise = promise;\n    this.resolve = ctx($resolve, promise, 1);\n    this.reject = ctx($reject, promise, 1);\n  };\n  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {\n    return C === $Promise || C === Wrapper\n      ? new OwnPromiseCapability(C)\n      : newGenericPromiseCapability(C);\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });\nrequire('./_set-to-string-tag')($Promise, PROMISE);\nrequire('./_set-species')(PROMISE);\nWrapper = require('./_core')[PROMISE];\n\n// statics\n$export($export.S + $export.F * !USE_NATIVE, PROMISE, {\n  // 25.4.4.5 Promise.reject(r)\n  reject: function reject(r) {\n    var capability = newPromiseCapability(this);\n    var $$reject = capability.reject;\n    $$reject(r);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {\n  // 25.4.4.6 Promise.resolve(x)\n  resolve: function resolve(x) {\n    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);\n  }\n});\n$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {\n  $Promise.all(iter)['catch'](empty);\n})), PROMISE, {\n  // 25.4.4.1 Promise.all(iterable)\n  all: function all(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var resolve = capability.resolve;\n    var reject = capability.reject;\n    var result = perform(function () {\n      var values = [];\n      var index = 0;\n      var remaining = 1;\n      forOf(iterable, false, function (promise) {\n        var $index = index++;\n        var alreadyCalled = false;\n        values.push(undefined);\n        remaining++;\n        C.resolve(promise).then(function (value) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          values[$index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if (result.e) reject(result.v);\n    return capability.promise;\n  },\n  // 25.4.4.4 Promise.race(iterable)\n  race: function race(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var reject = capability.reject;\n    var result = perform(function () {\n      forOf(iterable, false, function (promise) {\n        C.resolve(promise).then(capability.resolve, reject);\n      });\n    });\n    if (result.e) reject(result.v);\n    return capability.promise;\n  }\n});\n","// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)\nvar $export = require('./_export');\nvar aFunction = require('./_a-function');\nvar anObject = require('./_an-object');\nvar rApply = (require('./_global').Reflect || {}).apply;\nvar fApply = Function.apply;\n// MS Edge argumentsList argument is optional\n$export($export.S + $export.F * !require('./_fails')(function () {\n  rApply(function () { /* empty */ });\n}), 'Reflect', {\n  apply: function apply(target, thisArgument, argumentsList) {\n    var T = aFunction(target);\n    var L = anObject(argumentsList);\n    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);\n  }\n});\n","// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])\nvar $export = require('./_export');\nvar create = require('./_object-create');\nvar aFunction = require('./_a-function');\nvar anObject = require('./_an-object');\nvar isObject = require('./_is-object');\nvar fails = require('./_fails');\nvar bind = require('./_bind');\nvar rConstruct = (require('./_global').Reflect || {}).construct;\n\n// MS Edge supports only 2 arguments and argumentsList argument is optional\n// FF Nightly sets third argument as `new.target`, but does not create `this` from it\nvar NEW_TARGET_BUG = fails(function () {\n  function F() { /* empty */ }\n  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);\n});\nvar ARGS_BUG = !fails(function () {\n  rConstruct(function () { /* empty */ });\n});\n\n$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {\n  construct: function construct(Target, args /* , newTarget */) {\n    aFunction(Target);\n    anObject(args);\n    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);\n    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);\n    if (Target == newTarget) {\n      // w/o altered newTarget, optimization for 0-4 arguments\n      switch (args.length) {\n        case 0: return new Target();\n        case 1: return new Target(args[0]);\n        case 2: return new Target(args[0], args[1]);\n        case 3: return new Target(args[0], args[1], args[2]);\n        case 4: return new Target(args[0], args[1], args[2], args[3]);\n      }\n      // w/o altered newTarget, lot of arguments case\n      var $args = [null];\n      $args.push.apply($args, args);\n      return new (bind.apply(Target, $args))();\n    }\n    // with altered newTarget, not support built-in constructors\n    var proto = newTarget.prototype;\n    var instance = create(isObject(proto) ? proto : Object.prototype);\n    var result = Function.apply.call(Target, instance, args);\n    return isObject(result) ? result : instance;\n  }\n});\n","// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)\nvar dP = require('./_object-dp');\nvar $export = require('./_export');\nvar anObject = require('./_an-object');\nvar toPrimitive = require('./_to-primitive');\n\n// MS Edge has broken Reflect.defineProperty - throwing instead of returning false\n$export($export.S + $export.F * require('./_fails')(function () {\n  // eslint-disable-next-line no-undef\n  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });\n}), 'Reflect', {\n  defineProperty: function defineProperty(target, propertyKey, attributes) {\n    anObject(target);\n    propertyKey = toPrimitive(propertyKey, true);\n    anObject(attributes);\n    try {\n      dP.f(target, propertyKey, attributes);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n});\n","// 26.1.4 Reflect.deleteProperty(target, propertyKey)\nvar $export = require('./_export');\nvar gOPD = require('./_object-gopd').f;\nvar anObject = require('./_an-object');\n\n$export($export.S, 'Reflect', {\n  deleteProperty: function deleteProperty(target, propertyKey) {\n    var desc = gOPD(anObject(target), propertyKey);\n    return desc && !desc.configurable ? false : delete target[propertyKey];\n  }\n});\n","// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)\nvar gOPD = require('./_object-gopd');\nvar $export = require('./_export');\nvar anObject = require('./_an-object');\n\n$export($export.S, 'Reflect', {\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {\n    return gOPD.f(anObject(target), propertyKey);\n  }\n});\n","// 26.1.8 Reflect.getPrototypeOf(target)\nvar $export = require('./_export');\nvar getProto = require('./_object-gpo');\nvar anObject = require('./_an-object');\n\n$export($export.S, 'Reflect', {\n  getPrototypeOf: function getPrototypeOf(target) {\n    return getProto(anObject(target));\n  }\n});\n","// 26.1.6 Reflect.get(target, propertyKey [, receiver])\nvar gOPD = require('./_object-gopd');\nvar getPrototypeOf = require('./_object-gpo');\nvar has = require('./_has');\nvar $export = require('./_export');\nvar isObject = require('./_is-object');\nvar anObject = require('./_an-object');\n\nfunction get(target, propertyKey /* , receiver */) {\n  var receiver = arguments.length < 3 ? target : arguments[2];\n  var desc, proto;\n  if (anObject(target) === receiver) return target[propertyKey];\n  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')\n    ? desc.value\n    : desc.get !== undefined\n      ? desc.get.call(receiver)\n      : undefined;\n  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);\n}\n\n$export($export.S, 'Reflect', { get: get });\n","// 26.1.9 Reflect.has(target, propertyKey)\nvar $export = require('./_export');\n\n$export($export.S, 'Reflect', {\n  has: function has(target, propertyKey) {\n    return propertyKey in target;\n  }\n});\n","// 26.1.10 Reflect.isExtensible(target)\nvar $export = require('./_export');\nvar anObject = require('./_an-object');\nvar $isExtensible = Object.isExtensible;\n\n$export($export.S, 'Reflect', {\n  isExtensible: function isExtensible(target) {\n    anObject(target);\n    return $isExtensible ? $isExtensible(target) : true;\n  }\n});\n","// 26.1.11 Reflect.ownKeys(target)\nvar $export = require('./_export');\n\n$export($export.S, 'Reflect', { ownKeys: require('./_own-keys') });\n","// 26.1.12 Reflect.preventExtensions(target)\nvar $export = require('./_export');\nvar anObject = require('./_an-object');\nvar $preventExtensions = Object.preventExtensions;\n\n$export($export.S, 'Reflect', {\n  preventExtensions: function preventExtensions(target) {\n    anObject(target);\n    try {\n      if ($preventExtensions) $preventExtensions(target);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n});\n","// 26.1.14 Reflect.setPrototypeOf(target, proto)\nvar $export = require('./_export');\nvar setProto = require('./_set-proto');\n\nif (setProto) $export($export.S, 'Reflect', {\n  setPrototypeOf: function setPrototypeOf(target, proto) {\n    setProto.check(target, proto);\n    try {\n      setProto.set(target, proto);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n});\n","// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])\nvar dP = require('./_object-dp');\nvar gOPD = require('./_object-gopd');\nvar getPrototypeOf = require('./_object-gpo');\nvar has = require('./_has');\nvar $export = require('./_export');\nvar createDesc = require('./_property-desc');\nvar anObject = require('./_an-object');\nvar isObject = require('./_is-object');\n\nfunction set(target, propertyKey, V /* , receiver */) {\n  var receiver = arguments.length < 4 ? target : arguments[3];\n  var ownDesc = gOPD.f(anObject(target), propertyKey);\n  var existingDescriptor, proto;\n  if (!ownDesc) {\n    if (isObject(proto = getPrototypeOf(target))) {\n      return set(proto, propertyKey, V, receiver);\n    }\n    ownDesc = createDesc(0);\n  }\n  if (has(ownDesc, 'value')) {\n    if (ownDesc.writable === false || !isObject(receiver)) return false;\n    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {\n      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;\n      existingDescriptor.value = V;\n      dP.f(receiver, propertyKey, existingDescriptor);\n    } else dP.f(receiver, propertyKey, createDesc(0, V));\n    return true;\n  }\n  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);\n}\n\n$export($export.S, 'Reflect', { set: set });\n","// 21.2.5.3 get RegExp.prototype.flags()\nif (require('./_descriptors') && /./g.flags != 'g') require('./_object-dp').f(RegExp.prototype, 'flags', {\n  configurable: true,\n  get: require('./_flags')\n});\n","// @@match logic\nrequire('./_fix-re-wks')('match', 1, function (defined, MATCH, $match) {\n  // 21.1.3.11 String.prototype.match(regexp)\n  return [function match(regexp) {\n    'use strict';\n    var O = defined(this);\n    var fn = regexp == undefined ? undefined : regexp[MATCH];\n    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));\n  }, $match];\n});\n","// @@replace logic\nrequire('./_fix-re-wks')('replace', 2, function (defined, REPLACE, $replace) {\n  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)\n  return [function replace(searchValue, replaceValue) {\n    'use strict';\n    var O = defined(this);\n    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];\n    return fn !== undefined\n      ? fn.call(searchValue, O, replaceValue)\n      : $replace.call(String(O), searchValue, replaceValue);\n  }, $replace];\n});\n","// @@search logic\nrequire('./_fix-re-wks')('search', 1, function (defined, SEARCH, $search) {\n  // 21.1.3.15 String.prototype.search(regexp)\n  return [function search(regexp) {\n    'use strict';\n    var O = defined(this);\n    var fn = regexp == undefined ? undefined : regexp[SEARCH];\n    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));\n  }, $search];\n});\n","// @@split logic\nrequire('./_fix-re-wks')('split', 2, function (defined, SPLIT, $split) {\n  'use strict';\n  var isRegExp = require('./_is-regexp');\n  var _split = $split;\n  var $push = [].push;\n  var $SPLIT = 'split';\n  var LENGTH = 'length';\n  var LAST_INDEX = 'lastIndex';\n  if (\n    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||\n    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||\n    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||\n    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||\n    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||\n    ''[$SPLIT](/.?/)[LENGTH]\n  ) {\n    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group\n    // based on es5-shim implementation, need to rework it\n    $split = function (separator, limit) {\n      var string = String(this);\n      if (separator === undefined && limit === 0) return [];\n      // If `separator` is not a regex, use native split\n      if (!isRegExp(separator)) return _split.call(string, separator, limit);\n      var output = [];\n      var flags = (separator.ignoreCase ? 'i' : '') +\n                  (separator.multiline ? 'm' : '') +\n                  (separator.unicode ? 'u' : '') +\n                  (separator.sticky ? 'y' : '');\n      var lastLastIndex = 0;\n      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      var separatorCopy = new RegExp(separator.source, flags + 'g');\n      var separator2, match, lastIndex, lastLength, i;\n      // Doesn't need flags gy, but they don't hurt\n      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\\\s)', flags);\n      while (match = separatorCopy.exec(string)) {\n        // `separatorCopy.lastIndex` is not reliable cross-browser\n        lastIndex = match.index + match[0][LENGTH];\n        if (lastIndex > lastLastIndex) {\n          output.push(string.slice(lastLastIndex, match.index));\n          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG\n          // eslint-disable-next-line no-loop-func\n          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {\n            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;\n          });\n          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));\n          lastLength = match[0][LENGTH];\n          lastLastIndex = lastIndex;\n          if (output[LENGTH] >= splitLimit) break;\n        }\n        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop\n      }\n      if (lastLastIndex === string[LENGTH]) {\n        if (lastLength || !separatorCopy.test('')) output.push('');\n      } else output.push(string.slice(lastLastIndex));\n      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;\n    };\n  // Chakra, V8\n  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {\n    $split = function (separator, limit) {\n      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);\n    };\n  }\n  // 21.1.3.17 String.prototype.split(separator, limit)\n  return [function split(separator, limit) {\n    var O = defined(this);\n    var fn = separator == undefined ? undefined : separator[SPLIT];\n    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);\n  }, $split];\n});\n","'use strict';\nvar strong = require('./_collection-strong');\nvar validate = require('./_validate-collection');\nvar SET = 'Set';\n\n// 23.2 Set Objects\nmodule.exports = require('./_collection')(SET, function (get) {\n  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.2.3.1 Set.prototype.add(value)\n  add: function add(value) {\n    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);\n  }\n}, strong);\n","'use strict';\nvar $export = require('./_export');\nvar $at = require('./_string-at')(false);\n$export($export.P, 'String', {\n  // 21.1.3.3 String.prototype.codePointAt(pos)\n  codePointAt: function codePointAt(pos) {\n    return $at(this, pos);\n  }\n});\n","// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])\n'use strict';\nvar $export = require('./_export');\nvar toLength = require('./_to-length');\nvar context = require('./_string-context');\nvar ENDS_WITH = 'endsWith';\nvar $endsWith = ''[ENDS_WITH];\n\n$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {\n  endsWith: function endsWith(searchString /* , endPosition = @length */) {\n    var that = context(this, searchString, ENDS_WITH);\n    var endPosition = arguments.length > 1 ? arguments[1] : undefined;\n    var len = toLength(that.length);\n    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);\n    var search = String(searchString);\n    return $endsWith\n      ? $endsWith.call(that, search, end)\n      : that.slice(end - search.length, end) === search;\n  }\n});\n","var $export = require('./_export');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nvar fromCharCode = String.fromCharCode;\nvar $fromCodePoint = String.fromCodePoint;\n\n// length should be 1, old FF problem\n$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {\n  // 21.1.2.2 String.fromCodePoint(...codePoints)\n  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars\n    var res = [];\n    var aLen = arguments.length;\n    var i = 0;\n    var code;\n    while (aLen > i) {\n      code = +arguments[i++];\n      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');\n      res.push(code < 0x10000\n        ? fromCharCode(code)\n        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)\n      );\n    } return res.join('');\n  }\n});\n","// 21.1.3.7 String.prototype.includes(searchString, position = 0)\n'use strict';\nvar $export = require('./_export');\nvar context = require('./_string-context');\nvar INCLUDES = 'includes';\n\n$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {\n  includes: function includes(searchString /* , position = 0 */) {\n    return !!~context(this, searchString, INCLUDES)\n      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n","var $export = require('./_export');\nvar toIObject = require('./_to-iobject');\nvar toLength = require('./_to-length');\n\n$export($export.S, 'String', {\n  // 21.1.2.4 String.raw(callSite, ...substitutions)\n  raw: function raw(callSite) {\n    var tpl = toIObject(callSite.raw);\n    var len = toLength(tpl.length);\n    var aLen = arguments.length;\n    var res = [];\n    var i = 0;\n    while (len > i) {\n      res.push(String(tpl[i++]));\n      if (i < aLen) res.push(String(arguments[i]));\n    } return res.join('');\n  }\n});\n","var $export = require('./_export');\n\n$export($export.P, 'String', {\n  // 21.1.3.13 String.prototype.repeat(count)\n  repeat: require('./_string-repeat')\n});\n","// 21.1.3.18 String.prototype.startsWith(searchString [, position ])\n'use strict';\nvar $export = require('./_export');\nvar toLength = require('./_to-length');\nvar context = require('./_string-context');\nvar STARTS_WITH = 'startsWith';\nvar $startsWith = ''[STARTS_WITH];\n\n$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {\n  startsWith: function startsWith(searchString /* , position = 0 */) {\n    var that = context(this, searchString, STARTS_WITH);\n    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));\n    var search = String(searchString);\n    return $startsWith\n      ? $startsWith.call(that, search, index)\n      : that.slice(index, index + search.length) === search;\n  }\n});\n","'use strict';\n// ECMAScript 6 symbols shim\nvar global = require('./_global');\nvar has = require('./_has');\nvar DESCRIPTORS = require('./_descriptors');\nvar $export = require('./_export');\nvar redefine = require('./_redefine');\nvar META = require('./_meta').KEY;\nvar $fails = require('./_fails');\nvar shared = require('./_shared');\nvar setToStringTag = require('./_set-to-string-tag');\nvar uid = require('./_uid');\nvar wks = require('./_wks');\nvar wksExt = require('./_wks-ext');\nvar wksDefine = require('./_wks-define');\nvar enumKeys = require('./_enum-keys');\nvar isArray = require('./_is-array');\nvar anObject = require('./_an-object');\nvar isObject = require('./_is-object');\nvar toIObject = require('./_to-iobject');\nvar toPrimitive = require('./_to-primitive');\nvar createDesc = require('./_property-desc');\nvar _create = require('./_object-create');\nvar gOPNExt = require('./_object-gopn-ext');\nvar $GOPD = require('./_object-gopd');\nvar $DP = require('./_object-dp');\nvar $keys = require('./_object-keys');\nvar gOPD = $GOPD.f;\nvar dP = $DP.f;\nvar gOPN = gOPNExt.f;\nvar $Symbol = global.Symbol;\nvar $JSON = global.JSON;\nvar _stringify = $JSON && $JSON.stringify;\nvar PROTOTYPE = 'prototype';\nvar HIDDEN = wks('_hidden');\nvar TO_PRIMITIVE = wks('toPrimitive');\nvar isEnum = {}.propertyIsEnumerable;\nvar SymbolRegistry = shared('symbol-registry');\nvar AllSymbols = shared('symbols');\nvar OPSymbols = shared('op-symbols');\nvar ObjectProto = Object[PROTOTYPE];\nvar USE_NATIVE = typeof $Symbol == 'function';\nvar QObject = global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = DESCRIPTORS && $fails(function () {\n  return _create(dP({}, 'a', {\n    get: function () { return dP(this, 'a', { value: 7 }).a; }\n  })).a != 7;\n}) ? function (it, key, D) {\n  var protoDesc = gOPD(ObjectProto, key);\n  if (protoDesc) delete ObjectProto[key];\n  dP(it, key, D);\n  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);\n} : dP;\n\nvar wrap = function (tag) {\n  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n  sym._k = tag;\n  return sym;\n};\n\nvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  return it instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(it, key, D) {\n  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);\n  anObject(it);\n  key = toPrimitive(key, true);\n  anObject(D);\n  if (has(AllSymbols, key)) {\n    if (!D.enumerable) {\n      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;\n      D = _create(D, { enumerable: createDesc(0, false) });\n    } return setSymbolDesc(it, key, D);\n  } return dP(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P) {\n  anObject(it);\n  var keys = enumKeys(P = toIObject(P));\n  var i = 0;\n  var l = keys.length;\n  var key;\n  while (l > i) $defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P) {\n  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key) {\n  var E = isEnum.call(this, key = toPrimitive(key, true));\n  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;\n  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {\n  it = toIObject(it);\n  key = toPrimitive(key, true);\n  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;\n  var D = gOPD(it, key);\n  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it) {\n  var names = gOPN(toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);\n  } return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it) {\n  var IS_OP = it === ObjectProto;\n  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);\n  } return result;\n};\n\n// 19.4.1.1 Symbol([description])\nif (!USE_NATIVE) {\n  $Symbol = function Symbol() {\n    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');\n    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n    var $set = function (value) {\n      if (this === ObjectProto) $set.call(OPSymbols, value);\n      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, createDesc(1, value));\n    };\n    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });\n    return wrap(tag);\n  };\n  redefine($Symbol[PROTOTYPE], 'toString', function toString() {\n    return this._k;\n  });\n\n  $GOPD.f = $getOwnPropertyDescriptor;\n  $DP.f = $defineProperty;\n  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;\n  require('./_object-pie').f = $propertyIsEnumerable;\n  require('./_object-gops').f = $getOwnPropertySymbols;\n\n  if (DESCRIPTORS && !require('./_library')) {\n    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n\n  wksExt.f = function (name) {\n    return wrap(wks(name));\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });\n\nfor (var es6Symbols = (\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);\n\nfor (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);\n\n$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function (key) {\n    return has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(sym) {\n    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');\n    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;\n  },\n  useSetter: function () { setter = true; },\n  useSimple: function () { setter = false; }\n});\n\n$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';\n})), 'JSON', {\n  stringify: function stringify(it) {\n    var args = [it];\n    var i = 1;\n    var replacer, $replacer;\n    while (arguments.length > i) args.push(arguments[i++]);\n    $replacer = replacer = args[1];\n    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\n    if (!isArray(replacer)) replacer = function (key, value) {\n      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);\n      if (!isSymbol(value)) return value;\n    };\n    args[1] = replacer;\n    return _stringify.apply($JSON, args);\n  }\n});\n\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\nsetToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\nsetToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\nsetToStringTag(global.JSON, 'JSON', true);\n","'use strict';\nvar $export = require('./_export');\nvar $typed = require('./_typed');\nvar buffer = require('./_typed-buffer');\nvar anObject = require('./_an-object');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nvar toLength = require('./_to-length');\nvar isObject = require('./_is-object');\nvar ArrayBuffer = require('./_global').ArrayBuffer;\nvar speciesConstructor = require('./_species-constructor');\nvar $ArrayBuffer = buffer.ArrayBuffer;\nvar $DataView = buffer.DataView;\nvar $isView = $typed.ABV && ArrayBuffer.isView;\nvar $slice = $ArrayBuffer.prototype.slice;\nvar VIEW = $typed.VIEW;\nvar ARRAY_BUFFER = 'ArrayBuffer';\n\n$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });\n\n$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {\n  // 24.1.3.1 ArrayBuffer.isView(arg)\n  isView: function isView(it) {\n    return $isView && $isView(it) || isObject(it) && VIEW in it;\n  }\n});\n\n$export($export.P + $export.U + $export.F * require('./_fails')(function () {\n  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;\n}), ARRAY_BUFFER, {\n  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)\n  slice: function slice(start, end) {\n    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix\n    var len = anObject(this).byteLength;\n    var first = toAbsoluteIndex(start, len);\n    var fin = toAbsoluteIndex(end === undefined ? len : end, len);\n    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));\n    var viewS = new $DataView(this);\n    var viewT = new $DataView(result);\n    var index = 0;\n    while (first < fin) {\n      viewT.setUint8(index++, viewS.getUint8(first++));\n    } return result;\n  }\n});\n\nrequire('./_set-species')(ARRAY_BUFFER);\n","require('./_typed-array')('Float32', 4, function (init) {\n  return function Float32Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","require('./_typed-array')('Float64', 8, function (init) {\n  return function Float64Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","require('./_typed-array')('Int16', 2, function (init) {\n  return function Int16Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","require('./_typed-array')('Int32', 4, function (init) {\n  return function Int32Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","require('./_typed-array')('Int8', 1, function (init) {\n  return function Int8Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","require('./_typed-array')('Uint16', 2, function (init) {\n  return function Uint16Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","require('./_typed-array')('Uint32', 4, function (init) {\n  return function Uint32Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","require('./_typed-array')('Uint8', 1, function (init) {\n  return function Uint8Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","require('./_typed-array')('Uint8', 1, function (init) {\n  return function Uint8ClampedArray(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n}, true);\n","'use strict';\nvar each = require('./_array-methods')(0);\nvar redefine = require('./_redefine');\nvar meta = require('./_meta');\nvar assign = require('./_object-assign');\nvar weak = require('./_collection-weak');\nvar isObject = require('./_is-object');\nvar fails = require('./_fails');\nvar validate = require('./_validate-collection');\nvar WEAK_MAP = 'WeakMap';\nvar getWeak = meta.getWeak;\nvar isExtensible = Object.isExtensible;\nvar uncaughtFrozenStore = weak.ufstore;\nvar tmp = {};\nvar InternalMap;\n\nvar wrapper = function (get) {\n  return function WeakMap() {\n    return get(this, arguments.length > 0 ? arguments[0] : undefined);\n  };\n};\n\nvar methods = {\n  // 23.3.3.3 WeakMap.prototype.get(key)\n  get: function get(key) {\n    if (isObject(key)) {\n      var data = getWeak(key);\n      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);\n      return data ? data[this._i] : undefined;\n    }\n  },\n  // 23.3.3.5 WeakMap.prototype.set(key, value)\n  set: function set(key, value) {\n    return weak.def(validate(this, WEAK_MAP), key, value);\n  }\n};\n\n// 23.3 WeakMap Objects\nvar $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);\n\n// IE11 WeakMap frozen keys fix\nif (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {\n  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);\n  assign(InternalMap.prototype, methods);\n  meta.NEED = true;\n  each(['delete', 'has', 'get', 'set'], function (key) {\n    var proto = $WeakMap.prototype;\n    var method = proto[key];\n    redefine(proto, key, function (a, b) {\n      // store frozen objects on internal weakmap shim\n      if (isObject(a) && !isExtensible(a)) {\n        if (!this._f) this._f = new InternalMap();\n        var result = this._f[key](a, b);\n        return key == 'set' ? this : result;\n      // store all the rest on native weakmap\n      } return method.call(this, a, b);\n    });\n  });\n}\n","'use strict';\nvar weak = require('./_collection-weak');\nvar validate = require('./_validate-collection');\nvar WEAK_SET = 'WeakSet';\n\n// 23.4 WeakSet Objects\nrequire('./_collection')(WEAK_SET, function (get) {\n  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.4.3.1 WeakSet.prototype.add(value)\n  add: function add(value) {\n    return weak.def(validate(this, WEAK_SET), value, true);\n  }\n}, weak, false, true);\n","'use strict';\n// https://github.com/tc39/Array.prototype.includes\nvar $export = require('./_export');\nvar $includes = require('./_array-includes')(true);\n\n$export($export.P, 'Array', {\n  includes: function includes(el /* , fromIndex = 0 */) {\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nrequire('./_add-to-unscopables')('includes');\n","// https://github.com/tc39/proposal-object-values-entries\nvar $export = require('./_export');\nvar $entries = require('./_object-to-array')(true);\n\n$export($export.S, 'Object', {\n  entries: function entries(it) {\n    return $entries(it);\n  }\n});\n","// https://github.com/tc39/proposal-object-getownpropertydescriptors\nvar $export = require('./_export');\nvar ownKeys = require('./_own-keys');\nvar toIObject = require('./_to-iobject');\nvar gOPD = require('./_object-gopd');\nvar createProperty = require('./_create-property');\n\n$export($export.S, 'Object', {\n  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {\n    var O = toIObject(object);\n    var getDesc = gOPD.f;\n    var keys = ownKeys(O);\n    var result = {};\n    var i = 0;\n    var key, desc;\n    while (keys.length > i) {\n      desc = getDesc(O, key = keys[i++]);\n      if (desc !== undefined) createProperty(result, key, desc);\n    }\n    return result;\n  }\n});\n","// https://github.com/tc39/proposal-object-values-entries\nvar $export = require('./_export');\nvar $values = require('./_object-to-array')(false);\n\n$export($export.S, 'Object', {\n  values: function values(it) {\n    return $values(it);\n  }\n});\n","'use strict';\n// https://github.com/tc39/proposal-string-pad-start-end\nvar $export = require('./_export');\nvar $pad = require('./_string-pad');\nvar userAgent = require('./_user-agent');\n\n// https://github.com/zloirock/core-js/issues/280\n$export($export.P + $export.F * /Version\\/10\\.\\d+(\\.\\d+)? Safari\\//.test(userAgent), 'String', {\n  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {\n    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);\n  }\n});\n","'use strict';\n// https://github.com/tc39/proposal-string-pad-start-end\nvar $export = require('./_export');\nvar $pad = require('./_string-pad');\nvar userAgent = require('./_user-agent');\n\n// https://github.com/zloirock/core-js/issues/280\n$export($export.P + $export.F * /Version\\/10\\.\\d+(\\.\\d+)? Safari\\//.test(userAgent), 'String', {\n  padStart: function padStart(maxLength /* , fillString = ' ' */) {\n    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);\n  }\n});\n","var $iterators = require('./es6.array.iterator');\nvar getKeys = require('./_object-keys');\nvar redefine = require('./_redefine');\nvar global = require('./_global');\nvar hide = require('./_hide');\nvar Iterators = require('./_iterators');\nvar wks = require('./_wks');\nvar ITERATOR = wks('iterator');\nvar TO_STRING_TAG = wks('toStringTag');\nvar ArrayValues = Iterators.Array;\n\nvar DOMIterables = {\n  CSSRuleList: true, // TODO: Not spec compliant, should be false.\n  CSSStyleDeclaration: false,\n  CSSValueList: false,\n  ClientRectList: false,\n  DOMRectList: false,\n  DOMStringList: false,\n  DOMTokenList: true,\n  DataTransferItemList: false,\n  FileList: false,\n  HTMLAllCollection: false,\n  HTMLCollection: false,\n  HTMLFormElement: false,\n  HTMLSelectElement: false,\n  MediaList: true, // TODO: Not spec compliant, should be false.\n  MimeTypeArray: false,\n  NamedNodeMap: false,\n  NodeList: true,\n  PaintRequestList: false,\n  Plugin: false,\n  PluginArray: false,\n  SVGLengthList: false,\n  SVGNumberList: false,\n  SVGPathSegList: false,\n  SVGPointList: false,\n  SVGStringList: false,\n  SVGTransformList: false,\n  SourceBufferList: false,\n  StyleSheetList: true, // TODO: Not spec compliant, should be false.\n  TextTrackCueList: false,\n  TextTrackList: false,\n  TouchList: false\n};\n\nfor (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {\n  var NAME = collections[i];\n  var explicit = DOMIterables[NAME];\n  var Collection = global[NAME];\n  var proto = Collection && Collection.prototype;\n  var key;\n  if (proto) {\n    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);\n    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\n    Iterators[NAME] = ArrayValues;\n    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);\n  }\n}\n","var $export = require('./_export');\nvar $task = require('./_task');\n$export($export.G + $export.B, {\n  setImmediate: $task.set,\n  clearImmediate: $task.clear\n});\n","// ie9- setTimeout & setInterval additional parameters fix\nvar global = require('./_global');\nvar $export = require('./_export');\nvar userAgent = require('./_user-agent');\nvar slice = [].slice;\nvar MSIE = /MSIE .\\./.test(userAgent); // <- dirty ie9- check\nvar wrap = function (set) {\n  return function (fn, time /* , ...args */) {\n    var boundArgs = arguments.length > 2;\n    var args = boundArgs ? slice.call(arguments, 2) : false;\n    return set(boundArgs ? function () {\n      // eslint-disable-next-line no-new-func\n      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);\n    } : fn, time);\n  };\n};\n$export($export.G + $export.B + $export.F * MSIE, {\n  setTimeout: wrap(global.setTimeout),\n  setInterval: wrap(global.setInterval)\n});\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n","//////////////////////\n// xtend\n//////////////////////\n\nimport {XtUtil} from '../../../scripts/xtend-utils';\n","/*! xtend (https://getxtend.com/)\n@copyright (c) 2017 - 2018 Riccardo Caroli\n@license MIT (https://github.com/minimit/xtend-library/blob/master/LICENSE) */\n\n'use strict';\n\nimport 'babel-polyfill';\n\nimport {XtToggle, XtDrop, XtOverlay, XtFade, XtSticky} from './xtend';\n\n//////////////////////\n// constructor\n//////////////////////\n\nconst XtUtil = {};\n\n//////////////////////\n// properties\n//////////////////////\n\n// Xt currents based on namespace (so shared between Xt objects)\n\nXtUtil.currents = {};\n\n//////////////////////\n// methods\n//////////////////////\n\n/**\n * init all data-xt classes\n */\nXtUtil.initAll = function (container = document.documentElement) {\n  // xt-toggle\n  Array.from(container.querySelectorAll('[data-xt-toggle]')).forEach(function (el) {\n    new XtToggle(el);\n  });\n  Array.from(container.querySelectorAll('[data-xt-drop]')).forEach(function (el) {\n    new XtDrop(el);\n  });\n  Array.from(container.querySelectorAll('[data-xt-overlay]')).forEach(function (el) {\n    new XtOverlay(el);\n  });\n  Array.from(container.querySelectorAll('[data-xt-fade]')).forEach(function (el) {\n    new XtFade(el);\n  });\n  Array.from(container.querySelectorAll('[data-xt-sticky]')).forEach(function (el) {\n    new XtSticky(el);\n  });\n};\n\n/**\n * request animation frame\n * @returns {Number} animationFrameID\n * USAGE: let animationFrame = XtUtil.requestAnimationFrame.call(window, function () {});\n */\nXtUtil.requestAnimationFrame = function () {\n  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) {\n    window.setTimeout(callback, 1000 / 60);\n  };\n}();\n\n/**\n * cancel animation frame\n * USAGE: XtUtil.cancelAnimationFrame.call(window, animationFrameID);\n */\nXtUtil.cancelAnimationFrame = function () {\n  return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function (callback) {\n    window.clearTimeout(id);\n  };\n}();\n\n/**\n * Check if event target is inside elements\n * @param {Event} e Event to check target\n * @param {NodeList|Array} targets Elements to check inside\n * @return {Boolean}\n */\nXtUtil.checkInside = function (e, targets) {\n  let result = false;\n  for (let t of targets) {\n    if (e.target === t || t.contains(e.target)) {\n      result = true;\n    }\n  }\n  return result;\n};\n\n/**\n * Check if event target is outside elements\n * @param {Event} e Event to check target\n * @param {NodeList|Array} targets Elements to check Outside\n * @return {Boolean}\n */\nXtUtil.checkOutside = function (e, targets) {\n  let result = true;\n  for (let t of targets) {\n    if (e.target === t || t.contains(e.target)) {\n      result = false;\n    }\n  }\n  return result;\n};\n\n/**\n * Get scrollbar width of document\n * @returns {Number} Scrollbar width\n */\nXtUtil.scrollbarWidth = function () {\n  // add outer\n  let outer = document.createElement('div');\n  outer.style.visibility = 'hidden';\n  outer.style.width = '100px';\n  outer.style.msOverflowStyle = 'scrollbar'; // needed for WinJS apps\n  document.body.appendChild(outer);\n  let widthNoScroll = outer.offsetWidth;\n  // force scrollbars\n  outer.style.overflow = 'scroll';\n  // add inner\n  let inner = document.createElement('div');\n  inner.style.width = '100%';\n  outer.appendChild(inner);\n  let widthWithScroll = inner.offsetWidth;\n  // remove\n  outer.parentNode.removeChild(outer);\n  return widthNoScroll - widthWithScroll;\n};\n\n/**\n * Get unique id\n * @returns {String} Unique id\n */\nXtUtil.getUniqueID = function () {\n  XtUtil.uid = XtUtil.uid !== undefined ? XtUtil.uid : 0;\n  return 'unique-id-' + (XtUtil.uid++);\n};\n\n/**\n * Get unique number\n * @returns {Number} Unique number\n */\nXtUtil.getUniqueNum = function () {\n  XtUtil.unumber = XtUtil.unumber !== undefined ? XtUtil.unumber : 0;\n  return XtUtil.unumber++;\n};\n\n/**\n * Merge objects\n * @param {Array} arr Array of objects to merge\n * @returns {Object} Merged object\n */\nXtUtil.merge = function (arr) {\n  let final = {};\n  for (let obj of arr) {\n    for (let [key, value] of Object.entries(obj)) {\n      final[key] = value;\n    }\n  }\n  return final;\n};\n\n/**\n * Make an array when element is only one\n * @param {Object|Array} element\n * @returns {Array}\n */\nXtUtil.arrSingle = function (element) {\n  if (element.length === undefined) {\n    let arr = new Array(1);\n    arr[0] = element;\n    return arr;\n  } else {\n    return element;\n  }\n};\n\n/**\n * Create DOM element from html string\n * @param {String} str Html string (only 1 root html tag)\n * @return {Node|HTMLElement} DOM element\n */\nXtUtil.createElement = function (str) {\n  let div = document.createElement('div');\n  div.innerHTML = str.trim();\n  return div.firstChild;\n};\n\n/**\n * Query element's parents\n * @param {Node|HTMLElement} element Child element\n * @param {String} query Query parents\n * @return {Array} Parents elements by query\n */\nXtUtil.parents = function (element, query) {\n  let parents = [];\n  while (element = element.parentElement.closest(query)) {\n    parents.push(element);\n  }\n  return parents;\n};\n\n/**\n * dataStorage\n * https://stackoverflow.com/questions/29222027/vanilla-alternative-to-jquery-data-function-any-native-javascript-alternati\n * USAGE: XtUtil.dataStorage.put(element, 'key', value);\n */\nXtUtil.dataStorage = {\n  _storage: new WeakMap(),\n  put: function (element, key, obj) {\n    if (!this._storage.has(key)) {\n      this._storage.set(element, new Map());\n    }\n    this._storage.get(element).set(key, obj);\n    return this._storage.get(element).get(key);\n  },\n  get: function (element, key) {\n    return this._storage.get(element).get(key);\n  },\n  has: function (element, key) {\n    return this._storage.get(element).has(key);\n  },\n  remove: function (element, key) {\n    let ret = this._storage.get(element).delete(key);\n    if (!this._storage.get(key).size === false) {\n      this._storage.delete(element);\n    }\n    return ret;\n  }\n};\n\n//////////////////////\n// api\n//////////////////////\n\nwindow.XtUtil = XtUtil;\nexport {XtUtil};\n\n//////////////////////\n// scope polyfill\n// https://github.com/jonathantneal/element-qsa-scope\n// USAGE: querySelectorAll(':scope > .selector');\n//////////////////////\n\ntry {\n  // test for scope support\n  document.querySelector(':scope *');\n} catch (error) {\n  (function (ElementPrototype) {\n    // scope regex\n    var scope = /:scope(?![\\w-])/gi;\n\n    // polyfill Element#querySelector\n    var querySelectorWithScope = polyfill(ElementPrototype.querySelector);\n\n    ElementPrototype.querySelector = function querySelector(selectors) {\n      return querySelectorWithScope.apply(this, arguments);\n    };\n\n    // polyfill Element#querySelectorAll\n    var querySelectorAllWithScope = polyfill(ElementPrototype.querySelectorAll);\n\n    ElementPrototype.querySelectorAll = function querySelectorAll(selectors) {\n      return querySelectorAllWithScope.apply(this, arguments);\n    };\n\n    // polyfill Element#matches\n    if (ElementPrototype.matches) {\n      var matchesWithScope = polyfill(ElementPrototype.matches);\n\n      ElementPrototype.matches = function matches(selectors) {\n        return matchesWithScope.apply(this, arguments);\n      };\n    }\n\n    // polyfill Element#closest\n    if (ElementPrototype.closest) {\n      var closestWithScope = polyfill(ElementPrototype.closest);\n\n      ElementPrototype.closest = function closest(selectors) {\n        return closestWithScope.apply(this, arguments);\n      };\n    }\n\n    function polyfill(qsa) {\n      return function (selectors) {\n        // whether the selectors contain :scope\n        var hasScope = selectors && scope.test(selectors);\n\n        if (hasScope) {\n          // fallback attribute\n          var attr = 'q' + Math.floor(Math.random() * 9000000) + 1000000;\n\n          // replace :scope with the fallback attribute\n          arguments[0] = selectors.replace(scope, '[' + attr + ']');\n\n          // add the fallback attribute\n          this.setAttribute(attr, '');\n\n          // results of the qsa\n          var elementOrNodeList = qsa.apply(this, arguments);\n\n          // remove the fallback attribute\n          this.removeAttribute(attr);\n\n          // return the results of the qsa\n          return elementOrNodeList;\n        } else {\n          // return the results of the qsa\n          return qsa.apply(this, arguments);\n        }\n      };\n    }\n  })(Element.prototype);\n}\n\n//////////////////////\n// matches polyfill\n// https://github.com/jonathantneal/closest\n// USAGE: element.matches(query);\n//////////////////////\n/*\n(function (proto) {\n  if (typeof proto.matches !== 'function') {\n    proto.matches = proto.msMatchesSelector || proto.webkitMatchesSelector || function matches(query) {\n      let el = this;\n      let els = (el.document || el.ownerDocument).querySelectorAll(query);\n      let index = 0;\n      while (els[index] && els[index] !== el) {\n        ++index;\n      }\n      return Boolean(els[index]);\n    };\n  }\n})(Element.prototype);\n*/\n//////////////////////\n// closest polyfill\n// https://github.com/jonathantneal/closest\n// USAGE: element.closest(query);\n//////////////////////\n\n/*\n(function (proto) {\n  if (typeof proto.closest !== 'function') {\n    proto.closest = function closest(query) {\n      let el = this;\n      while (el && el.nodeType === 1) {\n        if (el.matches(query)) {\n          return el;\n        }\n        el = el.parentNode;\n      }\n      return null;\n    };\n  }\n})(Element.prototype);\n*/\n//////////////////////\n// CustomEvent polyfill\n// https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent\n//////////////////////\n\n(function () {\n  if (typeof window.CustomEvent === \"function\") {\n    return false;\n  }\n\n  function CustomEvent(event, params) {\n    params = params || {bubbles: false, cancelable: false, detail: undefined};\n    let evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n    return evt;\n  }\n\n  CustomEvent.prototype = window.Event.prototype;\n  window.CustomEvent = CustomEvent;\n})();\n\n//////////////////////\n// scrollingElement polyfill\n// https://github.com/yangg/scrolling-element\n//////////////////////\n\n(function () {\n  if (document.scrollingElement) {\n    return;\n  }\n  let element = null;\n\n  function scrollingElement() {\n    if (element) {\n      return element;\n    } else if (document.body.scrollTop) {\n      // speed up if scrollTop > 0\n      return (element = document.body);\n    }\n    let iframe = document.createElement('iframe');\n    iframe.style.height = '1px';\n    document.documentElement.appendChild(iframe);\n    let doc = iframe.contentWindow.document;\n    doc.write('<!DOCTYPE html><div style=\"height:9999em\">x</div>');\n    doc.close();\n    let isCompliant = doc.documentElement.scrollHeight > doc.body.scrollHeight;\n    iframe.parentNode.removeChild(iframe);\n    return (element = isCompliant ? document.documentElement : document.body);\n  }\n\n  Object.defineProperty(document, 'scrollingElement', {\n    get: scrollingElement\n  })\n})();\n\n//////////////////////\n// append polyfill\n// https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/append\n//////////////////////\n\n(function (arr) {\n  arr.forEach(function (item) {\n    if (item.hasOwnProperty('append')) {\n      return;\n    }\n    Object.defineProperty(item, 'append', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: function append() {\n        let argArr = Array.prototype.slice.call(arguments),\n          docFrag = document.createDocumentFragment();\n\n        argArr.forEach(function (argItem) {\n          let isNode = argItem instanceof Node;\n          docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));\n        });\n\n        this.appendChild(docFrag);\n      }\n    });\n  });\n})([Element.prototype, Document.prototype, DocumentFragment.prototype]);\n\n//////////////////////\n// before polyfill\n// https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/before\n//////////////////////\n\n(function (arr) {\n  arr.forEach(function (item) {\n    if (item.hasOwnProperty('before')) {\n      return;\n    }\n    Object.defineProperty(item, 'before', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: function before() {\n        let argArr = Array.prototype.slice.call(arguments),\n          docFrag = document.createDocumentFragment();\n\n        argArr.forEach(function (argItem) {\n          let isNode = argItem instanceof Node;\n          docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));\n        });\n\n        this.parentNode.insertBefore(docFrag, this);\n      }\n    });\n  });\n})([Element.prototype, CharacterData.prototype, DocumentType.prototype]);\n\n//////////////////////\n// entries polyfill\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\n//////////////////////\n\n(function (obj) {\n  if (!obj.entries) {\n    obj.entries = function( obj ){\n      let ownProps = Object.keys( obj ),\n        i = ownProps.length,\n        resArray = new Array(i); // preallocate the Array\n      while (i--)\n        resArray[i] = [ownProps[i], obj[ownProps[i]]];\n\n      return resArray;\n    };\n  }\n})(Object);\n\n//////////////////////\n// Array.from polyfill\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\n//////////////////////\n\n(function (arr) {\n  if (!arr.from) {\n    arr.from = (function () {\n      var toStr = Object.prototype.toString;\n      var isCallable = function (fn) {\n        return typeof fn === 'function' || toStr.call(fn) === '[object Function]';\n      };\n      var toInteger = function (value) {\n        var number = Number(value);\n        if (isNaN(number)) { return 0; }\n        if (number === 0 || !isFinite(number)) { return number; }\n        return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));\n      };\n      var maxSafeInteger = Math.pow(2, 53) - 1;\n      var toLength = function (value) {\n        var len = toInteger(value);\n        return Math.min(Math.max(len, 0), maxSafeInteger);\n      };\n\n      // The length property of the from method is 1.\n      return function from(arrayLike/*, mapFn, thisArg */) {\n        // 1. Let C be the this value.\n        var C = this;\n\n        // 2. Let items be ToObject(arrayLike).\n        var items = Object(arrayLike);\n\n        // 3. ReturnIfAbrupt(items).\n        if (arrayLike == null) {\n          throw new TypeError('Array.from requires an array-like object - not null or undefined');\n        }\n\n        // 4. If mapfn is undefined, then let mapping be false.\n        var mapFn = arguments.length > 1 ? arguments[1] : void undefined;\n        var T;\n        if (typeof mapFn !== 'undefined') {\n          // 5. else\n          // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.\n          if (!isCallable(mapFn)) {\n            throw new TypeError('Array.from: when provided, the second argument must be a function');\n          }\n\n          // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.\n          if (arguments.length > 2) {\n            T = arguments[2];\n          }\n        }\n\n        // 10. Let lenValue be Get(items, \"length\").\n        // 11. Let len be ToLength(lenValue).\n        var len = toLength(items.length);\n\n        // 13. If IsConstructor(C) is true, then\n        // 13. a. Let A be the result of calling the [[Construct]] internal method\n        // of C with an argument list containing the single item len.\n        // 14. a. Else, Let A be ArrayCreate(len).\n        var A = isCallable(C) ? Object(new C(len)) : new Array(len);\n\n        // 16. Let k be 0.\n        var k = 0;\n        // 17. Repeat, while k < len (also steps a - h)\n        var kValue;\n        while (k < len) {\n          kValue = items[k];\n          if (mapFn) {\n            A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);\n          } else {\n            A[k] = kValue;\n          }\n          k += 1;\n        }\n        // 18. Let putStatus be Put(A, \"length\", len, true).\n        A.length = len;\n        // 20. Return A.\n        return A;\n      };\n    }());\n  }\n})(Array);\n","/* xtend (https://getxtend.com/)\n@copyright (c) 2017 - 2018 Riccardo Caroli\n@license MIT (https://github.com/minimit/xtend-library/blob/master/LICENSE) */\n\n'use strict';\n\nimport 'babel-polyfill';\n\nimport {XtUtil} from './xtend-utils';\n\n//////////////////////\n// Xt\n//////////////////////\n\nclass Xt {\n\n  /**\n   * constructor\n   * @param {Node|HTMLElement} object Base node\n   * @param {Object} jsOptions User options\n   * @param {String} attr Attribute name with json options\n   * @constructor\n   */\n  constructor(object, jsOptions = {}, attr) {\n    this.object = object;\n    if (this.object) {\n      this.defaults = this.constructor.defaults;\n      // js options\n      this.options = XtUtil.merge([this.defaults, jsOptions]);\n      // markup options\n      let markupOptions = this.object.getAttribute(attr);\n      this.options = XtUtil.merge([this.options, markupOptions ? JSON.parse(markupOptions) : {}]);\n      // classes\n      if (this.options.class) {\n        this.options.classes = [...this.options.class.split(' ')];\n      }\n      // init\n      this.initSetup();\n      this.initScope();\n      this.initEvents();\n      this.initAria();\n    }\n  }\n\n  //////////////////////\n  // init\n  //////////////////////\n\n  /**\n   * setup namespace, container and options\n   */\n  initSetup() {\n    let self = this;\n    let options = self.options;\n    // setup (based on xtend mode)\n    if (options.targets && options.targets.indexOf('#') !== -1) {\n      // xtend all mode\n      this.mode = 'all';\n      this.container = document.documentElement;\n      options.max = Infinity;\n      this.namespace = options.targets.toString() + '-' + options.classes.toString();\n    } else {\n      // xtend unique mode\n      this.mode = 'unique';\n      this.container = this.object;\n      this.namespace = XtUtil.getUniqueID();\n    }\n    // final namespace\n    this.namespace = this.namespace.replace(/\\W+/g, '');\n    // currents array based on namespace (so shared between Xt objects)\n    if (!this.getCurrents()) {\n      this.setCurrents([]);\n    }\n  }\n\n  /**\n   * init elements, targets and currents\n   */\n  initScope() {\n    let self = this;\n    let options = self.options;\n    // elements\n    this.elements = [];\n    if (options.elements) {\n      this.elements = XtUtil.arrSingle(this.container.querySelectorAll(options.elements));\n    }\n    if (!this.elements.length) {\n      this.elements = XtUtil.arrSingle(this.object);\n      // @FIX on next frame set all elements querying the namespace\n      XtUtil.requestAnimationFrame.call(window, function () {\n        let namespaceQuery = '[data-xt-id=' + self.namespace + ']';\n        self.elements = XtUtil.arrSingle(document.documentElement.querySelectorAll(namespaceQuery));\n      });\n    }\n    // targets\n    if (options.targets) {\n      let arr = Array.from(this.container.querySelectorAll(options.targets));\n      arr = arr.filter(x => !XtUtil.parents(x, options.targets).length); // filter out parent\n      this.targets = arr;\n    }\n    // appendTo\n    if (options.appendTo) {\n      let appendToTarget = document.documentElement.querySelectorAll(options.appendTo);\n      if (appendToTarget.length) {\n        this.targets.forEach(function (el) {\n          appendToTarget[0].appendChild(el);\n        });\n      }\n    }\n    // @FIX set namespace for next frame\n    for (let el of this.elements) {\n      el.setAttribute('data-xt-id', self.namespace);\n    }\n    // currents\n    XtUtil.requestAnimationFrame.call(window, function () {\n      if (self.elements.length) {\n        // activate options.class\n        for (let el of self.elements) {\n          if (el.classList.contains(...options.classes)) {\n            el.classList.remove(...options.classes); // remove to activate also targets\n            self.eventOn(el);\n          }\n        }\n        // if currents < min\n        let todo = options.min - self.getCurrents().length;\n        if (todo) {\n          for (let i = 0; i < todo; i++) {\n            self.eventOn(self.elements[i]);\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * init aria\n   */\n  initAria() {\n    if (this.targets) {\n      for (let tr of this.targets) {\n        // aria-label\n        let headers = tr.querySelectorAll('h1, h2, h3, h4, h5, h6');\n        let label = headers.length ? headers : this.getElementsFromTarget(tr);\n        if (label.length) {\n          label = label[0].innerText.replace(/\\s+/g, ' ').trim();\n          tr.setAttribute('aria-label', label);\n        }\n      }\n    }\n  }\n\n  /**\n   * init events\n   */\n  initEvents() {\n    let self = this;\n    let options = self.options;\n    // events\n    for (let el of this.elements) {\n      if (options.on) {\n        // handler\n        let xtOnHandler = XtUtil.dataStorage.put(el, 'xtOnHandler', self.eventOnHandler.bind(self).bind(self, el));\n        // event\n        let events = [...options.on.split(' ')];\n        for (let event of events) {\n          el.removeEventListener(event, xtOnHandler);\n          el.addEventListener(event, xtOnHandler);\n        }\n        // listener\n        el.addEventListener('on.trigger', xtOnHandler);\n      }\n      if (options.off) {\n        // handler\n        let xtOffHandler = XtUtil.dataStorage.put(el, 'xtOffHandler', self.eventOffHandler.bind(self).bind(self, el));\n        // event\n        let events = [...options.off.split(' ')];\n        for (let event of events) {\n          el.removeEventListener(event, xtOffHandler);\n          el.addEventListener(event, xtOffHandler);\n        }\n        // listener\n        el.addEventListener('off.trigger', xtOffHandler);\n      }\n    }\n    // listener\n    for (let tr of this.targets) {\n      let el = this.getElementsFromTarget(tr)[0];\n      if (el) {\n        // handler\n        let xtOnHandler = XtUtil.dataStorage.put(el, 'xtOnHandler', self.eventOnHandler.bind(self).bind(self, el));\n        let xtOffHandler = XtUtil.dataStorage.put(el, 'xtOffHandler', self.eventOffHandler.bind(self).bind(self, el));\n        // listener\n        tr.addEventListener('on.trigger', xtOnHandler);\n        tr.addEventListener('off.trigger', xtOffHandler);\n      }\n    }\n    // auto\n    if (options.auto) {\n      this.auto();\n      // focus and blur\n      window.addEventListener('focus', function () {\n        self.auto();\n      });\n      window.addEventListener('blur', function () {\n        self.autoStop();\n      });\n    }\n  }\n\n  /**\n   * element on handler\n   * @param {Node|HTMLElement} element\n   * @param {Event} e\n   */\n  eventOnHandler(element, e) {\n    let eventLimit = this.container.querySelectorAll('.event-limit');\n    if (eventLimit.length) {\n      if (XtUtil.checkOutside(e, eventLimit)) {\n        this.eventOn(element);\n      }\n    } else {\n      this.eventOn(element);\n    }\n    // auto\n    if (this.options.autoPause) {\n      this.autoPause();\n    } else if (this.options.auto) {\n      this.auto();\n    }\n  }\n\n  /**\n   * element off handler\n   * @param {Node|HTMLElement} element\n   * @param {Event} e\n   */\n  eventOffHandler(element, e) {\n    let eventLimit = this.container.querySelectorAll('.event-limit');\n    if (eventLimit.length) {\n      if (XtUtil.checkOutside(e, eventLimit)) {\n        this.eventOff(element);\n      }\n    } else {\n      this.eventOff(element);\n    }\n  }\n\n  /**\n   * set auto change\n   * @param {Boolean} instant\n   */\n  auto(instant = false) {\n    let self = this;\n    let options = self.options;\n    // auto\n    this.autoStop();\n    let time = !instant ? options.auto : 0;\n    self.autoInterval = setInterval(function () {\n      if (!options.autoAlways && self.object.offsetParent === null) { // if not :visible don't change\n        return false;\n      }\n      self.autoCurrent = self.autoCurrent !== undefined ? self.autoCurrent + 1 : 0;\n      self.autoCurrent = self.autoCurrent >= self.elements.length ? 0 : self.autoCurrent;\n      self.eventOn(self.elements[self.autoCurrent]);\n    }, time);\n  }\n\n  /**\n   * set autoPause change\n   * @param {Boolean} instant\n   */\n  autoPause(instant = false) {\n    let self = this;\n    let options = self.options;\n    // autoPause\n    this.autoStop();\n    let time = !instant ? options.autoPause : 0;\n    if (time !== 'stop') {\n      self.autoPauseTimeout = setTimeout(function () {\n        self.auto(true);\n        self.auto();\n      }, time);\n    }\n  }\n\n  /**\n   * stop auto change\n   */\n  autoStop() {\n    clearInterval(this.autoInterval);\n    clearTimeout(this.autoPauseTimeout);\n  }\n\n  //////////////////////\n  // utils\n  //////////////////////\n\n  /**\n   * choose which elements to activate/deactivate (based on xtend mode and containers)\n   * @param {Node|HTMLElement} element Element that triggered interaction\n   * @returns {Object} object.all and object.single\n   */\n  getElements(element) {\n    if (!this.elements || !this.elements.length) {\n      return {all: [], single: null};\n    }\n    if (this.mode === 'all') {\n      // choose all elements\n      return {all: this.elements, single: this.elements[0]};\n    } else if (this.mode === 'unique') {\n      // choose element by group\n      let group = element.getAttribute('data-group');\n      if (group) {\n        // all group elements if group\n        let groupElements = Array.from(this.elements).filter(x => x.getAttribute('data-group') === group);\n        let final = XtUtil.arrSingle(groupElements);\n        return {all: final, single: final[0]};\n      } else {\n        // element if not group\n        let final = element;\n        return {all: XtUtil.arrSingle(final), single: final};\n      }\n    }\n  }\n\n  /**\n   * choose which targets to activate/deactivate (based on xtend mode and containers)\n   * @param {Node|HTMLElement} element Element that triggered interaction\n   * @returns {Array}\n   */\n  getTargets(element) {\n    if (!this.targets || !this.targets.length) {\n      return [];\n    }\n    if (this.mode === 'all') {\n      // choose all targets\n      return this.targets;\n    } else if (this.mode === 'unique') {\n      // choose only target by group\n      let group = element.getAttribute('data-group');\n      let groupElements = Array.from(this.elements).filter(x => x.getAttribute('data-group') === group);\n      let groupTargets = Array.from(this.targets).filter(x => x.getAttribute('data-group') === group);\n      let final;\n      if (group) {\n        // all group targets if group\n        final = groupTargets;\n        return XtUtil.arrSingle(final);\n      } else {\n        // not group targets by index if not group\n        let index = groupElements.findIndex(x => x === element);\n        final = groupTargets[index];\n        return XtUtil.arrSingle(final);\n      }\n    }\n  }\n\n  /**\n   * choose which elements to activate/deactivate from target (based on xtend mode and containers)\n   * @param {Node|HTMLElement} element Target to trigger interaction on\n   * @returns {Array}\n   */\n  getElementsFromTarget(target) {\n    if (!this.elements || !this.elements.length) {\n      return [];\n    }\n    // choose only target by group\n    let group = target.getAttribute('data-group');\n    let groupElements = Array.from(this.elements).filter(x => x.getAttribute('data-group') === group);\n    let groupTargets = Array.from(this.targets).filter(x => x.getAttribute('data-group') === group);\n    let final;\n    if (group) {\n      // all group targets if group\n      final = groupElements;\n      return XtUtil.arrSingle(final);\n    } else {\n      // not group targets by index if not group\n      let index = groupTargets.findIndex(x => x === target);\n      final = groupElements[index];\n      return XtUtil.arrSingle(final);\n    }\n  }\n\n  /**\n   * additional elements to activate/deactivate\n   * @returns {NodeList|Array}\n   */\n  getAdditional() {\n    if (!this.options.additional) {\n      return [];\n    } else {\n      return this.object.querySelectorAll(this.options.additional);\n    }\n  }\n\n  /**\n   * get currents based on namespace (so shared between Xt objects)\n   * @returns {Array}\n   */\n  getCurrents() {\n    return XtUtil.currents[this.namespace];\n  }\n\n  /**\n   * set currents based on namespace (so shared between Xt objects)\n   * @param {Array} arr\n   */\n  setCurrents(arr) {\n    XtUtil.currents[this.namespace] = arr;\n  }\n\n  /**\n   * add current based on namespace (so shared between Xt objects)\n   * @param {Node|HTMLElement} element To be added\n   */\n  addCurrent(element) {\n    let arr = XtUtil.currents[this.namespace];\n    arr.push(element);\n  }\n\n  /**\n   * remove currents based on namespace (so shared between Xt objects)\n   * @param {Node|HTMLElement} element To be removed\n   */\n  removeCurrent(element) {\n    XtUtil.currents[this.namespace] = XtUtil.currents[this.namespace].filter(x => x !== element);\n  }\n\n  //////////////////////\n  // events\n  //////////////////////\n\n  /**\n   * check element on\n   * @param {Node|HTMLElement} element To be activated\n   * @returns {Boolean} If eventOn changes activation\n   */\n  checkOn(element) {\n    if ((!element.classList.contains(...this.options.classes) || element.classList.contains('off-block')) && !element.classList.contains('on-block')) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * check element off\n   * @param {Node|HTMLElement} element To be activated\n   * @returns {Boolean} If eventOff changes activation\n   */\n  checkOff(element) {\n    // if currents < min\n    let todo = this.options.min - this.getCurrents().length;\n    if (!todo) {\n      return false;\n    }\n    if ((element.classList.contains(...this.options.classes) || element.classList.contains('on-block')) && !element.classList.contains('off-block')) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * element on\n   * @param {Node|HTMLElement} element To be activated\n   */\n  eventOn(element) {\n    let self = this;\n    let options = self.options;\n    // activate or deactivate\n    if (this.checkOn(element)) {\n      let fElements = this.getElements(element);\n      this.addCurrent(fElements.single);\n      let targets = this.getTargets(element);\n      let additional = this.getAdditional();\n      let activationDelay = {\n        elements: function () {\n          self.activationOn(fElements.all, fElements, 'elements');\n        },\n        targets: function () {\n          self.activationOn(targets, fElements, 'targets');\n        },\n        additional: function () {\n          self.activationOn(additional, fElements, 'additional');\n        },\n      };\n      // set autoCurrent\n      if (options.auto) {\n        let index = 0;\n        for (let [i, el] of self.elements.entries()) {\n          if (el === element) {\n            index = i;\n            break;\n          }\n        }\n        self.autoCurrent = index;\n      }\n      // if currents > max\n      let currents = this.getCurrents();\n      if (currents.length > options.max) {\n        this.eventOff(currents[0], activationDelay);\n      } else {\n        activationDelay.elements();\n        activationDelay.targets();\n        activationDelay.additional();\n      }\n    } else if (options.toggle) {\n      // toggle\n      this.eventOff(element);\n    }\n  }\n\n  /**\n   * element off\n   * @param {Node|HTMLElement} element To be deactivated\n   * @param {Object} activationDelay Object with delayed activations\n   */\n  eventOff(element, activationDelay = null) {\n    // deactivate\n    if (this.checkOff(element)) {\n      let fElements = this.getElements(element);\n      this.removeCurrent(fElements.single);\n      this.activationOff(fElements.all, fElements, 'elements', activationDelay);\n      let targets = this.getTargets(element);\n      this.activationOff(targets, fElements, 'targets', activationDelay);\n      let additional = this.getAdditional();\n      this.activationOff(additional, fElements, 'additional', activationDelay);\n    }\n  }\n\n  /**\n   * element on activation\n   * @param {NodeList|Array} els Elements to be activated\n   * @param {Object} fElements Additional elements\n   * @param {String} type Type of elements\n   */\n  activationOn(els, fElements, type) {\n    let self = this;\n    let options = self.options;\n    // activate\n    let activate = function (self, el, fElements, type) {\n      el.classList.add(...options.classes);\n      el.classList.remove('out');\n      self.activationOnAnimate(el, type);\n      // specials\n      if (type === 'targets') {\n        self.specialClassHtmlOn();\n        self.specialBackdrop(el);\n        self.specialCenterOn(el);\n        self.specialMiddleOn(el);\n        self.specialCollapseOn(el);\n        self.specialCloseOn(el, fElements.single);\n        self.specialScrollbarOn();\n      }\n      // dispatch\n      el.dispatchEvent(new CustomEvent('on'));\n    };\n    // delay\n    for (let el of els) {\n      el.classList.remove('off-block');\n      clearTimeout(el.dataset.xtDelayTimeout);\n      clearTimeout(el.dataset.xtAnimTimeout);\n      let delay = el.dataset.xtOnDelay;\n      if (delay) {\n        el.classList.add('on-block');\n        el.dataset.xtDelayTimeout = setTimeout(function (self, el, fElements, type) {\n          el.classList.remove('on-block');\n          activate(self, el, fElements, type);\n        }, parseFloat(delay), self, el, fElements, type).toString();\n      } else {\n        activate(self, el, fElements, type);\n      }\n    }\n  }\n\n  /**\n   * element off activation\n   * @param {NodeList|Array} els Elements to be deactivated\n   * @param {Object} fElements Additional elements\n   * @param {String} type Type of elements\n   * @param {Object} activationDelay Object with delayed activations\n   */\n  activationOff(els, fElements, type, activationDelay) {\n    let self = this;\n    let options = self.options;\n    // deactivate\n    let deactivate = function (self, el, fElements, type, activationDelay) {\n      el.classList.remove(...options.classes);\n      el.classList.add('out');\n      self.activationOffAnimate(el, type, activationDelay);\n      // activationDelay\n      if (activationDelay && activationDelay[type] && !activationDelay[type + 'done']) {\n        if (options.instant && options.instant[type]) {\n          activationDelay[type]();\n          activationDelay[type + 'done'] = true;\n        }\n      }\n      // specials\n      if (type === 'targets') {\n        self.specialClassHtmlOff();\n        self.specialCollapseOff(el);\n        self.specialCloseOff(el);\n      }\n      // dispatch\n      el.dispatchEvent(new CustomEvent('off'));\n    };\n    // delay\n    for (let el of els) {\n      el.classList.remove('on-block');\n      clearTimeout(el.dataset.xtDelayTimeout);\n      clearTimeout(el.dataset.xtAnimTimeout);\n      let delay = el.dataset.xtOffDelay;\n      if (delay) {\n        el.classList.add('off-block');\n        el.dataset.xtDelayTimeout = setTimeout(function (self, el, fElements, type, activationDelay) {\n          el.classList.remove('off-block');\n          deactivate(self, el, fElements, type, activationDelay);\n        }, parseFloat(delay), self, el, fElements, type, activationDelay).toString();\n      } else {\n        deactivate(self, el, fElements, type, activationDelay);\n      }\n    }\n  }\n\n  /**\n   * element on animation\n   * @param {Node|HTMLElement} el Element to be animated\n   * @param {String} type Type of element\n   */\n  activationOnAnimate(el, type) {\n    // onDone\n    let onDone = function (el, type) {\n      // collapse-width and collapse-height\n      if (el.classList.contains('collapse-height')) {\n        el.style.height = 'auto';\n      }\n      if (el.classList.contains('collapse-width')) {\n        el.style.width = 'auto';\n      }\n    };\n    // delay onDone\n    let timing = this.activationTiming(el);\n    clearTimeout(el.dataset.xtAnimTimeout);\n    if (!timing) {\n      onDone(el, type);\n    } else {\n      el.dataset.xtAnimTimeout = setTimeout(function (el, type) {\n        onDone(el, type);\n      }, timing, el, type).toString();\n    }\n  }\n\n  /**\n   * element off animation\n   * @param {Node|HTMLElement} el Element to be animated\n   * @param {String} type Type of element\n   * @param {Object} activationDelay Object with delayed activations\n   */\n  activationOffAnimate(el, type, activationDelay) {\n    let self = this;\n    let options = self.options;\n    // onDone\n    let onDone = function (el, type) {\n      el.classList.remove('out');\n      // specials\n      if (type === 'targets') {\n        self.specialScrollbarOff();\n      }\n      // activationDelay\n      if (activationDelay && activationDelay[type] && !activationDelay[type + 'done']) {\n        if (!options.instant || !options.instant[type]) {\n          activationDelay[type]();\n          activationDelay[type + 'done'] = true;\n        }\n      }\n    };\n    // delay onDone\n    let timing = this.activationTiming(el);\n    clearTimeout(el.dataset.xtAnimTimeout);\n    if (!timing) {\n      onDone(el, type);\n    } else {\n      el.dataset.xtAnimTimeout = setTimeout(function (el, type) {\n        onDone(el, type);\n      }, timing, el, type).toString();\n    }\n  }\n\n  /**\n   * get transition or animation timing\n   * @param {Node|HTMLElement} el To be animated\n   * @returns {Number} Time in milliseconds\n   */\n  activationTiming(el) {\n    let self = this;\n    let options = self.options;\n    // timing\n    let timing = options.timing;\n    if (timing !== undefined) {\n      return timing;\n    } else {\n      let style = getComputedStyle(el);\n      let transition = parseFloat(style.transitionDuration) + parseFloat(style.transitionDelay);\n      let animation = parseFloat(style.animationDuration) + parseFloat(style.animationDelay);\n      if (transition || animation) {\n        timing = Math.max(transition, animation);\n      }\n      return timing * 1000;\n    }\n  }\n\n  //////////////////////\n  // activation specials\n  //////////////////////\n\n  /**\n   * add html class\n   */\n  specialClassHtmlOn() {\n    let self = this;\n    let options = self.options;\n    //\n    if (options.classHtml) {\n      let container = document.documentElement;\n      container.classList.add(...options.classHtml.split(' '));\n    }\n  }\n\n  /**\n   * remove html class\n   */\n  specialClassHtmlOff() {\n    let self = this;\n    let options = self.options;\n    //\n    if (options.classHtml) {\n      let container = document.documentElement;\n      container.classList.remove(...options.classHtml.split(' '));\n    }\n  }\n\n  /**\n   * backdrop append to element\n   * @param {Node|HTMLElement} el Element\n   */\n  specialBackdrop(el) {\n    let self = this;\n    let options = self.options;\n    //\n    if (options.backdrop) {\n      let elements;\n      if (options.backdrop === 'object') {\n        elements = XtUtil.arrSingle(this.object);\n      } else if (options.backdrop === 'targets') {\n        elements = XtUtil.arrSingle(el);\n      } else {\n        elements = el.querySelectorAll(options.backdrop);\n        if (!elements.length) {\n          elements = this.object.querySelectorAll(options.backdrop);\n        }\n      }\n      for (let element of elements) {\n        let backdrop = element.querySelectorAll('.xt-backdrop');\n        if (!backdrop.length) {\n          backdrop = XtUtil.createElement('<div class=\"xt-backdrop\"></div>');\n          element.append(backdrop);\n        }\n      }\n    }\n  }\n\n  /**\n   * center position on activation\n   * @param {Node|HTMLElement} el Element\n   */\n  specialCenterOn(el) {\n    if (el.classList.contains('drop-center')) {\n      let add = this.object.clientWidth;\n      let remove = el.clientWidth;\n      el.style.left = ((add - remove) / 2) + 'px';\n    }\n  }\n\n  /**\n   * middle position on activation\n   * @param {Node|HTMLElement} el Element\n   */\n  specialMiddleOn(el) {\n    if (el.classList.contains('drop-middle')) {\n      let add = this.object.clientHeight;\n      let remove = el.clientHeight;\n      el.style.top = ((add - remove) / 2) + 'px';\n    }\n  }\n\n  /**\n   * open collapse on activation\n   * @param {Node|HTMLElement} el Element\n   */\n  specialCollapseOn(el) {\n    if (el.classList.contains('collapse-height')) {\n      el.classList.add('no-transition');\n      el.style.height = 'auto';\n      el.style.paddingTop = '';\n      el.style.paddingBottom = '';\n      let h = el.clientHeight + 'px';\n      let pt = el.style.paddingTop;\n      let pb = el.style.paddingBottom;\n      XtUtil.requestAnimationFrame.call(window, function () {\n        el.style.height = '0';\n        el.style.paddingTop = '0';\n        el.style.paddingBottom = '0';\n        XtUtil.requestAnimationFrame.call(window, function () {\n          el.classList.remove('no-transition');\n          el.style.height = h;\n          el.style.paddingTop = pt;\n          el.style.paddingBottom = pb;\n        });\n      });\n    }\n    if (el.classList.contains('collapse-width')) {\n      el.style.width = 'auto';\n      el.style.paddingLeft = '';\n      el.style.paddingRight = '';\n      let w = el.clientHeight + 'px';\n      let pl = el.style.paddingLeft;\n      let pr = el.style.paddingRight;\n      XtUtil.requestAnimationFrame.call(window, function () {\n        el.style.width = '0';\n        el.style.paddingLeft = '0';\n        el.style.paddingRight = '0';\n        XtUtil.requestAnimationFrame.call(window, function () {\n          el.classList.remove('no-transition');\n          el.style.width = w;\n          el.style.paddingLeft = pl;\n          el.style.paddingRight = pr;\n        });\n      });\n    }\n  }\n\n  /**\n   * close collapse on deactivation\n   * @param {Node|HTMLElement} el Element\n   */\n  specialCollapseOff(el) {\n    if (el.classList.contains('collapse-height')) {\n      let h = el.clientHeight + 'px';\n      let pt = el.style.paddingTop;\n      let pb = el.style.paddingBottom;\n      XtUtil.requestAnimationFrame.call(window, function () {\n        el.style.height = h;\n        el.style.paddingTop = pt;\n        el.style.paddingBottom = pb;\n        XtUtil.requestAnimationFrame.call(window, function () {\n          el.style.height = '0';\n          el.style.paddingTop = '0';\n          el.style.paddingBottom = '0';\n        });\n      });\n    }\n    if (el.classList.contains('collapse-width')) {\n      let w = el.clientWidth + 'px';\n      let pl = el.style.paddingLeft;\n      let pr = el.style.paddingRight;\n      XtUtil.requestAnimationFrame.call(window, function () {\n        el.style.width = w;\n        el.style.paddingLeft = pl;\n        el.style.paddingRight = pr;\n        XtUtil.requestAnimationFrame.call(window, function () {\n          el.style.width = '0';\n          el.style.paddingLeft = '0';\n          el.style.paddingRight = '0';\n        });\n      });\n    }\n  }\n\n  /**\n   * add close events on element\n   * @param {Node|HTMLElement} el Element\n   * @param {Node|HTMLElement} single Element to toggle\n   */\n  specialCloseOn(el, single) {\n    let self = this;\n    let options = self.options;\n    // closeInside\n    if (options.closeInside) {\n      let closeElements = el.querySelectorAll(options.closeInside);\n      XtUtil.requestAnimationFrame.call(window, function () {\n        for (let closeElement of closeElements) {\n          // handler\n          let specialCloseOnHandler = XtUtil.dataStorage.put(el, 'specialCloseOnHandler', self.specialCloseOnHandler.bind(self).bind(self, closeElement, single));\n          // event\n          closeElement.removeEventListener('click', specialCloseOnHandler);\n          closeElement.addEventListener('click', specialCloseOnHandler);\n        }\n      });\n    }\n    // closeOutside\n    if (options.closeOutside) {\n      let closeElements = document.documentElement.querySelectorAll(options.closeOutside);\n      XtUtil.requestAnimationFrame.call(window, function () {\n        for (let closeElement of closeElements) {\n          // handler\n          let specialCloseOffHandler = XtUtil.dataStorage.put(el, 'specialCloseOffHandler', self.specialCloseOffHandler.bind(self).bind(self, el, single));\n          // event\n          closeElement.removeEventListener('click', specialCloseOffHandler);\n          closeElement.addEventListener('click', specialCloseOffHandler);\n        }\n      });\n    }\n  }\n\n  /**\n   * remove close events on element\n   * @param {Node|HTMLElement} el Element\n   */\n  specialCloseOff(el) {\n    let self = this;\n    let options = self.options;\n    // closeInside\n    if (options.closeInside) {\n      let closeElements = el.querySelectorAll(options.closeInside);\n      for (let closeElement of closeElements) {\n        // handler\n        let specialCloseOnHandler = XtUtil.dataStorage.get(el, 'specialCloseOnHandler');\n        closeElement.removeEventListener('click', specialCloseOnHandler);\n      }\n    }\n    // closeOutside\n    if (options.closeOutside) {\n      let closeElements = document.documentElement.querySelectorAll(options.closeOutside);\n      for (let closeElement of closeElements) {\n        let specialCloseOffHandler = XtUtil.dataStorage.get(el, 'specialCloseOffHandler');\n        closeElement.removeEventListener('click', specialCloseOffHandler);\n      }\n    }\n  }\n\n  /**\n   * element on handler\n   * @param {Node|HTMLElement} checkEl\n   * @param {Node|HTMLElement} single\n   * @param {Event} e\n   */\n  specialCloseOnHandler(checkEl, single, e) {\n    if (XtUtil.checkInside(e, XtUtil.arrSingle(checkEl))) {\n      this.eventOff(single);\n    }\n  }\n\n  /**\n   * element off handler\n   * @param {Node|HTMLElement} checkEl\n   * @param {Node|HTMLElement} single\n   * @param {Event} e\n   */\n  specialCloseOffHandler(checkEl, single, e) {\n    if (XtUtil.checkOutside(e, XtUtil.arrSingle(checkEl))) {\n      this.eventOff(single);\n    }\n  }\n\n  /**\n   * scrollbar activation\n   */\n  specialScrollbarOn() {\n    let self = this;\n    let options = self.options;\n    //\n    if (options.scrollbar) {\n      let elements;\n      let width = XtUtil.scrollbarWidth();\n      // check fixed\n      elements = document.documentElement.querySelectorAll('.xt-check-fixed > *');\n      for (let element of elements) {\n        let style = getComputedStyle(element);\n        if (style.position === 'fixed') {\n          element.classList.add('xt-fixed');\n        } else {\n          element.classList.remove('xt-fixed');\n        }\n      }\n      // fixed\n      elements = document.documentElement.querySelectorAll('.xt-fixed');\n      for (let element of elements) {\n        element.style.paddingRight = '';\n        if (self.normalizeWidth(element.clientWidth) === '') {\n          let style = getComputedStyle(element);\n          let padding = style.paddingRight;\n          let str = 'calc(' + padding + ' + ' + width + 'px)';\n          element.classList.add('no-transition');\n          XtUtil.requestAnimationFrame.call(window, function () {\n            element.style.paddingRight = str;\n            XtUtil.requestAnimationFrame.call(window, function () {\n              element.classList.remove('no-transition');\n            });\n          });\n        }\n      }\n      // backdrop\n      elements = document.documentElement.querySelectorAll('.xt-backdrop');\n      for (let element of elements) {\n        element.style.right = width + 'px';\n      }\n      // scroll\n      let container = document.documentElement;\n      container.style.paddingRight = width + 'px';\n      container.classList.add('xt-scrollbar');\n    }\n  }\n\n  /**\n   * scrollbar deactivation\n   */\n  specialScrollbarOff() {\n    let self = this;\n    let options = self.options;\n    //\n    if (options.scrollbar) {\n      let elements;\n      // scroll\n      let container = document.documentElement;\n      container.style.paddingRight = '';\n      container.classList.remove('xt-scrollbar');\n      // fixed\n      elements = document.documentElement.querySelectorAll('.xt-fixed');\n      for (let element of elements) {\n        element.classList.add('no-transition');\n        XtUtil.requestAnimationFrame.call(window, function () {\n          element.style.paddingRight = '';\n          XtUtil.requestAnimationFrame.call(window, function () {\n            element.classList.remove('no-transition');\n          });\n        });\n      }\n      // backdrop\n      elements = document.documentElement.querySelectorAll('.xt-backdrop');\n      for (let element of elements) {\n        element.style.right = '';\n      }\n    }\n  }\n\n  /**\n   * if full width return '' else return value in px\n   * @param {Number|String} width\n   * @returns {String} Value in px\n   */\n  normalizeWidth(width) {\n    width = parseFloat(width);\n    if (width + XtUtil.scrollbarWidth() >= window.innerWidth) {\n      width = '';\n    } else {\n      width += 'px';\n    }\n    return width;\n  }\n\n}\n\n// default\n\nXt.defaults = {\n  \"auto\": false,\n  \"autoPause\": false,\n  \"autoAlways\": false\n};\n\n// export\n\nwindow.Xt = Xt;\nexport {Xt};\n\n//////////////////////\n// XtToggle\n//////////////////////\n\nclass XtToggle extends Xt {\n\n  /**\n   * constructor\n   * @param {Node|HTMLElement} object Base node\n   * @param {Object} jsOptions User options\n   * @constructor\n   */\n  constructor(object, jsOptions = {}) {\n    super(object, jsOptions, 'data-xt-toggle');\n  }\n\n}\n\n// default\n\nXtToggle.defaults = {\n  \"elements\": \":scope > a, :scope > button\",\n  \"targets\": \":scope > [class^=\\\"toggle-\\\"], :scope > [class*=\\\" toggle-\\\"]\",\n  \"class\": \"active\",\n  \"instant\": {\"elements\": true},\n  \"on\": \"click\",\n  \"toggle\": true,\n  \"min\": 0,\n  \"max\": 1\n};\n\n// export\n\nwindow.XtToggle = XtToggle;\nexport {XtToggle};\n\n//////////////////////\n// XtDrop\n//////////////////////\n\nclass XtDrop extends Xt {\n\n  /**\n   * constructor\n   * @param {Node|HTMLElement} object Base node\n   * @param {Object} jsOptions User options\n   * @constructor\n   */\n  constructor(object, jsOptions = {}) {\n    super(object, jsOptions, 'data-xt-drop');\n  }\n\n  /**\n   * init aria\n   */\n  initAria() {\n    if (this.targets) {\n      for (let tr of this.targets) {\n        // aria-label\n        if (this.options.additional) {\n          let label = this.getAdditional();\n          if (label.length) {\n            label = label[0].innerText.replace(/\\s+/g, ' ').trim();\n            tr.setAttribute('aria-label', label);\n          }\n        }\n      }\n    }\n  }\n\n}\n\n// default\n\nXtDrop.defaults = {\n  \"elements\": \":scope\",\n  \"targets\": \":scope > .drop\",\n  \"additional\": \":scope > a, :scope > button\",\n  \"class\": \"active\",\n  \"instant\": {\"elements\": true},\n  \"on\": \"click\",\n  \"toggle\": true,\n  \"min\": 0,\n  \"max\": 1,\n  \"closeOutside\": \"body\"\n};\n\n// export\n\nwindow.XtDrop = XtDrop;\nexport {XtDrop};\n\n//////////////////////\n// XtOverlay\n//////////////////////\n\nclass XtOverlay extends Xt {\n\n  /**\n   * constructor\n   * @param {Node|HTMLElement} object Base node\n   * @param {Object} jsOptions User options\n   * @constructor\n   */\n  constructor(object, jsOptions = {}) {\n    super(object, jsOptions, 'data-xt-overlay');\n  }\n\n  /**\n   * init aria\n   */\n  initAria() {\n    super.initAria();\n    if (this.targets) {\n      for (let tr of this.targets) {\n        // role\n        tr.setAttribute('role', 'dialog');\n        tr.setAttribute('aria-modal', 'true');\n      }\n    }\n  }\n\n}\n\n// default\n\nXtOverlay.defaults = {\n  \"elements\": \":scope > a, :scope > button\",\n  \"targets\": \":scope > .overlay-outer\",\n  \"class\": \"active\",\n  \"instant\": {\"elements\": true},\n  \"on\": \"click\",\n  \"toggle\": true,\n  \"min\": 0,\n  \"max\": 1,\n  \"appendTo\": \"body\",\n  \"backdrop\": \"targets\",\n  \"classHtml\": \"xt-overlay\",\n  \"closeInside\": \".overlay-dismiss, :scope > .xt-backdrop, :scope .overlay-inner > .btn-close\",\n  \"scrollbar\": true\n};\n\n// export\n\nwindow.XtOverlay = XtOverlay;\nexport {XtOverlay};\n\n//////////////////////\n// XtSticky\n//////////////////////\n\nclass XtSticky extends Xt {\n\n  /**\n   * constructor\n   * @param {Node|HTMLElement} object Base node\n   * @param {Object} jsOptions User options\n   * @constructor\n   */\n  constructor(object, jsOptions = {}) {\n    super(object, jsOptions, 'data-xt-sticky');\n  }\n\n  //////////////////////\n  // init\n  //////////////////////\n\n  /**\n   * init elements, targets and currents\n   */\n  initScope() {\n    super.initScope();\n    // mode\n    this.mode = 'all';\n    // container\n    this.container = XtUtil.parents(this.object, '.xt-container');\n    if (!this.container.length) {\n      this.container = XtUtil.createElement('<div class=\"xt-container xt-check-fixed\"></div>');\n      this.object.before(this.container);\n      this.container.append(this.object);\n      this.container = XtUtil.parents(this.object, '.xt-container');\n    }\n    // targets\n    this.targets = this.container[0].querySelectorAll('.xt-clone');\n    if (!this.targets.length) {\n      this.targets = this.object.cloneNode(true);\n      this.targets.classList.add('xt-clone');\n      this.targets.setAttribute('aria-hidden', 'true');\n      for (let elId of this.targets.querySelectorAll('[id]')) {\n        elId.setAttribute('id', elId.getAttribute('id') + '-clone');\n      }\n      for (let elName of this.targets.querySelectorAll('[name]')) {\n        elName.setAttribute('name', elName.getAttribute('name') + '-clone');\n      }\n      this.container[0].append(this.targets);\n    }\n    this.targets = XtUtil.arrSingle(this.targets);\n    // xt-fixed\n    this.object.classList.add('xt-fixed');\n    // hide\n    if (this.options.hide === 'down') {\n      this.object.classList.add('sticky-hide-down');\n    } else {\n      this.object.classList.remove('sticky-hide-down');\n    }\n    if (this.options.hide === 'up') {\n      this.object.classList.add('sticky-hide-up');\n    } else {\n      this.object.classList.remove('sticky-hide-up');\n    }\n    // z-index\n    this.unique = XtUtil.getUniqueNum();\n    this.object.style.zIndex = '' + (100 - this.unique);\n  }\n\n  /**\n   * init events\n   */\n  initEvents() {\n    let self = this;\n    let options = self.options;\n    // events\n    if (options.on) {\n      // handler\n      let stickyHandler = XtUtil.dataStorage.put(window, 'stickyHandler', self.eventOnHandler.bind(self));\n      // event\n      let events = [...options.on.split(' ')];\n      for (let event of events) {\n        window.removeEventListener(event, stickyHandler);\n        window.addEventListener(event, stickyHandler);\n      }\n      window.addEventListener('on.sticky', stickyHandler);\n    }\n    // trigger initial\n    window.dispatchEvent(new CustomEvent('on.sticky'));\n  }\n\n  /**\n   * element on handler\n   * @param {Node|HTMLElement} element\n   * @param {Event} e\n   */\n  eventOnHandler(element, e) {\n    this.eventScroll(this.object);\n  }\n\n  //////////////////////\n  // events\n  //////////////////////\n\n  /**\n   * window scroll\n   * @param {Node|HTMLElement} element To be activated or deactivated\n   */\n  eventScroll(element) {\n    let self = this;\n    let options = self.options;\n    // vars\n    let anim = true;\n    let hide = false;\n    let scrollInverse = false;\n    let add = 0;\n    let addHide = 0;\n    let windowHeight = window.innerHeight;\n    let el = self.object;\n    let rectElTop = el.getBoundingClientRect().top;\n    let heightEl = parseFloat(getComputedStyle(el).height);\n    let heightTarget = parseFloat(getComputedStyle(self.targets[0]).height);\n    let rectContainerTop = self.container[0].getBoundingClientRect().top;\n    let scrollingElement = document.scrollingElement;\n    let scrollHeight = scrollingElement.scrollHeight;\n    let scrollTop = scrollingElement.scrollTop;\n    let scrollTopOld = self.scrollTopOld;\n    // direction\n    if (scrollTop < scrollTopOld) {\n      el.classList.remove('sticky-down');\n      el.classList.add('sticky-up');\n      scrollInverse = true;\n    } else {\n      el.classList.add('sticky-down');\n      el.classList.remove('sticky-up');\n    }\n    // hide\n    if (options.hide === 'down') {\n      if (!scrollInverse) {\n        addHide = heightTarget;\n      }\n    }\n    if (options.hide === 'up') {\n      if (scrollInverse) {\n        addHide = heightTarget;\n      }\n    }\n    // scroll\n    let top = self.eventScrollPos(options.limit['top'] || self.targets, scrollTop, rectContainerTop);\n    let bottom = self.eventScrollPos(options.limit['bottom'], scrollTop, Infinity);\n    if (options.position === 'top') {\n      bottom -= heightTarget;\n    }\n    if (options.position === 'bottom') {\n      top -= windowHeight - heightTarget;\n      bottom = Math.abs(scrollHeight - windowHeight - bottom);\n    }\n    // contain and add\n    let addTop = 0;\n    let addBottom = 0;\n    if (options.contain) {\n      if (options.contain['top']) {\n        let addTopObj = self.eventScrollHeight(options.contain['top'], scrollInverse);\n        addTop = addTopObj.val;\n        if (addTop !== null && addTop > rectContainerTop) {\n          add = addTop;\n          if (!addTopObj.foundHide) {\n            anim = false;\n          }\n        } else {\n          addTop = null;\n        }\n      }\n      if (options.contain['bottom']) {\n        addBottom = self.eventScrollPos(options.contain['bottom']);\n        if (addBottom !== null && addBottom < heightEl + addTop) {\n          add = addBottom - heightEl;\n          anim = false;\n        } else {\n          addBottom = null;\n        }\n      }\n    }\n    // save real add for calculation\n    el.dataset.xtAddSticky = add.toString();\n    // activation\n    let checkTop = scrollTop >= top - add + addHide;\n    let checkBottom = scrollTop < bottom + add - addHide;\n    if (checkTop && checkBottom) {\n      // inside\n      self.eventOn(element);\n      // hide\n      if (addHide) {\n        hide = true;\n      }\n    } else {\n      // outside\n      self.eventOff(element);\n    }\n    // after active\n    if (el.classList.contains('active')) {\n      // hide\n      if (hide) {\n        add = -heightEl;\n        if (!el.classList.contains('sticky-hide')) {\n          el.classList.add('sticky-hide');\n          el.dispatchEvent(new CustomEvent('sticky.hide'));\n        }\n      } else {\n        if (el.classList.contains('sticky-hide')) {\n          el.classList.remove('sticky-hide');\n          el.dispatchEvent(new CustomEvent('sticky.show'));\n        }\n      }\n    } else {\n      // reset\n      add = 0;\n      anim = false;\n    }\n    // anim\n    if (anim && scrollTopOld !== undefined) {\n      if (!el.classList.contains('sticky-anim')) {\n        el.classList.add('sticky-anim');\n      }\n    } else {\n      if (el.classList.contains('sticky-anim')) {\n        el.classList.remove('sticky-anim');\n      }\n    }\n    // top and bottom\n    if (!checkTop) {\n      if (!el.classList.contains('sticky-top')) {\n        el.classList.add('sticky-top');\n      }\n    } else {\n      if (el.classList.contains('sticky-top')) {\n        el.classList.remove('sticky-top');\n      }\n    }\n    if (!checkBottom) {\n      if (!el.classList.contains('sticky-bottom')) {\n        el.classList.add('sticky-bottom');\n      }\n    } else {\n      if (el.classList.contains('sticky-bottom')) {\n        el.classList.remove('sticky-bottom');\n      }\n    }\n    // set add\n    if (add !== self.addOld) {\n      el.classList.add('no-transition');\n      if (self.addOld !== undefined) {\n        el.style[options.position] = rectElTop + 'px';\n      }\n      XtUtil.cancelAnimationFrame.call(window, self.eventFrame);\n      self.eventFrame = XtUtil.requestAnimationFrame.call(window, function () {\n        el.classList.remove('no-transition');\n        el.style[options.position] = add + 'px';\n      });\n    }\n    // fix position fixed width 100% of parent\n    let width = self.normalizeWidth(self.container[0].clientWidth);\n    if (el.style.width !== width) {\n      el.style.width = width;\n    }\n    // save for direction\n    self.addOld = add;\n    self.scrollTopOld = scrollTop;\n  }\n\n  /**\n   * get position of option\n   * @param {String|Number|Element} option\n   * @param {Number} val Default value\n   * @param {Number} scrollTop Window's scrollTop\n   * @returns {Number} value Option's position (px)\n   */\n  eventScrollPos(option, scrollTop = 0, val = null) {\n    if (!isNaN(parseFloat(option))) {\n      val = option;\n    } else {\n      let elements = Array.isArray(option) ? option : document.documentElement.querySelectorAll(option);\n      if (elements.length) {\n        let found = false;\n        val = 0;\n        for (let el of elements) {\n          let addSticky = parseFloat(el.dataset.xtAddSticky);\n          if (addSticky) { // if sticky-hide get real add\n            let style = getComputedStyle(el);\n            if (style.display !== 'none') {\n              val += addSticky;\n              found = true;\n            }\n          } else {\n            let rect = el.getBoundingClientRect();\n            val += rect.top;\n            found = true;\n          }\n        }\n        if (found) {\n          val += scrollTop;\n        } else {\n          val = null;\n        }\n      }\n    }\n    return val;\n  }\n\n  /**\n   * get height of option\n   * @param {String|Number|Element} option\n   * @param {Boolean} scrollInverse\n   * @param {Number} val Default value\n   * @returns {Object} obj Option's height (px) and if found hide element\n   */\n  eventScrollHeight(option, scrollInverse, val = null) {\n    let foundHide = false;\n    if (!isNaN(parseFloat(option))) {\n      val = option;\n    } else {\n      let elements = Array.isArray(option) ? option : document.documentElement.querySelectorAll(option);\n      if (elements.length) {\n        for (let el of elements) {\n          if (el.classList.contains('sticky-hide-down') && el.classList.contains('active')) {\n            if (scrollInverse) {\n              val += el.clientHeight;\n              foundHide = true;\n            }\n          } else if (el.classList.contains('sticky-hide-up') && el.classList.contains('active')) {\n            if (!scrollInverse) {\n              val += el.clientHeight;\n              foundHide = true;\n            }\n          } else {\n            val += el.clientHeight;\n          }\n        }\n      }\n    }\n    return {val: val, foundHide: foundHide};\n  }\n\n}\n\n// default\n\nXtSticky.defaults = {\n  \"class\": \"active\",\n  \"on\": \"scroll resize\",\n  \"min\": 0,\n  \"max\": Infinity,\n  \"position\": \"top\",\n  \"limit\": {\"bottom\": Infinity},\n  \"contain\": false,\n  \"hide\": false\n};\n\n// export\n\nwindow.XtSticky = XtSticky;\nexport {XtSticky};\n\n//////////////////////\n// XtFade\n//////////////////////\n\nclass XtFade extends Xt {\n\n  /**\n   * constructor\n   * @param {Node|HTMLElement} object Base node\n   * @param {Object} jsOptions User options\n   * @constructor\n   */\n  constructor(object, jsOptions = {}) {\n    super(object, jsOptions, 'data-xt-fade');\n  }\n\n  //////////////////////\n  // init\n  //////////////////////\n\n  /**\n   * init events\n   */\n  initEvents() {\n    let self = this;\n    let options = self.options;\n    // events\n    if (options.on) {\n      // handler\n      let fadeHandler = XtUtil.dataStorage.put(window, 'fadeHandler', self.eventOnHandler.bind(self));\n      // event\n      let events = [...options.on.split(' ')];\n      for (let event of events) {\n        window.removeEventListener(event, fadeHandler);\n        window.addEventListener(event, fadeHandler);\n      }\n      window.addEventListener('on.fade', fadeHandler);\n    }\n    // trigger initial\n    window.dispatchEvent(new CustomEvent('on.fade'));\n  }\n\n  /**\n   * element on handler\n   * @param {Node|HTMLElement} element\n   * @param {Event} e\n   */\n  eventOnHandler(element, e) {\n    this.eventScroll(this.object);\n  }\n\n  //////////////////////\n  // events\n  //////////////////////\n\n  /**\n   * window scroll\n   */\n  eventScroll() {\n    let self = this;\n    let options = self.options;\n    // vars\n    let current = 0;\n    let currents = [];\n    let scrollInverse = false;\n    let windowHeight = window.innerHeight;\n    let scrollingElement = document.scrollingElement;\n    let scrollTop = scrollingElement.scrollTop;\n    let scrollTopOld = self.scrollTopOld;\n    // direction\n    if (scrollTop < scrollTopOld) {\n      scrollInverse = true;\n    }\n    // core\n    for (let el of self.elements) {\n      if (el.offsetParent && !el.classList.contains('fade-block')) {\n        // vars\n        let rectElTop = el.offsetParent.getBoundingClientRect().top + el.offsetTop; // we use parents to not include transforms animations\n        let heightEl = parseFloat(getComputedStyle(el).height);\n        // scroll\n        let changed = false;\n        let top = rectElTop + scrollTop;\n        let bottom = top + heightEl;\n        let dist = windowHeight * options.distance;\n        // activation\n        let checkTop = scrollTop + windowHeight >= top + dist;\n        let checkBottom = scrollTop < bottom - dist;\n        if (checkTop && checkBottom) {\n          // inside\n          changed = self.checkOn(el);\n          if (changed) {\n            currents.push(el);\n            XtUtil.cancelAnimationFrame.call(window, el.dataset.eventFrame);\n            el.dataset.eventFrame = XtUtil.requestAnimationFrame.call(window, function () {\n              if (options.delayOn) {\n                let func = new Function('current', 'total', options.delayOn);\n                el.dataset.xtOnDelay = func(current, currents.length).toString();\n                current++;\n              }\n              self.eventOn(el);\n            });\n          }\n        } else {\n          // outside\n          changed = self.checkOff(el);\n          el.classList.add('fade-visible');\n          if (changed) {\n            el.classList.add('fade-scroll');\n            currents.push(el);\n            XtUtil.cancelAnimationFrame.call(window, el.dataset.eventFrame);\n            el.dataset.eventFrame = XtUtil.requestAnimationFrame.call(window, function () {\n              if (options.delayOff) {\n                let func = new Function('current', 'total', options.delayOff);\n                el.dataset.xtOffDelay = func(current, currents.length).toString();\n                current++;\n              }\n              changed = self.eventOff(el);\n            });\n          }\n        }\n        // direction\n        if (changed) {\n          if (scrollInverse) {\n            el.classList.remove('fade-down');\n            el.classList.add('fade-up');\n          } else {\n            el.classList.add('fade-down');\n            el.classList.remove('fade-up');\n          }\n        }\n      }\n    }\n    // save for direction\n    self.scrollTopOld = scrollTop;\n  }\n\n}\n\n// default\n\nXtFade.defaults = {\n  \"elements\": \".fade\",\n  \"class\": \"in\",\n  \"on\": \"scroll resize\",\n  \"min\": 0,\n  \"max\": Infinity,\n  \"distance\": 0.2,\n  \"delayOn\": false,\n  \"delayOff\": false\n};\n\n// export\n\nwindow.XtFade = XtFade;\nexport {XtFade};\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4taW5zdGFuY2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1jb3B5LXdpdGhpbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZpbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19iaW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tc3Ryb25nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi13ZWFrLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0ta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLWlzLXJlZ2V4cC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZml4LXJlLXdrcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZsYWdzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZm9yLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGlkZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2luaGVyaXQtaWYtcmVxdWlyZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pbnZva2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtaW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLXJlZ2V4cC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2xpYnJhcnkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLWV4cG0xLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1mcm91bmQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLWxvZzFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1zaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWV0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21pY3JvdGFzay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX25ldy1wcm9taXNlLWNhcGFiaWxpdHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qtc2FwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXRvLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb3duLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wZXJmb3JtLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvbWlzZS1yZXNvbHZlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2FtZS12YWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1wcm90by5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1jb250ZXh0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXBhZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1yZXBlYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190YXNrLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC1idWZmZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VpZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VzZXItYWdlbnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL192YWxpZGF0ZS1jb2xsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy1leHQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkub2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hY29zaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXNpbmguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmF0YW5oLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jYnJ0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jbHozMi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY29zaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZXhwbTEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmZyb3VuZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmltdWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2luaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudGFuaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudHJ1bmMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuZXBzaWxvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtc2FmZS1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWluLXNhZmUtaW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtc2VhbGVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNlYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnByb21pc2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuaGFzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5pcy1leHRlbnNpYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5vd24ta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5zZXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuZmxhZ3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2guanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAucmVwbGFjZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zZWFyY2guanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zZXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJhdy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5hcnJheS1idWZmZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDMyLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQ2NC1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDE2LWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MzItYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQ4LWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDMyLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLXNldC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmVudHJpZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtc3RhcnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5pbW1lZGlhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi50aW1lcnMuanMiLCJub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwic3JjL2RvY3MvYXNzZXRzL3NjcmlwdHMveHRlbmQuanMiLCJzcmMvc2NyaXB0cy94dGVuZC11dGlscy5qcyIsInNyYy9zY3JpcHRzL3h0ZW5kLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ250QkE7OztBQ0pBOzs7O0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFNLFNBQVMsRUFBZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTyxRQUFQLEdBQWtCLEVBQWxCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTyxPQUFQLEdBQWlCLFlBQWdEO0FBQUEsTUFBdEMsU0FBc0MsdUVBQTFCLFNBQVMsZUFBaUI7O0FBQy9EO0FBQ0EsUUFBTSxJQUFOLENBQVcsVUFBVSxnQkFBVixDQUEyQixrQkFBM0IsQ0FBWCxFQUEyRCxPQUEzRCxDQUFtRSxVQUFVLEVBQVYsRUFBYztBQUMvRSx3QkFBYSxFQUFiO0FBQ0QsR0FGRDtBQUdBLFFBQU0sSUFBTixDQUFXLFVBQVUsZ0JBQVYsQ0FBMkIsZ0JBQTNCLENBQVgsRUFBeUQsT0FBekQsQ0FBaUUsVUFBVSxFQUFWLEVBQWM7QUFDN0Usc0JBQVcsRUFBWDtBQUNELEdBRkQ7QUFHQSxRQUFNLElBQU4sQ0FBVyxVQUFVLGdCQUFWLENBQTJCLG1CQUEzQixDQUFYLEVBQTRELE9BQTVELENBQW9FLFVBQVUsRUFBVixFQUFjO0FBQ2hGLHlCQUFjLEVBQWQ7QUFDRCxHQUZEO0FBR0EsUUFBTSxJQUFOLENBQVcsVUFBVSxnQkFBVixDQUEyQixnQkFBM0IsQ0FBWCxFQUF5RCxPQUF6RCxDQUFpRSxVQUFVLEVBQVYsRUFBYztBQUM3RSxzQkFBVyxFQUFYO0FBQ0QsR0FGRDtBQUdBLFFBQU0sSUFBTixDQUFXLFVBQVUsZ0JBQVYsQ0FBMkIsa0JBQTNCLENBQVgsRUFBMkQsT0FBM0QsQ0FBbUUsVUFBVSxFQUFWLEVBQWM7QUFDL0Usd0JBQWEsRUFBYjtBQUNELEdBRkQ7QUFHRCxDQWpCRDs7QUFtQkE7Ozs7O0FBS0EsT0FBTyxxQkFBUCxHQUErQixZQUFZO0FBQ3pDLFNBQU8sT0FBTyxxQkFBUCxJQUFnQyxPQUFPLDJCQUF2QyxJQUFzRSxPQUFPLHdCQUE3RSxJQUF5RyxVQUFVLFFBQVYsRUFBb0I7QUFDbEksV0FBTyxVQUFQLENBQWtCLFFBQWxCLEVBQTRCLE9BQU8sRUFBbkM7QUFDRCxHQUZEO0FBR0QsQ0FKOEIsRUFBL0I7O0FBTUE7Ozs7QUFJQSxPQUFPLG9CQUFQLEdBQThCLFlBQVk7QUFDeEMsU0FBTyxPQUFPLG9CQUFQLElBQStCLE9BQU8sMEJBQXRDLElBQW9FLE9BQU8sdUJBQTNFLElBQXNHLFVBQVUsUUFBVixFQUFvQjtBQUMvSCxXQUFPLFlBQVAsQ0FBb0IsRUFBcEI7QUFDRCxHQUZEO0FBR0QsQ0FKNkIsRUFBOUI7O0FBTUE7Ozs7OztBQU1BLE9BQU8sV0FBUCxHQUFxQixVQUFVLENBQVYsRUFBYSxPQUFiLEVBQXNCO0FBQ3pDLE1BQUksU0FBUyxLQUFiO0FBRHlDO0FBQUE7QUFBQTs7QUFBQTtBQUV6Qyx5QkFBYyxPQUFkLDhIQUF1QjtBQUFBLFVBQWQsQ0FBYzs7QUFDckIsVUFBSSxFQUFFLE1BQUYsS0FBYSxDQUFiLElBQWtCLEVBQUUsUUFBRixDQUFXLEVBQUUsTUFBYixDQUF0QixFQUE0QztBQUMxQyxpQkFBUyxJQUFUO0FBQ0Q7QUFDRjtBQU53QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQU96QyxTQUFPLE1BQVA7QUFDRCxDQVJEOztBQVVBOzs7Ozs7QUFNQSxPQUFPLFlBQVAsR0FBc0IsVUFBVSxDQUFWLEVBQWEsT0FBYixFQUFzQjtBQUMxQyxNQUFJLFNBQVMsSUFBYjtBQUQwQztBQUFBO0FBQUE7O0FBQUE7QUFFMUMsMEJBQWMsT0FBZCxtSUFBdUI7QUFBQSxVQUFkLENBQWM7O0FBQ3JCLFVBQUksRUFBRSxNQUFGLEtBQWEsQ0FBYixJQUFrQixFQUFFLFFBQUYsQ0FBVyxFQUFFLE1BQWIsQ0FBdEIsRUFBNEM7QUFDMUMsaUJBQVMsS0FBVDtBQUNEO0FBQ0Y7QUFOeUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFPMUMsU0FBTyxNQUFQO0FBQ0QsQ0FSRDs7QUFVQTs7OztBQUlBLE9BQU8sY0FBUCxHQUF3QixZQUFZO0FBQ2xDO0FBQ0EsTUFBSSxRQUFRLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUFaO0FBQ0EsUUFBTSxLQUFOLENBQVksVUFBWixHQUF5QixRQUF6QjtBQUNBLFFBQU0sS0FBTixDQUFZLEtBQVosR0FBb0IsT0FBcEI7QUFDQSxRQUFNLEtBQU4sQ0FBWSxlQUFaLEdBQThCLFdBQTlCLENBTGtDLENBS1M7QUFDM0MsV0FBUyxJQUFULENBQWMsV0FBZCxDQUEwQixLQUExQjtBQUNBLE1BQUksZ0JBQWdCLE1BQU0sV0FBMUI7QUFDQTtBQUNBLFFBQU0sS0FBTixDQUFZLFFBQVosR0FBdUIsUUFBdkI7QUFDQTtBQUNBLE1BQUksUUFBUSxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBWjtBQUNBLFFBQU0sS0FBTixDQUFZLEtBQVosR0FBb0IsTUFBcEI7QUFDQSxRQUFNLFdBQU4sQ0FBa0IsS0FBbEI7QUFDQSxNQUFJLGtCQUFrQixNQUFNLFdBQTVCO0FBQ0E7QUFDQSxRQUFNLFVBQU4sQ0FBaUIsV0FBakIsQ0FBNkIsS0FBN0I7QUFDQSxTQUFPLGdCQUFnQixlQUF2QjtBQUNELENBbEJEOztBQW9CQTs7OztBQUlBLE9BQU8sV0FBUCxHQUFxQixZQUFZO0FBQy9CLFNBQU8sR0FBUCxHQUFhLE9BQU8sR0FBUCxLQUFlLFNBQWYsR0FBMkIsT0FBTyxHQUFsQyxHQUF3QyxDQUFyRDtBQUNBLFNBQU8sZUFBZ0IsT0FBTyxHQUFQLEVBQXZCO0FBQ0QsQ0FIRDs7QUFLQTs7OztBQUlBLE9BQU8sWUFBUCxHQUFzQixZQUFZO0FBQ2hDLFNBQU8sT0FBUCxHQUFpQixPQUFPLE9BQVAsS0FBbUIsU0FBbkIsR0FBK0IsT0FBTyxPQUF0QyxHQUFnRCxDQUFqRTtBQUNBLFNBQU8sT0FBTyxPQUFQLEVBQVA7QUFDRCxDQUhEOztBQUtBOzs7OztBQUtBLE9BQU8sS0FBUCxHQUFlLFVBQVUsR0FBVixFQUFlO0FBQzVCLE1BQUksUUFBUSxFQUFaO0FBRDRCO0FBQUE7QUFBQTs7QUFBQTtBQUU1QiwwQkFBZ0IsR0FBaEIsbUlBQXFCO0FBQUEsVUFBWixHQUFZO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ25CLDhCQUF5QixPQUFPLE9BQVAsQ0FBZSxHQUFmLENBQXpCLG1JQUE4QztBQUFBO0FBQUEsY0FBcEMsR0FBb0M7QUFBQSxjQUEvQixLQUErQjs7QUFDNUMsZ0JBQU0sR0FBTixJQUFhLEtBQWI7QUFDRDtBQUhrQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSXBCO0FBTjJCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBTzVCLFNBQU8sS0FBUDtBQUNELENBUkQ7O0FBVUE7Ozs7O0FBS0EsT0FBTyxTQUFQLEdBQW1CLFVBQVUsT0FBVixFQUFtQjtBQUNwQyxNQUFJLFFBQVEsTUFBUixLQUFtQixTQUF2QixFQUFrQztBQUNoQyxRQUFJLE1BQU0sSUFBSSxLQUFKLENBQVUsQ0FBVixDQUFWO0FBQ0EsUUFBSSxDQUFKLElBQVMsT0FBVDtBQUNBLFdBQU8sR0FBUDtBQUNELEdBSkQsTUFJTztBQUNMLFdBQU8sT0FBUDtBQUNEO0FBQ0YsQ0FSRDs7QUFVQTs7Ozs7QUFLQSxPQUFPLGFBQVAsR0FBdUIsVUFBVSxHQUFWLEVBQWU7QUFDcEMsTUFBSSxNQUFNLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUFWO0FBQ0EsTUFBSSxTQUFKLEdBQWdCLElBQUksSUFBSixFQUFoQjtBQUNBLFNBQU8sSUFBSSxVQUFYO0FBQ0QsQ0FKRDs7QUFNQTs7Ozs7O0FBTUEsT0FBTyxPQUFQLEdBQWlCLFVBQVUsT0FBVixFQUFtQixLQUFuQixFQUEwQjtBQUN6QyxNQUFJLFVBQVUsRUFBZDtBQUNBLFNBQU8sVUFBVSxRQUFRLGFBQVIsQ0FBc0IsT0FBdEIsQ0FBOEIsS0FBOUIsQ0FBakIsRUFBdUQ7QUFDckQsWUFBUSxJQUFSLENBQWEsT0FBYjtBQUNEO0FBQ0QsU0FBTyxPQUFQO0FBQ0QsQ0FORDs7QUFRQTs7Ozs7QUFLQSxPQUFPLFdBQVAsR0FBcUI7QUFDbkIsWUFBVSxJQUFJLE9BQUosRUFEUztBQUVuQixPQUFLLGFBQVUsT0FBVixFQUFtQixHQUFuQixFQUF3QixHQUF4QixFQUE2QjtBQUNoQyxRQUFJLENBQUMsS0FBSyxRQUFMLENBQWMsR0FBZCxDQUFrQixHQUFsQixDQUFMLEVBQTZCO0FBQzNCLFdBQUssUUFBTCxDQUFjLEdBQWQsQ0FBa0IsT0FBbEIsRUFBMkIsSUFBSSxHQUFKLEVBQTNCO0FBQ0Q7QUFDRCxTQUFLLFFBQUwsQ0FBYyxHQUFkLENBQWtCLE9BQWxCLEVBQTJCLEdBQTNCLENBQStCLEdBQS9CLEVBQW9DLEdBQXBDO0FBQ0EsV0FBTyxLQUFLLFFBQUwsQ0FBYyxHQUFkLENBQWtCLE9BQWxCLEVBQTJCLEdBQTNCLENBQStCLEdBQS9CLENBQVA7QUFDRCxHQVJrQjtBQVNuQixPQUFLLGFBQVUsT0FBVixFQUFtQixHQUFuQixFQUF3QjtBQUMzQixXQUFPLEtBQUssUUFBTCxDQUFjLEdBQWQsQ0FBa0IsT0FBbEIsRUFBMkIsR0FBM0IsQ0FBK0IsR0FBL0IsQ0FBUDtBQUNELEdBWGtCO0FBWW5CLE9BQUssYUFBVSxPQUFWLEVBQW1CLEdBQW5CLEVBQXdCO0FBQzNCLFdBQU8sS0FBSyxRQUFMLENBQWMsR0FBZCxDQUFrQixPQUFsQixFQUEyQixHQUEzQixDQUErQixHQUEvQixDQUFQO0FBQ0QsR0Fka0I7QUFlbkIsVUFBUSxnQkFBVSxPQUFWLEVBQW1CLEdBQW5CLEVBQXdCO0FBQzlCLFFBQUksTUFBTSxLQUFLLFFBQUwsQ0FBYyxHQUFkLENBQWtCLE9BQWxCLEVBQTJCLE1BQTNCLENBQWtDLEdBQWxDLENBQVY7QUFDQSxRQUFJLENBQUMsS0FBSyxRQUFMLENBQWMsR0FBZCxDQUFrQixHQUFsQixFQUF1QixJQUF4QixLQUFpQyxLQUFyQyxFQUE0QztBQUMxQyxXQUFLLFFBQUwsQ0FBYyxNQUFkLENBQXFCLE9BQXJCO0FBQ0Q7QUFDRCxXQUFPLEdBQVA7QUFDRDtBQXJCa0IsQ0FBckI7O0FBd0JBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPLE1BQVAsR0FBZ0IsTUFBaEI7UUFDUSxNLEdBQUEsTTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDRjtBQUNBLFdBQVMsYUFBVCxDQUF1QixVQUF2QjtBQUNELENBSEQsQ0FHRSxPQUFPLEtBQVAsRUFBYztBQUNkLEdBQUMsVUFBVSxnQkFBVixFQUE0QjtBQUMzQjtBQUNBLFFBQUksUUFBUSxtQkFBWjs7QUFFQTtBQUNBLFFBQUkseUJBQXlCLFNBQVMsaUJBQWlCLGFBQTFCLENBQTdCOztBQUVBLHFCQUFpQixhQUFqQixHQUFpQyxTQUFTLGFBQVQsQ0FBdUIsU0FBdkIsRUFBa0M7QUFDakUsYUFBTyx1QkFBdUIsS0FBdkIsQ0FBNkIsSUFBN0IsRUFBbUMsU0FBbkMsQ0FBUDtBQUNELEtBRkQ7O0FBSUE7QUFDQSxRQUFJLDRCQUE0QixTQUFTLGlCQUFpQixnQkFBMUIsQ0FBaEM7O0FBRUEscUJBQWlCLGdCQUFqQixHQUFvQyxTQUFTLGdCQUFULENBQTBCLFNBQTFCLEVBQXFDO0FBQ3ZFLGFBQU8sMEJBQTBCLEtBQTFCLENBQWdDLElBQWhDLEVBQXNDLFNBQXRDLENBQVA7QUFDRCxLQUZEOztBQUlBO0FBQ0EsUUFBSSxpQkFBaUIsT0FBckIsRUFBOEI7QUFDNUIsVUFBSSxtQkFBbUIsU0FBUyxpQkFBaUIsT0FBMUIsQ0FBdkI7O0FBRUEsdUJBQWlCLE9BQWpCLEdBQTJCLFNBQVMsT0FBVCxDQUFpQixTQUFqQixFQUE0QjtBQUNyRCxlQUFPLGlCQUFpQixLQUFqQixDQUF1QixJQUF2QixFQUE2QixTQUE3QixDQUFQO0FBQ0QsT0FGRDtBQUdEOztBQUVEO0FBQ0EsUUFBSSxpQkFBaUIsT0FBckIsRUFBOEI7QUFDNUIsVUFBSSxtQkFBbUIsU0FBUyxpQkFBaUIsT0FBMUIsQ0FBdkI7O0FBRUEsdUJBQWlCLE9BQWpCLEdBQTJCLFNBQVMsT0FBVCxDQUFpQixTQUFqQixFQUE0QjtBQUNyRCxlQUFPLGlCQUFpQixLQUFqQixDQUF1QixJQUF2QixFQUE2QixTQUE3QixDQUFQO0FBQ0QsT0FGRDtBQUdEOztBQUVELGFBQVMsUUFBVCxDQUFrQixHQUFsQixFQUF1QjtBQUNyQixhQUFPLFVBQVUsU0FBVixFQUFxQjtBQUMxQjtBQUNBLFlBQUksV0FBVyxhQUFhLE1BQU0sSUFBTixDQUFXLFNBQVgsQ0FBNUI7O0FBRUEsWUFBSSxRQUFKLEVBQWM7QUFDWjtBQUNBLGNBQUksT0FBTyxNQUFNLEtBQUssS0FBTCxDQUFXLEtBQUssTUFBTCxLQUFnQixPQUEzQixDQUFOLEdBQTRDLE9BQXZEOztBQUVBO0FBQ0Esb0JBQVUsQ0FBVixJQUFlLFVBQVUsT0FBVixDQUFrQixLQUFsQixFQUF5QixNQUFNLElBQU4sR0FBYSxHQUF0QyxDQUFmOztBQUVBO0FBQ0EsZUFBSyxZQUFMLENBQWtCLElBQWxCLEVBQXdCLEVBQXhCOztBQUVBO0FBQ0EsY0FBSSxvQkFBb0IsSUFBSSxLQUFKLENBQVUsSUFBVixFQUFnQixTQUFoQixDQUF4Qjs7QUFFQTtBQUNBLGVBQUssZUFBTCxDQUFxQixJQUFyQjs7QUFFQTtBQUNBLGlCQUFPLGlCQUFQO0FBQ0QsU0FsQkQsTUFrQk87QUFDTDtBQUNBLGlCQUFPLElBQUksS0FBSixDQUFVLElBQVYsRUFBZ0IsU0FBaEIsQ0FBUDtBQUNEO0FBQ0YsT0ExQkQ7QUEyQkQ7QUFDRixHQWpFRCxFQWlFRyxRQUFRLFNBakVYO0FBa0VEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLFlBQVk7QUFDWCxNQUFJLE9BQU8sT0FBTyxXQUFkLEtBQThCLFVBQWxDLEVBQThDO0FBQzVDLFdBQU8sS0FBUDtBQUNEOztBQUVELFdBQVMsV0FBVCxDQUFxQixLQUFyQixFQUE0QixNQUE1QixFQUFvQztBQUNsQyxhQUFTLFVBQVUsRUFBQyxTQUFTLEtBQVYsRUFBaUIsWUFBWSxLQUE3QixFQUFvQyxRQUFRLFNBQTVDLEVBQW5CO0FBQ0EsUUFBSSxNQUFNLFNBQVMsV0FBVCxDQUFxQixhQUFyQixDQUFWO0FBQ0EsUUFBSSxlQUFKLENBQW9CLEtBQXBCLEVBQTJCLE9BQU8sT0FBbEMsRUFBMkMsT0FBTyxVQUFsRCxFQUE4RCxPQUFPLE1BQXJFO0FBQ0EsV0FBTyxHQUFQO0FBQ0Q7O0FBRUQsY0FBWSxTQUFaLEdBQXdCLE9BQU8sS0FBUCxDQUFhLFNBQXJDO0FBQ0EsU0FBTyxXQUFQLEdBQXFCLFdBQXJCO0FBQ0QsQ0FkRDs7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxZQUFZO0FBQ1gsTUFBSSxTQUFTLGdCQUFiLEVBQStCO0FBQzdCO0FBQ0Q7QUFDRCxNQUFJLFVBQVUsSUFBZDs7QUFFQSxXQUFTLGdCQUFULEdBQTRCO0FBQzFCLFFBQUksT0FBSixFQUFhO0FBQ1gsYUFBTyxPQUFQO0FBQ0QsS0FGRCxNQUVPLElBQUksU0FBUyxJQUFULENBQWMsU0FBbEIsRUFBNkI7QUFDbEM7QUFDQSxhQUFRLFVBQVUsU0FBUyxJQUEzQjtBQUNEO0FBQ0QsUUFBSSxTQUFTLFNBQVMsYUFBVCxDQUF1QixRQUF2QixDQUFiO0FBQ0EsV0FBTyxLQUFQLENBQWEsTUFBYixHQUFzQixLQUF0QjtBQUNBLGFBQVMsZUFBVCxDQUF5QixXQUF6QixDQUFxQyxNQUFyQztBQUNBLFFBQUksTUFBTSxPQUFPLGFBQVAsQ0FBcUIsUUFBL0I7QUFDQSxRQUFJLEtBQUosQ0FBVSxtREFBVjtBQUNBLFFBQUksS0FBSjtBQUNBLFFBQUksY0FBYyxJQUFJLGVBQUosQ0FBb0IsWUFBcEIsR0FBbUMsSUFBSSxJQUFKLENBQVMsWUFBOUQ7QUFDQSxXQUFPLFVBQVAsQ0FBa0IsV0FBbEIsQ0FBOEIsTUFBOUI7QUFDQSxXQUFRLFVBQVUsY0FBYyxTQUFTLGVBQXZCLEdBQXlDLFNBQVMsSUFBcEU7QUFDRDs7QUFFRCxTQUFPLGNBQVAsQ0FBc0IsUUFBdEIsRUFBZ0Msa0JBQWhDLEVBQW9EO0FBQ2xELFNBQUs7QUFENkMsR0FBcEQ7QUFHRCxDQTNCRDs7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxVQUFVLEdBQVYsRUFBZTtBQUNkLE1BQUksT0FBSixDQUFZLFVBQVUsSUFBVixFQUFnQjtBQUMxQixRQUFJLEtBQUssY0FBTCxDQUFvQixRQUFwQixDQUFKLEVBQW1DO0FBQ2pDO0FBQ0Q7QUFDRCxXQUFPLGNBQVAsQ0FBc0IsSUFBdEIsRUFBNEIsUUFBNUIsRUFBc0M7QUFDcEMsb0JBQWMsSUFEc0I7QUFFcEMsa0JBQVksSUFGd0I7QUFHcEMsZ0JBQVUsSUFIMEI7QUFJcEMsYUFBTyxTQUFTLE1BQVQsR0FBa0I7QUFDdkIsWUFBSSxTQUFTLE1BQU0sU0FBTixDQUFnQixLQUFoQixDQUFzQixJQUF0QixDQUEyQixTQUEzQixDQUFiO0FBQUEsWUFDRSxVQUFVLFNBQVMsc0JBQVQsRUFEWjs7QUFHQSxlQUFPLE9BQVAsQ0FBZSxVQUFVLE9BQVYsRUFBbUI7QUFDaEMsY0FBSSxTQUFTLG1CQUFtQixJQUFoQztBQUNBLGtCQUFRLFdBQVIsQ0FBb0IsU0FBUyxPQUFULEdBQW1CLFNBQVMsY0FBVCxDQUF3QixPQUFPLE9BQVAsQ0FBeEIsQ0FBdkM7QUFDRCxTQUhEOztBQUtBLGFBQUssV0FBTCxDQUFpQixPQUFqQjtBQUNEO0FBZG1DLEtBQXRDO0FBZ0JELEdBcEJEO0FBcUJELENBdEJELEVBc0JHLENBQUMsUUFBUSxTQUFULEVBQW9CLFNBQVMsU0FBN0IsRUFBd0MsaUJBQWlCLFNBQXpELENBdEJIOztBQXdCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLFVBQVUsR0FBVixFQUFlO0FBQ2QsTUFBSSxPQUFKLENBQVksVUFBVSxJQUFWLEVBQWdCO0FBQzFCLFFBQUksS0FBSyxjQUFMLENBQW9CLFFBQXBCLENBQUosRUFBbUM7QUFDakM7QUFDRDtBQUNELFdBQU8sY0FBUCxDQUFzQixJQUF0QixFQUE0QixRQUE1QixFQUFzQztBQUNwQyxvQkFBYyxJQURzQjtBQUVwQyxrQkFBWSxJQUZ3QjtBQUdwQyxnQkFBVSxJQUgwQjtBQUlwQyxhQUFPLFNBQVMsTUFBVCxHQUFrQjtBQUN2QixZQUFJLFNBQVMsTUFBTSxTQUFOLENBQWdCLEtBQWhCLENBQXNCLElBQXRCLENBQTJCLFNBQTNCLENBQWI7QUFBQSxZQUNFLFVBQVUsU0FBUyxzQkFBVCxFQURaOztBQUdBLGVBQU8sT0FBUCxDQUFlLFVBQVUsT0FBVixFQUFtQjtBQUNoQyxjQUFJLFNBQVMsbUJBQW1CLElBQWhDO0FBQ0Esa0JBQVEsV0FBUixDQUFvQixTQUFTLE9BQVQsR0FBbUIsU0FBUyxjQUFULENBQXdCLE9BQU8sT0FBUCxDQUF4QixDQUF2QztBQUNELFNBSEQ7O0FBS0EsYUFBSyxVQUFMLENBQWdCLFlBQWhCLENBQTZCLE9BQTdCLEVBQXNDLElBQXRDO0FBQ0Q7QUFkbUMsS0FBdEM7QUFnQkQsR0FwQkQ7QUFxQkQsQ0F0QkQsRUFzQkcsQ0FBQyxRQUFRLFNBQVQsRUFBb0IsY0FBYyxTQUFsQyxFQUE2QyxhQUFhLFNBQTFELENBdEJIOztBQXdCQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLFVBQVUsR0FBVixFQUFlO0FBQ2QsTUFBSSxDQUFDLElBQUksT0FBVCxFQUFrQjtBQUNoQixRQUFJLE9BQUosR0FBYyxVQUFVLEdBQVYsRUFBZTtBQUMzQixVQUFJLFdBQVcsT0FBTyxJQUFQLENBQWEsR0FBYixDQUFmO0FBQUEsVUFDRSxJQUFJLFNBQVMsTUFEZjtBQUFBLFVBRUUsV0FBVyxJQUFJLEtBQUosQ0FBVSxDQUFWLENBRmIsQ0FEMkIsQ0FHQTtBQUMzQixhQUFPLEdBQVA7QUFDRSxpQkFBUyxDQUFULElBQWMsQ0FBQyxTQUFTLENBQVQsQ0FBRCxFQUFjLElBQUksU0FBUyxDQUFULENBQUosQ0FBZCxDQUFkO0FBREYsT0FHQSxPQUFPLFFBQVA7QUFDRCxLQVJEO0FBU0Q7QUFDRixDQVpELEVBWUcsTUFaSDs7QUFjQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLFVBQVUsR0FBVixFQUFlO0FBQ2QsTUFBSSxDQUFDLElBQUksSUFBVCxFQUFlO0FBQ2IsUUFBSSxJQUFKLEdBQVksWUFBWTtBQUN0QixVQUFJLFFBQVEsT0FBTyxTQUFQLENBQWlCLFFBQTdCO0FBQ0EsVUFBSSxhQUFhLFNBQWIsVUFBYSxDQUFVLEVBQVYsRUFBYztBQUM3QixlQUFPLE9BQU8sRUFBUCxLQUFjLFVBQWQsSUFBNEIsTUFBTSxJQUFOLENBQVcsRUFBWCxNQUFtQixtQkFBdEQ7QUFDRCxPQUZEO0FBR0EsVUFBSSxZQUFZLFNBQVosU0FBWSxDQUFVLEtBQVYsRUFBaUI7QUFDL0IsWUFBSSxTQUFTLE9BQU8sS0FBUCxDQUFiO0FBQ0EsWUFBSSxNQUFNLE1BQU4sQ0FBSixFQUFtQjtBQUFFLGlCQUFPLENBQVA7QUFBVztBQUNoQyxZQUFJLFdBQVcsQ0FBWCxJQUFnQixDQUFDLFNBQVMsTUFBVCxDQUFyQixFQUF1QztBQUFFLGlCQUFPLE1BQVA7QUFBZ0I7QUFDekQsZUFBTyxDQUFDLFNBQVMsQ0FBVCxHQUFhLENBQWIsR0FBaUIsQ0FBQyxDQUFuQixJQUF3QixLQUFLLEtBQUwsQ0FBVyxLQUFLLEdBQUwsQ0FBUyxNQUFULENBQVgsQ0FBL0I7QUFDRCxPQUxEO0FBTUEsVUFBSSxpQkFBaUIsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLEVBQVosSUFBa0IsQ0FBdkM7QUFDQSxVQUFJLFdBQVcsU0FBWCxRQUFXLENBQVUsS0FBVixFQUFpQjtBQUM5QixZQUFJLE1BQU0sVUFBVSxLQUFWLENBQVY7QUFDQSxlQUFPLEtBQUssR0FBTCxDQUFTLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxDQUFkLENBQVQsRUFBMkIsY0FBM0IsQ0FBUDtBQUNELE9BSEQ7O0FBS0E7QUFDQSxhQUFPLFNBQVMsSUFBVCxDQUFjLFNBQWQsQ0FBdUIscUJBQXZCLEVBQThDO0FBQ25EO0FBQ0EsWUFBSSxJQUFJLElBQVI7O0FBRUE7QUFDQSxZQUFJLFFBQVEsT0FBTyxTQUFQLENBQVo7O0FBRUE7QUFDQSxZQUFJLGFBQWEsSUFBakIsRUFBdUI7QUFDckIsZ0JBQU0sSUFBSSxTQUFKLENBQWMsa0VBQWQsQ0FBTjtBQUNEOztBQUVEO0FBQ0EsWUFBSSxRQUFRLFVBQVUsTUFBVixHQUFtQixDQUFuQixHQUF1QixVQUFVLENBQVYsQ0FBdkIsR0FBc0MsS0FBSyxTQUF2RDtBQUNBLFlBQUksQ0FBSjtBQUNBLFlBQUksT0FBTyxLQUFQLEtBQWlCLFdBQXJCLEVBQWtDO0FBQ2hDO0FBQ0E7QUFDQSxjQUFJLENBQUMsV0FBVyxLQUFYLENBQUwsRUFBd0I7QUFDdEIsa0JBQU0sSUFBSSxTQUFKLENBQWMsbUVBQWQsQ0FBTjtBQUNEOztBQUVEO0FBQ0EsY0FBSSxVQUFVLE1BQVYsR0FBbUIsQ0FBdkIsRUFBMEI7QUFDeEIsZ0JBQUksVUFBVSxDQUFWLENBQUo7QUFDRDtBQUNGOztBQUVEO0FBQ0E7QUFDQSxZQUFJLE1BQU0sU0FBUyxNQUFNLE1BQWYsQ0FBVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUksSUFBSSxXQUFXLENBQVgsSUFBZ0IsT0FBTyxJQUFJLENBQUosQ0FBTSxHQUFOLENBQVAsQ0FBaEIsR0FBcUMsSUFBSSxLQUFKLENBQVUsR0FBVixDQUE3Qzs7QUFFQTtBQUNBLFlBQUksSUFBSSxDQUFSO0FBQ0E7QUFDQSxZQUFJLE1BQUo7QUFDQSxlQUFPLElBQUksR0FBWCxFQUFnQjtBQUNkLG1CQUFTLE1BQU0sQ0FBTixDQUFUO0FBQ0EsY0FBSSxLQUFKLEVBQVc7QUFDVCxjQUFFLENBQUYsSUFBTyxPQUFPLENBQVAsS0FBYSxXQUFiLEdBQTJCLE1BQU0sTUFBTixFQUFjLENBQWQsQ0FBM0IsR0FBOEMsTUFBTSxJQUFOLENBQVcsQ0FBWCxFQUFjLE1BQWQsRUFBc0IsQ0FBdEIsQ0FBckQ7QUFDRCxXQUZELE1BRU87QUFDTCxjQUFFLENBQUYsSUFBTyxNQUFQO0FBQ0Q7QUFDRCxlQUFLLENBQUw7QUFDRDtBQUNEO0FBQ0EsVUFBRSxNQUFGLEdBQVcsR0FBWDtBQUNBO0FBQ0EsZUFBTyxDQUFQO0FBQ0QsT0F2REQ7QUF3REQsS0ExRVcsRUFBWjtBQTJFRDtBQUNGLENBOUVELEVBOEVHLEtBOUVIOzs7QUM3ZUE7Ozs7QUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUlBOzs7Ozs7Ozs7O0FBRUE7QUFDQTtBQUNBOztJQUVNLEU7O0FBRUo7Ozs7Ozs7QUFPQSxjQUFZLE1BQVosRUFBMEM7QUFBQSxRQUF0QixTQUFzQix1RUFBVixFQUFVO0FBQUEsUUFBTixJQUFNOztBQUFBOztBQUN4QyxTQUFLLE1BQUwsR0FBYyxNQUFkO0FBQ0EsUUFBSSxLQUFLLE1BQVQsRUFBaUI7QUFDZixXQUFLLFFBQUwsR0FBZ0IsS0FBSyxXQUFMLENBQWlCLFFBQWpDO0FBQ0E7QUFDQSxXQUFLLE9BQUwsR0FBZSxtQkFBTyxLQUFQLENBQWEsQ0FBQyxLQUFLLFFBQU4sRUFBZ0IsU0FBaEIsQ0FBYixDQUFmO0FBQ0E7QUFDQSxVQUFJLGdCQUFnQixLQUFLLE1BQUwsQ0FBWSxZQUFaLENBQXlCLElBQXpCLENBQXBCO0FBQ0EsV0FBSyxPQUFMLEdBQWUsbUJBQU8sS0FBUCxDQUFhLENBQUMsS0FBSyxPQUFOLEVBQWUsZ0JBQWdCLEtBQUssS0FBTCxDQUFXLGFBQVgsQ0FBaEIsR0FBNEMsRUFBM0QsQ0FBYixDQUFmO0FBQ0E7QUFDQSxVQUFJLEtBQUssT0FBTCxDQUFhLEtBQWpCLEVBQXdCO0FBQ3RCLGFBQUssT0FBTCxDQUFhLE9BQWIsZ0NBQTJCLEtBQUssT0FBTCxDQUFhLEtBQWIsQ0FBbUIsS0FBbkIsQ0FBeUIsR0FBekIsQ0FBM0I7QUFDRDtBQUNEO0FBQ0EsV0FBSyxTQUFMO0FBQ0EsV0FBSyxTQUFMO0FBQ0EsV0FBSyxVQUFMO0FBQ0EsV0FBSyxRQUFMO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Z0NBR1k7QUFDVixVQUFJLE9BQU8sSUFBWDtBQUNBLFVBQUksVUFBVSxLQUFLLE9BQW5CO0FBQ0E7QUFDQSxVQUFJLFFBQVEsT0FBUixJQUFtQixRQUFRLE9BQVIsQ0FBZ0IsT0FBaEIsQ0FBd0IsR0FBeEIsTUFBaUMsQ0FBQyxDQUF6RCxFQUE0RDtBQUMxRDtBQUNBLGFBQUssSUFBTCxHQUFZLEtBQVo7QUFDQSxhQUFLLFNBQUwsR0FBaUIsU0FBUyxlQUExQjtBQUNBLGdCQUFRLEdBQVIsR0FBYyxRQUFkO0FBQ0EsYUFBSyxTQUFMLEdBQWlCLFFBQVEsT0FBUixDQUFnQixRQUFoQixLQUE2QixHQUE3QixHQUFtQyxRQUFRLE9BQVIsQ0FBZ0IsUUFBaEIsRUFBcEQ7QUFDRCxPQU5ELE1BTU87QUFDTDtBQUNBLGFBQUssSUFBTCxHQUFZLFFBQVo7QUFDQSxhQUFLLFNBQUwsR0FBaUIsS0FBSyxNQUF0QjtBQUNBLGFBQUssU0FBTCxHQUFpQixtQkFBTyxXQUFQLEVBQWpCO0FBQ0Q7QUFDRDtBQUNBLFdBQUssU0FBTCxHQUFpQixLQUFLLFNBQUwsQ0FBZSxPQUFmLENBQXVCLE1BQXZCLEVBQStCLEVBQS9CLENBQWpCO0FBQ0E7QUFDQSxVQUFJLENBQUMsS0FBSyxXQUFMLEVBQUwsRUFBeUI7QUFDdkIsYUFBSyxXQUFMLENBQWlCLEVBQWpCO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7O2dDQUdZO0FBQ1YsVUFBSSxPQUFPLElBQVg7QUFDQSxVQUFJLFVBQVUsS0FBSyxPQUFuQjtBQUNBO0FBQ0EsV0FBSyxRQUFMLEdBQWdCLEVBQWhCO0FBQ0EsVUFBSSxRQUFRLFFBQVosRUFBc0I7QUFDcEIsYUFBSyxRQUFMLEdBQWdCLG1CQUFPLFNBQVAsQ0FBaUIsS0FBSyxTQUFMLENBQWUsZ0JBQWYsQ0FBZ0MsUUFBUSxRQUF4QyxDQUFqQixDQUFoQjtBQUNEO0FBQ0QsVUFBSSxDQUFDLEtBQUssUUFBTCxDQUFjLE1BQW5CLEVBQTJCO0FBQ3pCLGFBQUssUUFBTCxHQUFnQixtQkFBTyxTQUFQLENBQWlCLEtBQUssTUFBdEIsQ0FBaEI7QUFDQTtBQUNBLDJCQUFPLHFCQUFQLENBQTZCLElBQTdCLENBQWtDLE1BQWxDLEVBQTBDLFlBQVk7QUFDcEQsY0FBSSxpQkFBaUIsaUJBQWlCLEtBQUssU0FBdEIsR0FBa0MsR0FBdkQ7QUFDQSxlQUFLLFFBQUwsR0FBZ0IsbUJBQU8sU0FBUCxDQUFpQixTQUFTLGVBQVQsQ0FBeUIsZ0JBQXpCLENBQTBDLGNBQTFDLENBQWpCLENBQWhCO0FBQ0QsU0FIRDtBQUlEO0FBQ0Q7QUFDQSxVQUFJLFFBQVEsT0FBWixFQUFxQjtBQUNuQixZQUFJLE1BQU0sTUFBTSxJQUFOLENBQVcsS0FBSyxTQUFMLENBQWUsZ0JBQWYsQ0FBZ0MsUUFBUSxPQUF4QyxDQUFYLENBQVY7QUFDQSxjQUFNLElBQUksTUFBSixDQUFXO0FBQUEsaUJBQUssQ0FBQyxtQkFBTyxPQUFQLENBQWUsQ0FBZixFQUFrQixRQUFRLE9BQTFCLEVBQW1DLE1BQXpDO0FBQUEsU0FBWCxDQUFOLENBRm1CLENBRWdEO0FBQ25FLGFBQUssT0FBTCxHQUFlLEdBQWY7QUFDRDtBQUNEO0FBQ0EsVUFBSSxRQUFRLFFBQVosRUFBc0I7QUFDcEIsWUFBSSxpQkFBaUIsU0FBUyxlQUFULENBQXlCLGdCQUF6QixDQUEwQyxRQUFRLFFBQWxELENBQXJCO0FBQ0EsWUFBSSxlQUFlLE1BQW5CLEVBQTJCO0FBQ3pCLGVBQUssT0FBTCxDQUFhLE9BQWIsQ0FBcUIsVUFBVSxFQUFWLEVBQWM7QUFDakMsMkJBQWUsQ0FBZixFQUFrQixXQUFsQixDQUE4QixFQUE5QjtBQUNELFdBRkQ7QUFHRDtBQUNGO0FBQ0Q7QUEvQlU7QUFBQTtBQUFBOztBQUFBO0FBZ0NWLDZCQUFlLEtBQUssUUFBcEIsOEhBQThCO0FBQUEsY0FBckIsRUFBcUI7O0FBQzVCLGFBQUcsWUFBSCxDQUFnQixZQUFoQixFQUE4QixLQUFLLFNBQW5DO0FBQ0Q7QUFDRDtBQW5DVTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQW9DVix5QkFBTyxxQkFBUCxDQUE2QixJQUE3QixDQUFrQyxNQUFsQyxFQUEwQyxZQUFZO0FBQ3BELFlBQUksS0FBSyxRQUFMLENBQWMsTUFBbEIsRUFBMEI7QUFDeEI7QUFEd0I7QUFBQTtBQUFBOztBQUFBO0FBRXhCLGtDQUFlLEtBQUssUUFBcEIsbUlBQThCO0FBQUE7O0FBQUEsa0JBQXJCLEVBQXFCOztBQUM1QixrQkFBSSxvQkFBRyxTQUFILEVBQWEsUUFBYix5Q0FBeUIsUUFBUSxPQUFqQyxFQUFKLEVBQStDO0FBQUE7O0FBQzdDLHFDQUFHLFNBQUgsRUFBYSxNQUFiLDBDQUF1QixRQUFRLE9BQS9CLEdBRDZDLENBQ0o7QUFDekMscUJBQUssT0FBTCxDQUFhLEVBQWI7QUFDRDtBQUNGO0FBQ0Q7QUFSd0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFTeEIsY0FBSSxPQUFPLFFBQVEsR0FBUixHQUFjLEtBQUssV0FBTCxHQUFtQixNQUE1QztBQUNBLGNBQUksSUFBSixFQUFVO0FBQ1IsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxJQUFwQixFQUEwQixHQUExQixFQUErQjtBQUM3QixtQkFBSyxPQUFMLENBQWEsS0FBSyxRQUFMLENBQWMsQ0FBZCxDQUFiO0FBQ0Q7QUFDRjtBQUNGO0FBQ0YsT0FqQkQ7QUFrQkQ7O0FBRUQ7Ozs7OzsrQkFHVztBQUNULFVBQUksS0FBSyxPQUFULEVBQWtCO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ2hCLGdDQUFlLEtBQUssT0FBcEIsbUlBQTZCO0FBQUEsZ0JBQXBCLEVBQW9COztBQUMzQjtBQUNBLGdCQUFJLFVBQVUsR0FBRyxnQkFBSCxDQUFvQix3QkFBcEIsQ0FBZDtBQUNBLGdCQUFJLFFBQVEsUUFBUSxNQUFSLEdBQWlCLE9BQWpCLEdBQTJCLEtBQUsscUJBQUwsQ0FBMkIsRUFBM0IsQ0FBdkM7QUFDQSxnQkFBSSxNQUFNLE1BQVYsRUFBa0I7QUFDaEIsc0JBQVEsTUFBTSxDQUFOLEVBQVMsU0FBVCxDQUFtQixPQUFuQixDQUEyQixNQUEzQixFQUFtQyxHQUFuQyxFQUF3QyxJQUF4QyxFQUFSO0FBQ0EsaUJBQUcsWUFBSCxDQUFnQixZQUFoQixFQUE4QixLQUE5QjtBQUNEO0FBQ0Y7QUFUZTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBVWpCO0FBQ0Y7O0FBRUQ7Ozs7OztpQ0FHYTtBQUNYLFVBQUksT0FBTyxJQUFYO0FBQ0EsVUFBSSxVQUFVLEtBQUssT0FBbkI7QUFDQTtBQUhXO0FBQUE7QUFBQTs7QUFBQTtBQUlYLDhCQUFlLEtBQUssUUFBcEIsbUlBQThCO0FBQUEsY0FBckIsRUFBcUI7O0FBQzVCLGNBQUksUUFBUSxFQUFaLEVBQWdCO0FBQ2Q7QUFDQSxnQkFBSSxjQUFjLG1CQUFPLFdBQVAsQ0FBbUIsR0FBbkIsQ0FBdUIsRUFBdkIsRUFBMkIsYUFBM0IsRUFBMEMsS0FBSyxjQUFMLENBQW9CLElBQXBCLENBQXlCLElBQXpCLEVBQStCLElBQS9CLENBQW9DLElBQXBDLEVBQTBDLEVBQTFDLENBQTFDLENBQWxCO0FBQ0E7QUFDQSxnQkFBSSxzQ0FBYSxRQUFRLEVBQVIsQ0FBVyxLQUFYLENBQWlCLEdBQWpCLENBQWIsRUFBSjtBQUpjO0FBQUE7QUFBQTs7QUFBQTtBQUtkLG9DQUFrQixNQUFsQixtSUFBMEI7QUFBQSxvQkFBakIsS0FBaUI7O0FBQ3hCLG1CQUFHLG1CQUFILENBQXVCLEtBQXZCLEVBQThCLFdBQTlCO0FBQ0EsbUJBQUcsZ0JBQUgsQ0FBb0IsS0FBcEIsRUFBMkIsV0FBM0I7QUFDRDtBQUNEO0FBVGM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFVZCxlQUFHLGdCQUFILENBQW9CLFlBQXBCLEVBQWtDLFdBQWxDO0FBQ0Q7QUFDRCxjQUFJLFFBQVEsR0FBWixFQUFpQjtBQUNmO0FBQ0EsZ0JBQUksZUFBZSxtQkFBTyxXQUFQLENBQW1CLEdBQW5CLENBQXVCLEVBQXZCLEVBQTJCLGNBQTNCLEVBQTJDLEtBQUssZUFBTCxDQUFxQixJQUFyQixDQUEwQixJQUExQixFQUFnQyxJQUFoQyxDQUFxQyxJQUFyQyxFQUEyQyxFQUEzQyxDQUEzQyxDQUFuQjtBQUNBO0FBQ0EsZ0JBQUksdUNBQWEsUUFBUSxHQUFSLENBQVksS0FBWixDQUFrQixHQUFsQixDQUFiLEVBQUo7QUFKZTtBQUFBO0FBQUE7O0FBQUE7QUFLZixvQ0FBa0IsT0FBbEIsbUlBQTBCO0FBQUEsb0JBQWpCLE1BQWlCOztBQUN4QixtQkFBRyxtQkFBSCxDQUF1QixNQUF2QixFQUE4QixZQUE5QjtBQUNBLG1CQUFHLGdCQUFILENBQW9CLE1BQXBCLEVBQTJCLFlBQTNCO0FBQ0Q7QUFDRDtBQVRlO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBVWYsZUFBRyxnQkFBSCxDQUFvQixhQUFwQixFQUFtQyxZQUFuQztBQUNEO0FBQ0Y7QUFDRDtBQTlCVztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQStCWCw4QkFBZSxLQUFLLE9BQXBCLG1JQUE2QjtBQUFBLGNBQXBCLEVBQW9COztBQUMzQixjQUFJLE1BQUssS0FBSyxxQkFBTCxDQUEyQixFQUEzQixFQUErQixDQUEvQixDQUFUO0FBQ0EsY0FBSSxHQUFKLEVBQVE7QUFDTjtBQUNBLGdCQUFJLGVBQWMsbUJBQU8sV0FBUCxDQUFtQixHQUFuQixDQUF1QixHQUF2QixFQUEyQixhQUEzQixFQUEwQyxLQUFLLGNBQUwsQ0FBb0IsSUFBcEIsQ0FBeUIsSUFBekIsRUFBK0IsSUFBL0IsQ0FBb0MsSUFBcEMsRUFBMEMsR0FBMUMsQ0FBMUMsQ0FBbEI7QUFDQSxnQkFBSSxnQkFBZSxtQkFBTyxXQUFQLENBQW1CLEdBQW5CLENBQXVCLEdBQXZCLEVBQTJCLGNBQTNCLEVBQTJDLEtBQUssZUFBTCxDQUFxQixJQUFyQixDQUEwQixJQUExQixFQUFnQyxJQUFoQyxDQUFxQyxJQUFyQyxFQUEyQyxHQUEzQyxDQUEzQyxDQUFuQjtBQUNBO0FBQ0EsZUFBRyxnQkFBSCxDQUFvQixZQUFwQixFQUFrQyxZQUFsQztBQUNBLGVBQUcsZ0JBQUgsQ0FBb0IsYUFBcEIsRUFBbUMsYUFBbkM7QUFDRDtBQUNGO0FBQ0Q7QUExQ1c7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUEyQ1gsVUFBSSxRQUFRLElBQVosRUFBa0I7QUFDaEIsYUFBSyxJQUFMO0FBQ0E7QUFDQSxlQUFPLGdCQUFQLENBQXdCLE9BQXhCLEVBQWlDLFlBQVk7QUFDM0MsZUFBSyxJQUFMO0FBQ0QsU0FGRDtBQUdBLGVBQU8sZ0JBQVAsQ0FBd0IsTUFBeEIsRUFBZ0MsWUFBWTtBQUMxQyxlQUFLLFFBQUw7QUFDRCxTQUZEO0FBR0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7bUNBS2UsTyxFQUFTLEMsRUFBRztBQUN6QixVQUFJLGFBQWEsS0FBSyxTQUFMLENBQWUsZ0JBQWYsQ0FBZ0MsY0FBaEMsQ0FBakI7QUFDQSxVQUFJLFdBQVcsTUFBZixFQUF1QjtBQUNyQixZQUFJLG1CQUFPLFlBQVAsQ0FBb0IsQ0FBcEIsRUFBdUIsVUFBdkIsQ0FBSixFQUF3QztBQUN0QyxlQUFLLE9BQUwsQ0FBYSxPQUFiO0FBQ0Q7QUFDRixPQUpELE1BSU87QUFDTCxhQUFLLE9BQUwsQ0FBYSxPQUFiO0FBQ0Q7QUFDRDtBQUNBLFVBQUksS0FBSyxPQUFMLENBQWEsU0FBakIsRUFBNEI7QUFDMUIsYUFBSyxTQUFMO0FBQ0QsT0FGRCxNQUVPLElBQUksS0FBSyxPQUFMLENBQWEsSUFBakIsRUFBdUI7QUFDNUIsYUFBSyxJQUFMO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7b0NBS2dCLE8sRUFBUyxDLEVBQUc7QUFDMUIsVUFBSSxhQUFhLEtBQUssU0FBTCxDQUFlLGdCQUFmLENBQWdDLGNBQWhDLENBQWpCO0FBQ0EsVUFBSSxXQUFXLE1BQWYsRUFBdUI7QUFDckIsWUFBSSxtQkFBTyxZQUFQLENBQW9CLENBQXBCLEVBQXVCLFVBQXZCLENBQUosRUFBd0M7QUFDdEMsZUFBSyxRQUFMLENBQWMsT0FBZDtBQUNEO0FBQ0YsT0FKRCxNQUlPO0FBQ0wsYUFBSyxRQUFMLENBQWMsT0FBZDtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7MkJBSXNCO0FBQUEsVUFBakIsT0FBaUIsdUVBQVAsS0FBTzs7QUFDcEIsVUFBSSxPQUFPLElBQVg7QUFDQSxVQUFJLFVBQVUsS0FBSyxPQUFuQjtBQUNBO0FBQ0EsV0FBSyxRQUFMO0FBQ0EsVUFBSSxPQUFPLENBQUMsT0FBRCxHQUFXLFFBQVEsSUFBbkIsR0FBMEIsQ0FBckM7QUFDQSxXQUFLLFlBQUwsR0FBb0IsWUFBWSxZQUFZO0FBQzFDLFlBQUksQ0FBQyxRQUFRLFVBQVQsSUFBdUIsS0FBSyxNQUFMLENBQVksWUFBWixLQUE2QixJQUF4RCxFQUE4RDtBQUFFO0FBQzlELGlCQUFPLEtBQVA7QUFDRDtBQUNELGFBQUssV0FBTCxHQUFtQixLQUFLLFdBQUwsS0FBcUIsU0FBckIsR0FBaUMsS0FBSyxXQUFMLEdBQW1CLENBQXBELEdBQXdELENBQTNFO0FBQ0EsYUFBSyxXQUFMLEdBQW1CLEtBQUssV0FBTCxJQUFvQixLQUFLLFFBQUwsQ0FBYyxNQUFsQyxHQUEyQyxDQUEzQyxHQUErQyxLQUFLLFdBQXZFO0FBQ0EsYUFBSyxPQUFMLENBQWEsS0FBSyxRQUFMLENBQWMsS0FBSyxXQUFuQixDQUFiO0FBQ0QsT0FQbUIsRUFPakIsSUFQaUIsQ0FBcEI7QUFRRDs7QUFFRDs7Ozs7OztnQ0FJMkI7QUFBQSxVQUFqQixPQUFpQix1RUFBUCxLQUFPOztBQUN6QixVQUFJLE9BQU8sSUFBWDtBQUNBLFVBQUksVUFBVSxLQUFLLE9BQW5CO0FBQ0E7QUFDQSxXQUFLLFFBQUw7QUFDQSxVQUFJLE9BQU8sQ0FBQyxPQUFELEdBQVcsUUFBUSxTQUFuQixHQUErQixDQUExQztBQUNBLFVBQUksU0FBUyxNQUFiLEVBQXFCO0FBQ25CLGFBQUssZ0JBQUwsR0FBd0IsV0FBVyxZQUFZO0FBQzdDLGVBQUssSUFBTCxDQUFVLElBQVY7QUFDQSxlQUFLLElBQUw7QUFDRCxTQUh1QixFQUdyQixJQUhxQixDQUF4QjtBQUlEO0FBQ0Y7O0FBRUQ7Ozs7OzsrQkFHVztBQUNULG9CQUFjLEtBQUssWUFBbkI7QUFDQSxtQkFBYSxLQUFLLGdCQUFsQjtBQUNEOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Z0NBS1ksTyxFQUFTO0FBQ25CLFVBQUksQ0FBQyxLQUFLLFFBQU4sSUFBa0IsQ0FBQyxLQUFLLFFBQUwsQ0FBYyxNQUFyQyxFQUE2QztBQUMzQyxlQUFPLEVBQUMsS0FBSyxFQUFOLEVBQVUsUUFBUSxJQUFsQixFQUFQO0FBQ0Q7QUFDRCxVQUFJLEtBQUssSUFBTCxLQUFjLEtBQWxCLEVBQXlCO0FBQ3ZCO0FBQ0EsZUFBTyxFQUFDLEtBQUssS0FBSyxRQUFYLEVBQXFCLFFBQVEsS0FBSyxRQUFMLENBQWMsQ0FBZCxDQUE3QixFQUFQO0FBQ0QsT0FIRCxNQUdPLElBQUksS0FBSyxJQUFMLEtBQWMsUUFBbEIsRUFBNEI7QUFDakM7QUFDQSxZQUFJLFFBQVEsUUFBUSxZQUFSLENBQXFCLFlBQXJCLENBQVo7QUFDQSxZQUFJLEtBQUosRUFBVztBQUNUO0FBQ0EsY0FBSSxnQkFBZ0IsTUFBTSxJQUFOLENBQVcsS0FBSyxRQUFoQixFQUEwQixNQUExQixDQUFpQztBQUFBLG1CQUFLLEVBQUUsWUFBRixDQUFlLFlBQWYsTUFBaUMsS0FBdEM7QUFBQSxXQUFqQyxDQUFwQjtBQUNBLGNBQUksUUFBUSxtQkFBTyxTQUFQLENBQWlCLGFBQWpCLENBQVo7QUFDQSxpQkFBTyxFQUFDLEtBQUssS0FBTixFQUFhLFFBQVEsTUFBTSxDQUFOLENBQXJCLEVBQVA7QUFDRCxTQUxELE1BS087QUFDTDtBQUNBLGNBQUksU0FBUSxPQUFaO0FBQ0EsaUJBQU8sRUFBQyxLQUFLLG1CQUFPLFNBQVAsQ0FBaUIsTUFBakIsQ0FBTixFQUErQixRQUFRLE1BQXZDLEVBQVA7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OytCQUtXLE8sRUFBUztBQUNsQixVQUFJLENBQUMsS0FBSyxPQUFOLElBQWlCLENBQUMsS0FBSyxPQUFMLENBQWEsTUFBbkMsRUFBMkM7QUFDekMsZUFBTyxFQUFQO0FBQ0Q7QUFDRCxVQUFJLEtBQUssSUFBTCxLQUFjLEtBQWxCLEVBQXlCO0FBQ3ZCO0FBQ0EsZUFBTyxLQUFLLE9BQVo7QUFDRCxPQUhELE1BR08sSUFBSSxLQUFLLElBQUwsS0FBYyxRQUFsQixFQUE0QjtBQUNqQztBQUNBLFlBQUksUUFBUSxRQUFRLFlBQVIsQ0FBcUIsWUFBckIsQ0FBWjtBQUNBLFlBQUksZ0JBQWdCLE1BQU0sSUFBTixDQUFXLEtBQUssUUFBaEIsRUFBMEIsTUFBMUIsQ0FBaUM7QUFBQSxpQkFBSyxFQUFFLFlBQUYsQ0FBZSxZQUFmLE1BQWlDLEtBQXRDO0FBQUEsU0FBakMsQ0FBcEI7QUFDQSxZQUFJLGVBQWUsTUFBTSxJQUFOLENBQVcsS0FBSyxPQUFoQixFQUF5QixNQUF6QixDQUFnQztBQUFBLGlCQUFLLEVBQUUsWUFBRixDQUFlLFlBQWYsTUFBaUMsS0FBdEM7QUFBQSxTQUFoQyxDQUFuQjtBQUNBLFlBQUksY0FBSjtBQUNBLFlBQUksS0FBSixFQUFXO0FBQ1Q7QUFDQSxrQkFBUSxZQUFSO0FBQ0EsaUJBQU8sbUJBQU8sU0FBUCxDQUFpQixLQUFqQixDQUFQO0FBQ0QsU0FKRCxNQUlPO0FBQ0w7QUFDQSxjQUFJLFFBQVEsY0FBYyxTQUFkLENBQXdCO0FBQUEsbUJBQUssTUFBTSxPQUFYO0FBQUEsV0FBeEIsQ0FBWjtBQUNBLGtCQUFRLGFBQWEsS0FBYixDQUFSO0FBQ0EsaUJBQU8sbUJBQU8sU0FBUCxDQUFpQixLQUFqQixDQUFQO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOzs7Ozs7OzswQ0FLc0IsTSxFQUFRO0FBQzVCLFVBQUksQ0FBQyxLQUFLLFFBQU4sSUFBa0IsQ0FBQyxLQUFLLFFBQUwsQ0FBYyxNQUFyQyxFQUE2QztBQUMzQyxlQUFPLEVBQVA7QUFDRDtBQUNEO0FBQ0EsVUFBSSxRQUFRLE9BQU8sWUFBUCxDQUFvQixZQUFwQixDQUFaO0FBQ0EsVUFBSSxnQkFBZ0IsTUFBTSxJQUFOLENBQVcsS0FBSyxRQUFoQixFQUEwQixNQUExQixDQUFpQztBQUFBLGVBQUssRUFBRSxZQUFGLENBQWUsWUFBZixNQUFpQyxLQUF0QztBQUFBLE9BQWpDLENBQXBCO0FBQ0EsVUFBSSxlQUFlLE1BQU0sSUFBTixDQUFXLEtBQUssT0FBaEIsRUFBeUIsTUFBekIsQ0FBZ0M7QUFBQSxlQUFLLEVBQUUsWUFBRixDQUFlLFlBQWYsTUFBaUMsS0FBdEM7QUFBQSxPQUFoQyxDQUFuQjtBQUNBLFVBQUksY0FBSjtBQUNBLFVBQUksS0FBSixFQUFXO0FBQ1Q7QUFDQSxnQkFBUSxhQUFSO0FBQ0EsZUFBTyxtQkFBTyxTQUFQLENBQWlCLEtBQWpCLENBQVA7QUFDRCxPQUpELE1BSU87QUFDTDtBQUNBLFlBQUksUUFBUSxhQUFhLFNBQWIsQ0FBdUI7QUFBQSxpQkFBSyxNQUFNLE1BQVg7QUFBQSxTQUF2QixDQUFaO0FBQ0EsZ0JBQVEsY0FBYyxLQUFkLENBQVI7QUFDQSxlQUFPLG1CQUFPLFNBQVAsQ0FBaUIsS0FBakIsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7b0NBSWdCO0FBQ2QsVUFBSSxDQUFDLEtBQUssT0FBTCxDQUFhLFVBQWxCLEVBQThCO0FBQzVCLGVBQU8sRUFBUDtBQUNELE9BRkQsTUFFTztBQUNMLGVBQU8sS0FBSyxNQUFMLENBQVksZ0JBQVosQ0FBNkIsS0FBSyxPQUFMLENBQWEsVUFBMUMsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7a0NBSWM7QUFDWixhQUFPLG1CQUFPLFFBQVAsQ0FBZ0IsS0FBSyxTQUFyQixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Z0NBSVksRyxFQUFLO0FBQ2YseUJBQU8sUUFBUCxDQUFnQixLQUFLLFNBQXJCLElBQWtDLEdBQWxDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7K0JBSVcsTyxFQUFTO0FBQ2xCLFVBQUksTUFBTSxtQkFBTyxRQUFQLENBQWdCLEtBQUssU0FBckIsQ0FBVjtBQUNBLFVBQUksSUFBSixDQUFTLE9BQVQ7QUFDRDs7QUFFRDs7Ozs7OztrQ0FJYyxPLEVBQVM7QUFDckIseUJBQU8sUUFBUCxDQUFnQixLQUFLLFNBQXJCLElBQWtDLG1CQUFPLFFBQVAsQ0FBZ0IsS0FBSyxTQUFyQixFQUFnQyxNQUFoQyxDQUF1QztBQUFBLGVBQUssTUFBTSxPQUFYO0FBQUEsT0FBdkMsQ0FBbEM7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7OzRCQUtRLE8sRUFBUztBQUFBOztBQUNmLFVBQUksQ0FBQyxDQUFDLDhCQUFRLFNBQVIsRUFBa0IsUUFBbEIsOENBQThCLEtBQUssT0FBTCxDQUFhLE9BQTNDLEVBQUQsSUFBd0QsUUFBUSxTQUFSLENBQWtCLFFBQWxCLENBQTJCLFdBQTNCLENBQXpELEtBQXFHLENBQUMsUUFBUSxTQUFSLENBQWtCLFFBQWxCLENBQTJCLFVBQTNCLENBQTFHLEVBQWtKO0FBQ2hKLGVBQU8sSUFBUDtBQUNELE9BRkQsTUFFTztBQUNMLGVBQU8sS0FBUDtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OzZCQUtTLE8sRUFBUztBQUFBOztBQUNoQjtBQUNBLFVBQUksT0FBTyxLQUFLLE9BQUwsQ0FBYSxHQUFiLEdBQW1CLEtBQUssV0FBTCxHQUFtQixNQUFqRDtBQUNBLFVBQUksQ0FBQyxJQUFMLEVBQVc7QUFDVCxlQUFPLEtBQVA7QUFDRDtBQUNELFVBQUksQ0FBQywrQkFBUSxTQUFSLEVBQWtCLFFBQWxCLCtDQUE4QixLQUFLLE9BQUwsQ0FBYSxPQUEzQyxNQUF1RCxRQUFRLFNBQVIsQ0FBa0IsUUFBbEIsQ0FBMkIsVUFBM0IsQ0FBeEQsS0FBbUcsQ0FBQyxRQUFRLFNBQVIsQ0FBa0IsUUFBbEIsQ0FBMkIsV0FBM0IsQ0FBeEcsRUFBaUo7QUFDL0ksZUFBTyxJQUFQO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsZUFBTyxLQUFQO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs0QkFJUSxPLEVBQVM7QUFDZixVQUFJLE9BQU8sSUFBWDtBQUNBLFVBQUksVUFBVSxLQUFLLE9BQW5CO0FBQ0E7QUFDQSxVQUFJLEtBQUssT0FBTCxDQUFhLE9BQWIsQ0FBSixFQUEyQjtBQUN6QixZQUFJLFlBQVksS0FBSyxXQUFMLENBQWlCLE9BQWpCLENBQWhCO0FBQ0EsYUFBSyxVQUFMLENBQWdCLFVBQVUsTUFBMUI7QUFDQSxZQUFJLFdBQVUsS0FBSyxVQUFMLENBQWdCLE9BQWhCLENBQWQ7QUFDQSxZQUFJLGNBQWEsS0FBSyxhQUFMLEVBQWpCO0FBQ0EsWUFBSSxrQkFBa0I7QUFDcEIsb0JBQVUsb0JBQVk7QUFDcEIsaUJBQUssWUFBTCxDQUFrQixVQUFVLEdBQTVCLEVBQWlDLFNBQWpDLEVBQTRDLFVBQTVDO0FBQ0QsV0FIbUI7QUFJcEIsbUJBQVMsbUJBQVk7QUFDbkIsaUJBQUssWUFBTCxDQUFrQixRQUFsQixFQUEyQixTQUEzQixFQUFzQyxTQUF0QztBQUNELFdBTm1CO0FBT3BCLHNCQUFZLHNCQUFZO0FBQ3RCLGlCQUFLLFlBQUwsQ0FBa0IsV0FBbEIsRUFBOEIsU0FBOUIsRUFBeUMsWUFBekM7QUFDRDtBQVRtQixTQUF0QjtBQVdBO0FBQ0EsWUFBSSxRQUFRLElBQVosRUFBa0I7QUFDaEIsY0FBSSxRQUFRLENBQVo7QUFEZ0I7QUFBQTtBQUFBOztBQUFBO0FBRWhCLGtDQUFvQixLQUFLLFFBQUwsQ0FBYyxPQUFkLEVBQXBCLG1JQUE2QztBQUFBO0FBQUEsa0JBQW5DLENBQW1DO0FBQUEsa0JBQWhDLEVBQWdDOztBQUMzQyxrQkFBSSxPQUFPLE9BQVgsRUFBb0I7QUFDbEIsd0JBQVEsQ0FBUjtBQUNBO0FBQ0Q7QUFDRjtBQVBlO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBUWhCLGVBQUssV0FBTCxHQUFtQixLQUFuQjtBQUNEO0FBQ0Q7QUFDQSxZQUFJLFdBQVcsS0FBSyxXQUFMLEVBQWY7QUFDQSxZQUFJLFNBQVMsTUFBVCxHQUFrQixRQUFRLEdBQTlCLEVBQW1DO0FBQ2pDLGVBQUssUUFBTCxDQUFjLFNBQVMsQ0FBVCxDQUFkLEVBQTJCLGVBQTNCO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsMEJBQWdCLFFBQWhCO0FBQ0EsMEJBQWdCLE9BQWhCO0FBQ0EsMEJBQWdCLFVBQWhCO0FBQ0Q7QUFDRixPQXBDRCxNQW9DTyxJQUFJLFFBQVEsTUFBWixFQUFvQjtBQUN6QjtBQUNBLGFBQUssUUFBTCxDQUFjLE9BQWQ7QUFDRDtBQUNGOztBQUVEOzs7Ozs7Ozs2QkFLUyxPLEVBQWlDO0FBQUEsVUFBeEIsZUFBd0IsdUVBQU4sSUFBTTs7QUFDeEM7QUFDQSxVQUFJLEtBQUssUUFBTCxDQUFjLE9BQWQsQ0FBSixFQUE0QjtBQUMxQixZQUFJLFlBQVksS0FBSyxXQUFMLENBQWlCLE9BQWpCLENBQWhCO0FBQ0EsYUFBSyxhQUFMLENBQW1CLFVBQVUsTUFBN0I7QUFDQSxhQUFLLGFBQUwsQ0FBbUIsVUFBVSxHQUE3QixFQUFrQyxTQUFsQyxFQUE2QyxVQUE3QyxFQUF5RCxlQUF6RDtBQUNBLFlBQUksVUFBVSxLQUFLLFVBQUwsQ0FBZ0IsT0FBaEIsQ0FBZDtBQUNBLGFBQUssYUFBTCxDQUFtQixPQUFuQixFQUE0QixTQUE1QixFQUF1QyxTQUF2QyxFQUFrRCxlQUFsRDtBQUNBLFlBQUksYUFBYSxLQUFLLGFBQUwsRUFBakI7QUFDQSxhQUFLLGFBQUwsQ0FBbUIsVUFBbkIsRUFBK0IsU0FBL0IsRUFBMEMsWUFBMUMsRUFBd0QsZUFBeEQ7QUFDRDtBQUNGOztBQUVEOzs7Ozs7Ozs7aUNBTWEsRyxFQUFLLFMsRUFBVyxJLEVBQU07QUFDakMsVUFBSSxPQUFPLElBQVg7QUFDQSxVQUFJLFVBQVUsS0FBSyxPQUFuQjtBQUNBO0FBQ0EsVUFBSSxXQUFXLFNBQVgsUUFBVyxDQUFVLElBQVYsRUFBZ0IsRUFBaEIsRUFBb0IsU0FBcEIsRUFBK0IsSUFBL0IsRUFBcUM7QUFBQTs7QUFDbEQsNkJBQUcsU0FBSCxFQUFhLEdBQWIsMENBQW9CLFFBQVEsT0FBNUI7QUFDQSxXQUFHLFNBQUgsQ0FBYSxNQUFiLENBQW9CLEtBQXBCO0FBQ0EsYUFBSyxtQkFBTCxDQUF5QixFQUF6QixFQUE2QixJQUE3QjtBQUNBO0FBQ0EsWUFBSSxTQUFTLFNBQWIsRUFBd0I7QUFDdEIsZUFBSyxrQkFBTDtBQUNBLGVBQUssZUFBTCxDQUFxQixFQUFyQjtBQUNBLGVBQUssZUFBTCxDQUFxQixFQUFyQjtBQUNBLGVBQUssZUFBTCxDQUFxQixFQUFyQjtBQUNBLGVBQUssaUJBQUwsQ0FBdUIsRUFBdkI7QUFDQSxlQUFLLGNBQUwsQ0FBb0IsRUFBcEIsRUFBd0IsVUFBVSxNQUFsQztBQUNBLGVBQUssa0JBQUw7QUFDRDtBQUNEO0FBQ0EsV0FBRyxhQUFILENBQWlCLElBQUksV0FBSixDQUFnQixJQUFoQixDQUFqQjtBQUNELE9BaEJEO0FBaUJBO0FBckJpQztBQUFBO0FBQUE7O0FBQUE7QUFzQmpDLDhCQUFlLEdBQWYsbUlBQW9CO0FBQUEsY0FBWCxFQUFXOztBQUNsQixhQUFHLFNBQUgsQ0FBYSxNQUFiLENBQW9CLFdBQXBCO0FBQ0EsdUJBQWEsR0FBRyxPQUFILENBQVcsY0FBeEI7QUFDQSx1QkFBYSxHQUFHLE9BQUgsQ0FBVyxhQUF4QjtBQUNBLGNBQUksUUFBUSxHQUFHLE9BQUgsQ0FBVyxTQUF2QjtBQUNBLGNBQUksS0FBSixFQUFXO0FBQ1QsZUFBRyxTQUFILENBQWEsR0FBYixDQUFpQixVQUFqQjtBQUNBLGVBQUcsT0FBSCxDQUFXLGNBQVgsR0FBNEIsV0FBVyxVQUFVLElBQVYsRUFBZ0IsRUFBaEIsRUFBb0IsU0FBcEIsRUFBK0IsSUFBL0IsRUFBcUM7QUFDMUUsaUJBQUcsU0FBSCxDQUFhLE1BQWIsQ0FBb0IsVUFBcEI7QUFDQSx1QkFBUyxJQUFULEVBQWUsRUFBZixFQUFtQixTQUFuQixFQUE4QixJQUE5QjtBQUNELGFBSDJCLEVBR3pCLFdBQVcsS0FBWCxDQUh5QixFQUdOLElBSE0sRUFHQSxFQUhBLEVBR0ksU0FISixFQUdlLElBSGYsRUFHcUIsUUFIckIsRUFBNUI7QUFJRCxXQU5ELE1BTU87QUFDTCxxQkFBUyxJQUFULEVBQWUsRUFBZixFQUFtQixTQUFuQixFQUE4QixJQUE5QjtBQUNEO0FBQ0Y7QUFwQ2dDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFxQ2xDOztBQUVEOzs7Ozs7Ozs7O2tDQU9jLEcsRUFBSyxTLEVBQVcsSSxFQUFNLGUsRUFBaUI7QUFDbkQsVUFBSSxPQUFPLElBQVg7QUFDQSxVQUFJLFVBQVUsS0FBSyxPQUFuQjtBQUNBO0FBQ0EsVUFBSSxhQUFhLFNBQWIsVUFBYSxDQUFVLElBQVYsRUFBZ0IsRUFBaEIsRUFBb0IsU0FBcEIsRUFBK0IsSUFBL0IsRUFBcUMsZUFBckMsRUFBc0Q7QUFBQTs7QUFDckUsNkJBQUcsU0FBSCxFQUFhLE1BQWIsMENBQXVCLFFBQVEsT0FBL0I7QUFDQSxXQUFHLFNBQUgsQ0FBYSxHQUFiLENBQWlCLEtBQWpCO0FBQ0EsYUFBSyxvQkFBTCxDQUEwQixFQUExQixFQUE4QixJQUE5QixFQUFvQyxlQUFwQztBQUNBO0FBQ0EsWUFBSSxtQkFBbUIsZ0JBQWdCLElBQWhCLENBQW5CLElBQTRDLENBQUMsZ0JBQWdCLE9BQU8sTUFBdkIsQ0FBakQsRUFBaUY7QUFDL0UsY0FBSSxRQUFRLE9BQVIsSUFBbUIsUUFBUSxPQUFSLENBQWdCLElBQWhCLENBQXZCLEVBQThDO0FBQzVDLDRCQUFnQixJQUFoQjtBQUNBLDRCQUFnQixPQUFPLE1BQXZCLElBQWlDLElBQWpDO0FBQ0Q7QUFDRjtBQUNEO0FBQ0EsWUFBSSxTQUFTLFNBQWIsRUFBd0I7QUFDdEIsZUFBSyxtQkFBTDtBQUNBLGVBQUssa0JBQUwsQ0FBd0IsRUFBeEI7QUFDQSxlQUFLLGVBQUwsQ0FBcUIsRUFBckI7QUFDRDtBQUNEO0FBQ0EsV0FBRyxhQUFILENBQWlCLElBQUksV0FBSixDQUFnQixLQUFoQixDQUFqQjtBQUNELE9BbkJEO0FBb0JBO0FBeEJtRDtBQUFBO0FBQUE7O0FBQUE7QUF5Qm5ELCtCQUFlLEdBQWYsd0lBQW9CO0FBQUEsY0FBWCxFQUFXOztBQUNsQixhQUFHLFNBQUgsQ0FBYSxNQUFiLENBQW9CLFVBQXBCO0FBQ0EsdUJBQWEsR0FBRyxPQUFILENBQVcsY0FBeEI7QUFDQSx1QkFBYSxHQUFHLE9BQUgsQ0FBVyxhQUF4QjtBQUNBLGNBQUksUUFBUSxHQUFHLE9BQUgsQ0FBVyxVQUF2QjtBQUNBLGNBQUksS0FBSixFQUFXO0FBQ1QsZUFBRyxTQUFILENBQWEsR0FBYixDQUFpQixXQUFqQjtBQUNBLGVBQUcsT0FBSCxDQUFXLGNBQVgsR0FBNEIsV0FBVyxVQUFVLElBQVYsRUFBZ0IsRUFBaEIsRUFBb0IsU0FBcEIsRUFBK0IsSUFBL0IsRUFBcUMsZUFBckMsRUFBc0Q7QUFDM0YsaUJBQUcsU0FBSCxDQUFhLE1BQWIsQ0FBb0IsV0FBcEI7QUFDQSx5QkFBVyxJQUFYLEVBQWlCLEVBQWpCLEVBQXFCLFNBQXJCLEVBQWdDLElBQWhDLEVBQXNDLGVBQXRDO0FBQ0QsYUFIMkIsRUFHekIsV0FBVyxLQUFYLENBSHlCLEVBR04sSUFITSxFQUdBLEVBSEEsRUFHSSxTQUhKLEVBR2UsSUFIZixFQUdxQixlQUhyQixFQUdzQyxRQUh0QyxFQUE1QjtBQUlELFdBTkQsTUFNTztBQUNMLHVCQUFXLElBQVgsRUFBaUIsRUFBakIsRUFBcUIsU0FBckIsRUFBZ0MsSUFBaEMsRUFBc0MsZUFBdEM7QUFDRDtBQUNGO0FBdkNrRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBd0NwRDs7QUFFRDs7Ozs7Ozs7d0NBS29CLEUsRUFBSSxJLEVBQU07QUFDNUI7QUFDQSxVQUFJLFNBQVMsU0FBVCxNQUFTLENBQVUsRUFBVixFQUFjLElBQWQsRUFBb0I7QUFDL0I7QUFDQSxZQUFJLEdBQUcsU0FBSCxDQUFhLFFBQWIsQ0FBc0IsaUJBQXRCLENBQUosRUFBOEM7QUFDNUMsYUFBRyxLQUFILENBQVMsTUFBVCxHQUFrQixNQUFsQjtBQUNEO0FBQ0QsWUFBSSxHQUFHLFNBQUgsQ0FBYSxRQUFiLENBQXNCLGdCQUF0QixDQUFKLEVBQTZDO0FBQzNDLGFBQUcsS0FBSCxDQUFTLEtBQVQsR0FBaUIsTUFBakI7QUFDRDtBQUNGLE9BUkQ7QUFTQTtBQUNBLFVBQUksU0FBUyxLQUFLLGdCQUFMLENBQXNCLEVBQXRCLENBQWI7QUFDQSxtQkFBYSxHQUFHLE9BQUgsQ0FBVyxhQUF4QjtBQUNBLFVBQUksQ0FBQyxNQUFMLEVBQWE7QUFDWCxlQUFPLEVBQVAsRUFBVyxJQUFYO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsV0FBRyxPQUFILENBQVcsYUFBWCxHQUEyQixXQUFXLFVBQVUsRUFBVixFQUFjLElBQWQsRUFBb0I7QUFDeEQsaUJBQU8sRUFBUCxFQUFXLElBQVg7QUFDRCxTQUYwQixFQUV4QixNQUZ3QixFQUVoQixFQUZnQixFQUVaLElBRlksRUFFTixRQUZNLEVBQTNCO0FBR0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7O3lDQU1xQixFLEVBQUksSSxFQUFNLGUsRUFBaUI7QUFDOUMsVUFBSSxPQUFPLElBQVg7QUFDQSxVQUFJLFVBQVUsS0FBSyxPQUFuQjtBQUNBO0FBQ0EsVUFBSSxTQUFTLFNBQVQsTUFBUyxDQUFVLEVBQVYsRUFBYyxJQUFkLEVBQW9CO0FBQy9CLFdBQUcsU0FBSCxDQUFhLE1BQWIsQ0FBb0IsS0FBcEI7QUFDQTtBQUNBLFlBQUksU0FBUyxTQUFiLEVBQXdCO0FBQ3RCLGVBQUssbUJBQUw7QUFDRDtBQUNEO0FBQ0EsWUFBSSxtQkFBbUIsZ0JBQWdCLElBQWhCLENBQW5CLElBQTRDLENBQUMsZ0JBQWdCLE9BQU8sTUFBdkIsQ0FBakQsRUFBaUY7QUFDL0UsY0FBSSxDQUFDLFFBQVEsT0FBVCxJQUFvQixDQUFDLFFBQVEsT0FBUixDQUFnQixJQUFoQixDQUF6QixFQUFnRDtBQUM5Qyw0QkFBZ0IsSUFBaEI7QUFDQSw0QkFBZ0IsT0FBTyxNQUF2QixJQUFpQyxJQUFqQztBQUNEO0FBQ0Y7QUFDRixPQWJEO0FBY0E7QUFDQSxVQUFJLFNBQVMsS0FBSyxnQkFBTCxDQUFzQixFQUF0QixDQUFiO0FBQ0EsbUJBQWEsR0FBRyxPQUFILENBQVcsYUFBeEI7QUFDQSxVQUFJLENBQUMsTUFBTCxFQUFhO0FBQ1gsZUFBTyxFQUFQLEVBQVcsSUFBWDtBQUNELE9BRkQsTUFFTztBQUNMLFdBQUcsT0FBSCxDQUFXLGFBQVgsR0FBMkIsV0FBVyxVQUFVLEVBQVYsRUFBYyxJQUFkLEVBQW9CO0FBQ3hELGlCQUFPLEVBQVAsRUFBVyxJQUFYO0FBQ0QsU0FGMEIsRUFFeEIsTUFGd0IsRUFFaEIsRUFGZ0IsRUFFWixJQUZZLEVBRU4sUUFGTSxFQUEzQjtBQUdEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7O3FDQUtpQixFLEVBQUk7QUFDbkIsVUFBSSxPQUFPLElBQVg7QUFDQSxVQUFJLFVBQVUsS0FBSyxPQUFuQjtBQUNBO0FBQ0EsVUFBSSxTQUFTLFFBQVEsTUFBckI7QUFDQSxVQUFJLFdBQVcsU0FBZixFQUEwQjtBQUN4QixlQUFPLE1BQVA7QUFDRCxPQUZELE1BRU87QUFDTCxZQUFJLFFBQVEsaUJBQWlCLEVBQWpCLENBQVo7QUFDQSxZQUFJLGFBQWEsV0FBVyxNQUFNLGtCQUFqQixJQUF1QyxXQUFXLE1BQU0sZUFBakIsQ0FBeEQ7QUFDQSxZQUFJLFlBQVksV0FBVyxNQUFNLGlCQUFqQixJQUFzQyxXQUFXLE1BQU0sY0FBakIsQ0FBdEQ7QUFDQSxZQUFJLGNBQWMsU0FBbEIsRUFBNkI7QUFDM0IsbUJBQVMsS0FBSyxHQUFMLENBQVMsVUFBVCxFQUFxQixTQUFyQixDQUFUO0FBQ0Q7QUFDRCxlQUFPLFNBQVMsSUFBaEI7QUFDRDtBQUNGOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7O3lDQUdxQjtBQUNuQixVQUFJLE9BQU8sSUFBWDtBQUNBLFVBQUksVUFBVSxLQUFLLE9BQW5CO0FBQ0E7QUFDQSxVQUFJLFFBQVEsU0FBWixFQUF1QjtBQUFBOztBQUNyQixZQUFJLFlBQVksU0FBUyxlQUF6QjtBQUNBLDBDQUFVLFNBQVYsRUFBb0IsR0FBcEIsZ0RBQTJCLFFBQVEsU0FBUixDQUFrQixLQUFsQixDQUF3QixHQUF4QixDQUEzQjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7OzswQ0FHc0I7QUFDcEIsVUFBSSxPQUFPLElBQVg7QUFDQSxVQUFJLFVBQVUsS0FBSyxPQUFuQjtBQUNBO0FBQ0EsVUFBSSxRQUFRLFNBQVosRUFBdUI7QUFBQTs7QUFDckIsWUFBSSxZQUFZLFNBQVMsZUFBekI7QUFDQSwyQ0FBVSxTQUFWLEVBQW9CLE1BQXBCLGlEQUE4QixRQUFRLFNBQVIsQ0FBa0IsS0FBbEIsQ0FBd0IsR0FBeEIsQ0FBOUI7QUFDRDtBQUNGOztBQUVEOzs7Ozs7O29DQUlnQixFLEVBQUk7QUFDbEIsVUFBSSxPQUFPLElBQVg7QUFDQSxVQUFJLFVBQVUsS0FBSyxPQUFuQjtBQUNBO0FBQ0EsVUFBSSxRQUFRLFFBQVosRUFBc0I7QUFDcEIsWUFBSSxpQkFBSjtBQUNBLFlBQUksUUFBUSxRQUFSLEtBQXFCLFFBQXpCLEVBQW1DO0FBQ2pDLHFCQUFXLG1CQUFPLFNBQVAsQ0FBaUIsS0FBSyxNQUF0QixDQUFYO0FBQ0QsU0FGRCxNQUVPLElBQUksUUFBUSxRQUFSLEtBQXFCLFNBQXpCLEVBQW9DO0FBQ3pDLHFCQUFXLG1CQUFPLFNBQVAsQ0FBaUIsRUFBakIsQ0FBWDtBQUNELFNBRk0sTUFFQTtBQUNMLHFCQUFXLEdBQUcsZ0JBQUgsQ0FBb0IsUUFBUSxRQUE1QixDQUFYO0FBQ0EsY0FBSSxDQUFDLFNBQVMsTUFBZCxFQUFzQjtBQUNwQix1QkFBVyxLQUFLLE1BQUwsQ0FBWSxnQkFBWixDQUE2QixRQUFRLFFBQXJDLENBQVg7QUFDRDtBQUNGO0FBWG1CO0FBQUE7QUFBQTs7QUFBQTtBQVlwQixpQ0FBb0IsUUFBcEIsd0lBQThCO0FBQUEsZ0JBQXJCLE9BQXFCOztBQUM1QixnQkFBSSxXQUFXLFFBQVEsZ0JBQVIsQ0FBeUIsY0FBekIsQ0FBZjtBQUNBLGdCQUFJLENBQUMsU0FBUyxNQUFkLEVBQXNCO0FBQ3BCLHlCQUFXLG1CQUFPLGFBQVAsQ0FBcUIsaUNBQXJCLENBQVg7QUFDQSxzQkFBUSxNQUFSLENBQWUsUUFBZjtBQUNEO0FBQ0Y7QUFsQm1CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFtQnJCO0FBQ0Y7O0FBRUQ7Ozs7Ozs7b0NBSWdCLEUsRUFBSTtBQUNsQixVQUFJLEdBQUcsU0FBSCxDQUFhLFFBQWIsQ0FBc0IsYUFBdEIsQ0FBSixFQUEwQztBQUN4QyxZQUFJLE1BQU0sS0FBSyxNQUFMLENBQVksV0FBdEI7QUFDQSxZQUFJLFNBQVMsR0FBRyxXQUFoQjtBQUNBLFdBQUcsS0FBSCxDQUFTLElBQVQsR0FBaUIsQ0FBQyxNQUFNLE1BQVAsSUFBaUIsQ0FBbEIsR0FBdUIsSUFBdkM7QUFDRDtBQUNGOztBQUVEOzs7Ozs7O29DQUlnQixFLEVBQUk7QUFDbEIsVUFBSSxHQUFHLFNBQUgsQ0FBYSxRQUFiLENBQXNCLGFBQXRCLENBQUosRUFBMEM7QUFDeEMsWUFBSSxNQUFNLEtBQUssTUFBTCxDQUFZLFlBQXRCO0FBQ0EsWUFBSSxTQUFTLEdBQUcsWUFBaEI7QUFDQSxXQUFHLEtBQUgsQ0FBUyxHQUFULEdBQWdCLENBQUMsTUFBTSxNQUFQLElBQWlCLENBQWxCLEdBQXVCLElBQXRDO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7OztzQ0FJa0IsRSxFQUFJO0FBQ3BCLFVBQUksR0FBRyxTQUFILENBQWEsUUFBYixDQUFzQixpQkFBdEIsQ0FBSixFQUE4QztBQUM1QyxXQUFHLFNBQUgsQ0FBYSxHQUFiLENBQWlCLGVBQWpCO0FBQ0EsV0FBRyxLQUFILENBQVMsTUFBVCxHQUFrQixNQUFsQjtBQUNBLFdBQUcsS0FBSCxDQUFTLFVBQVQsR0FBc0IsRUFBdEI7QUFDQSxXQUFHLEtBQUgsQ0FBUyxhQUFULEdBQXlCLEVBQXpCO0FBQ0EsWUFBSSxJQUFJLEdBQUcsWUFBSCxHQUFrQixJQUExQjtBQUNBLFlBQUksS0FBSyxHQUFHLEtBQUgsQ0FBUyxVQUFsQjtBQUNBLFlBQUksS0FBSyxHQUFHLEtBQUgsQ0FBUyxhQUFsQjtBQUNBLDJCQUFPLHFCQUFQLENBQTZCLElBQTdCLENBQWtDLE1BQWxDLEVBQTBDLFlBQVk7QUFDcEQsYUFBRyxLQUFILENBQVMsTUFBVCxHQUFrQixHQUFsQjtBQUNBLGFBQUcsS0FBSCxDQUFTLFVBQVQsR0FBc0IsR0FBdEI7QUFDQSxhQUFHLEtBQUgsQ0FBUyxhQUFULEdBQXlCLEdBQXpCO0FBQ0EsNkJBQU8scUJBQVAsQ0FBNkIsSUFBN0IsQ0FBa0MsTUFBbEMsRUFBMEMsWUFBWTtBQUNwRCxlQUFHLFNBQUgsQ0FBYSxNQUFiLENBQW9CLGVBQXBCO0FBQ0EsZUFBRyxLQUFILENBQVMsTUFBVCxHQUFrQixDQUFsQjtBQUNBLGVBQUcsS0FBSCxDQUFTLFVBQVQsR0FBc0IsRUFBdEI7QUFDQSxlQUFHLEtBQUgsQ0FBUyxhQUFULEdBQXlCLEVBQXpCO0FBQ0QsV0FMRDtBQU1ELFNBVkQ7QUFXRDtBQUNELFVBQUksR0FBRyxTQUFILENBQWEsUUFBYixDQUFzQixnQkFBdEIsQ0FBSixFQUE2QztBQUMzQyxXQUFHLEtBQUgsQ0FBUyxLQUFULEdBQWlCLE1BQWpCO0FBQ0EsV0FBRyxLQUFILENBQVMsV0FBVCxHQUF1QixFQUF2QjtBQUNBLFdBQUcsS0FBSCxDQUFTLFlBQVQsR0FBd0IsRUFBeEI7QUFDQSxZQUFJLElBQUksR0FBRyxZQUFILEdBQWtCLElBQTFCO0FBQ0EsWUFBSSxLQUFLLEdBQUcsS0FBSCxDQUFTLFdBQWxCO0FBQ0EsWUFBSSxLQUFLLEdBQUcsS0FBSCxDQUFTLFlBQWxCO0FBQ0EsMkJBQU8scUJBQVAsQ0FBNkIsSUFBN0IsQ0FBa0MsTUFBbEMsRUFBMEMsWUFBWTtBQUNwRCxhQUFHLEtBQUgsQ0FBUyxLQUFULEdBQWlCLEdBQWpCO0FBQ0EsYUFBRyxLQUFILENBQVMsV0FBVCxHQUF1QixHQUF2QjtBQUNBLGFBQUcsS0FBSCxDQUFTLFlBQVQsR0FBd0IsR0FBeEI7QUFDQSw2QkFBTyxxQkFBUCxDQUE2QixJQUE3QixDQUFrQyxNQUFsQyxFQUEwQyxZQUFZO0FBQ3BELGVBQUcsU0FBSCxDQUFhLE1BQWIsQ0FBb0IsZUFBcEI7QUFDQSxlQUFHLEtBQUgsQ0FBUyxLQUFULEdBQWlCLENBQWpCO0FBQ0EsZUFBRyxLQUFILENBQVMsV0FBVCxHQUF1QixFQUF2QjtBQUNBLGVBQUcsS0FBSCxDQUFTLFlBQVQsR0FBd0IsRUFBeEI7QUFDRCxXQUxEO0FBTUQsU0FWRDtBQVdEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7dUNBSW1CLEUsRUFBSTtBQUNyQixVQUFJLEdBQUcsU0FBSCxDQUFhLFFBQWIsQ0FBc0IsaUJBQXRCLENBQUosRUFBOEM7QUFDNUMsWUFBSSxJQUFJLEdBQUcsWUFBSCxHQUFrQixJQUExQjtBQUNBLFlBQUksS0FBSyxHQUFHLEtBQUgsQ0FBUyxVQUFsQjtBQUNBLFlBQUksS0FBSyxHQUFHLEtBQUgsQ0FBUyxhQUFsQjtBQUNBLDJCQUFPLHFCQUFQLENBQTZCLElBQTdCLENBQWtDLE1BQWxDLEVBQTBDLFlBQVk7QUFDcEQsYUFBRyxLQUFILENBQVMsTUFBVCxHQUFrQixDQUFsQjtBQUNBLGFBQUcsS0FBSCxDQUFTLFVBQVQsR0FBc0IsRUFBdEI7QUFDQSxhQUFHLEtBQUgsQ0FBUyxhQUFULEdBQXlCLEVBQXpCO0FBQ0EsNkJBQU8scUJBQVAsQ0FBNkIsSUFBN0IsQ0FBa0MsTUFBbEMsRUFBMEMsWUFBWTtBQUNwRCxlQUFHLEtBQUgsQ0FBUyxNQUFULEdBQWtCLEdBQWxCO0FBQ0EsZUFBRyxLQUFILENBQVMsVUFBVCxHQUFzQixHQUF0QjtBQUNBLGVBQUcsS0FBSCxDQUFTLGFBQVQsR0FBeUIsR0FBekI7QUFDRCxXQUpEO0FBS0QsU0FURDtBQVVEO0FBQ0QsVUFBSSxHQUFHLFNBQUgsQ0FBYSxRQUFiLENBQXNCLGdCQUF0QixDQUFKLEVBQTZDO0FBQzNDLFlBQUksSUFBSSxHQUFHLFdBQUgsR0FBaUIsSUFBekI7QUFDQSxZQUFJLEtBQUssR0FBRyxLQUFILENBQVMsV0FBbEI7QUFDQSxZQUFJLEtBQUssR0FBRyxLQUFILENBQVMsWUFBbEI7QUFDQSwyQkFBTyxxQkFBUCxDQUE2QixJQUE3QixDQUFrQyxNQUFsQyxFQUEwQyxZQUFZO0FBQ3BELGFBQUcsS0FBSCxDQUFTLEtBQVQsR0FBaUIsQ0FBakI7QUFDQSxhQUFHLEtBQUgsQ0FBUyxXQUFULEdBQXVCLEVBQXZCO0FBQ0EsYUFBRyxLQUFILENBQVMsWUFBVCxHQUF3QixFQUF4QjtBQUNBLDZCQUFPLHFCQUFQLENBQTZCLElBQTdCLENBQWtDLE1BQWxDLEVBQTBDLFlBQVk7QUFDcEQsZUFBRyxLQUFILENBQVMsS0FBVCxHQUFpQixHQUFqQjtBQUNBLGVBQUcsS0FBSCxDQUFTLFdBQVQsR0FBdUIsR0FBdkI7QUFDQSxlQUFHLEtBQUgsQ0FBUyxZQUFULEdBQXdCLEdBQXhCO0FBQ0QsV0FKRDtBQUtELFNBVEQ7QUFVRDtBQUNGOztBQUVEOzs7Ozs7OzttQ0FLZSxFLEVBQUksTSxFQUFRO0FBQ3pCLFVBQUksT0FBTyxJQUFYO0FBQ0EsVUFBSSxVQUFVLEtBQUssT0FBbkI7QUFDQTtBQUNBLFVBQUksUUFBUSxXQUFaLEVBQXlCO0FBQ3ZCLFlBQUksZ0JBQWdCLEdBQUcsZ0JBQUgsQ0FBb0IsUUFBUSxXQUE1QixDQUFwQjtBQUNBLDJCQUFPLHFCQUFQLENBQTZCLElBQTdCLENBQWtDLE1BQWxDLEVBQTBDLFlBQVk7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDcEQsbUNBQXlCLGFBQXpCLHdJQUF3QztBQUFBLGtCQUEvQixZQUErQjs7QUFDdEM7QUFDQSxrQkFBSSx3QkFBd0IsbUJBQU8sV0FBUCxDQUFtQixHQUFuQixDQUF1QixFQUF2QixFQUEyQix1QkFBM0IsRUFBb0QsS0FBSyxxQkFBTCxDQUEyQixJQUEzQixDQUFnQyxJQUFoQyxFQUFzQyxJQUF0QyxDQUEyQyxJQUEzQyxFQUFpRCxZQUFqRCxFQUErRCxNQUEvRCxDQUFwRCxDQUE1QjtBQUNBO0FBQ0EsMkJBQWEsbUJBQWIsQ0FBaUMsT0FBakMsRUFBMEMscUJBQTFDO0FBQ0EsMkJBQWEsZ0JBQWIsQ0FBOEIsT0FBOUIsRUFBdUMscUJBQXZDO0FBQ0Q7QUFQbUQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVFyRCxTQVJEO0FBU0Q7QUFDRDtBQUNBLFVBQUksUUFBUSxZQUFaLEVBQTBCO0FBQ3hCLFlBQUksaUJBQWdCLFNBQVMsZUFBVCxDQUF5QixnQkFBekIsQ0FBMEMsUUFBUSxZQUFsRCxDQUFwQjtBQUNBLDJCQUFPLHFCQUFQLENBQTZCLElBQTdCLENBQWtDLE1BQWxDLEVBQTBDLFlBQVk7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDcEQsbUNBQXlCLGNBQXpCLHdJQUF3QztBQUFBLGtCQUEvQixZQUErQjs7QUFDdEM7QUFDQSxrQkFBSSx5QkFBeUIsbUJBQU8sV0FBUCxDQUFtQixHQUFuQixDQUF1QixFQUF2QixFQUEyQix3QkFBM0IsRUFBcUQsS0FBSyxzQkFBTCxDQUE0QixJQUE1QixDQUFpQyxJQUFqQyxFQUF1QyxJQUF2QyxDQUE0QyxJQUE1QyxFQUFrRCxFQUFsRCxFQUFzRCxNQUF0RCxDQUFyRCxDQUE3QjtBQUNBO0FBQ0EsMkJBQWEsbUJBQWIsQ0FBaUMsT0FBakMsRUFBMEMsc0JBQTFDO0FBQ0EsMkJBQWEsZ0JBQWIsQ0FBOEIsT0FBOUIsRUFBdUMsc0JBQXZDO0FBQ0Q7QUFQbUQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVFyRCxTQVJEO0FBU0Q7QUFDRjs7QUFFRDs7Ozs7OztvQ0FJZ0IsRSxFQUFJO0FBQ2xCLFVBQUksT0FBTyxJQUFYO0FBQ0EsVUFBSSxVQUFVLEtBQUssT0FBbkI7QUFDQTtBQUNBLFVBQUksUUFBUSxXQUFaLEVBQXlCO0FBQ3ZCLFlBQUksZ0JBQWdCLEdBQUcsZ0JBQUgsQ0FBb0IsUUFBUSxXQUE1QixDQUFwQjtBQUR1QjtBQUFBO0FBQUE7O0FBQUE7QUFFdkIsaUNBQXlCLGFBQXpCLHdJQUF3QztBQUFBLGdCQUEvQixZQUErQjs7QUFDdEM7QUFDQSxnQkFBSSx3QkFBd0IsbUJBQU8sV0FBUCxDQUFtQixHQUFuQixDQUF1QixFQUF2QixFQUEyQix1QkFBM0IsQ0FBNUI7QUFDQSx5QkFBYSxtQkFBYixDQUFpQyxPQUFqQyxFQUEwQyxxQkFBMUM7QUFDRDtBQU5zQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBT3hCO0FBQ0Q7QUFDQSxVQUFJLFFBQVEsWUFBWixFQUEwQjtBQUN4QixZQUFJLGtCQUFnQixTQUFTLGVBQVQsQ0FBeUIsZ0JBQXpCLENBQTBDLFFBQVEsWUFBbEQsQ0FBcEI7QUFEd0I7QUFBQTtBQUFBOztBQUFBO0FBRXhCLGlDQUF5QixlQUF6Qix3SUFBd0M7QUFBQSxnQkFBL0IsYUFBK0I7O0FBQ3RDLGdCQUFJLHlCQUF5QixtQkFBTyxXQUFQLENBQW1CLEdBQW5CLENBQXVCLEVBQXZCLEVBQTJCLHdCQUEzQixDQUE3QjtBQUNBLDBCQUFhLG1CQUFiLENBQWlDLE9BQWpDLEVBQTBDLHNCQUExQztBQUNEO0FBTHVCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNekI7QUFDRjs7QUFFRDs7Ozs7Ozs7OzBDQU1zQixPLEVBQVMsTSxFQUFRLEMsRUFBRztBQUN4QyxVQUFJLG1CQUFPLFdBQVAsQ0FBbUIsQ0FBbkIsRUFBc0IsbUJBQU8sU0FBUCxDQUFpQixPQUFqQixDQUF0QixDQUFKLEVBQXNEO0FBQ3BELGFBQUssUUFBTCxDQUFjLE1BQWQ7QUFDRDtBQUNGOztBQUVEOzs7Ozs7Ozs7MkNBTXVCLE8sRUFBUyxNLEVBQVEsQyxFQUFHO0FBQ3pDLFVBQUksbUJBQU8sWUFBUCxDQUFvQixDQUFwQixFQUF1QixtQkFBTyxTQUFQLENBQWlCLE9BQWpCLENBQXZCLENBQUosRUFBdUQ7QUFDckQsYUFBSyxRQUFMLENBQWMsTUFBZDtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozt5Q0FHcUI7QUFDbkIsVUFBSSxPQUFPLElBQVg7QUFDQSxVQUFJLFVBQVUsS0FBSyxPQUFuQjtBQUNBO0FBQ0EsVUFBSSxRQUFRLFNBQVosRUFBdUI7QUFDckIsWUFBSSxpQkFBSjtBQUNBLFlBQUksUUFBUSxtQkFBTyxjQUFQLEVBQVo7QUFDQTtBQUNBLG1CQUFXLFNBQVMsZUFBVCxDQUF5QixnQkFBekIsQ0FBMEMscUJBQTFDLENBQVg7QUFKcUI7QUFBQTtBQUFBOztBQUFBO0FBS3JCLGlDQUFvQixRQUFwQix3SUFBOEI7QUFBQSxnQkFBckIsT0FBcUI7O0FBQzVCLGdCQUFJLFFBQVEsaUJBQWlCLE9BQWpCLENBQVo7QUFDQSxnQkFBSSxNQUFNLFFBQU4sS0FBbUIsT0FBdkIsRUFBZ0M7QUFDOUIsc0JBQVEsU0FBUixDQUFrQixHQUFsQixDQUFzQixVQUF0QjtBQUNELGFBRkQsTUFFTztBQUNMLHNCQUFRLFNBQVIsQ0FBa0IsTUFBbEIsQ0FBeUIsVUFBekI7QUFDRDtBQUNGO0FBQ0Q7QUFicUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFjckIsbUJBQVcsU0FBUyxlQUFULENBQXlCLGdCQUF6QixDQUEwQyxXQUExQyxDQUFYO0FBZHFCO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUEsZ0JBZVosT0FmWTs7QUFnQm5CLG9CQUFRLEtBQVIsQ0FBYyxZQUFkLEdBQTZCLEVBQTdCO0FBQ0EsZ0JBQUksS0FBSyxjQUFMLENBQW9CLFFBQVEsV0FBNUIsTUFBNkMsRUFBakQsRUFBcUQ7QUFDbkQsa0JBQUksU0FBUSxpQkFBaUIsT0FBakIsQ0FBWjtBQUNBLGtCQUFJLFVBQVUsT0FBTSxZQUFwQjtBQUNBLGtCQUFJLE1BQU0sVUFBVSxPQUFWLEdBQW9CLEtBQXBCLEdBQTRCLEtBQTVCLEdBQW9DLEtBQTlDO0FBQ0Esc0JBQVEsU0FBUixDQUFrQixHQUFsQixDQUFzQixlQUF0QjtBQUNBLGlDQUFPLHFCQUFQLENBQTZCLElBQTdCLENBQWtDLE1BQWxDLEVBQTBDLFlBQVk7QUFDcEQsd0JBQVEsS0FBUixDQUFjLFlBQWQsR0FBNkIsR0FBN0I7QUFDQSxtQ0FBTyxxQkFBUCxDQUE2QixJQUE3QixDQUFrQyxNQUFsQyxFQUEwQyxZQUFZO0FBQ3BELDBCQUFRLFNBQVIsQ0FBa0IsTUFBbEIsQ0FBeUIsZUFBekI7QUFDRCxpQkFGRDtBQUdELGVBTEQ7QUFNRDtBQTVCa0I7O0FBZXJCLGlDQUFvQixRQUFwQix3SUFBOEI7QUFBQTtBQWM3QjtBQUNEO0FBOUJxQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQStCckIsbUJBQVcsU0FBUyxlQUFULENBQXlCLGdCQUF6QixDQUEwQyxjQUExQyxDQUFYO0FBL0JxQjtBQUFBO0FBQUE7O0FBQUE7QUFnQ3JCLGlDQUFvQixRQUFwQix3SUFBOEI7QUFBQSxnQkFBckIsUUFBcUI7O0FBQzVCLHFCQUFRLEtBQVIsQ0FBYyxLQUFkLEdBQXNCLFFBQVEsSUFBOUI7QUFDRDtBQUNEO0FBbkNxQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQW9DckIsWUFBSSxZQUFZLFNBQVMsZUFBekI7QUFDQSxrQkFBVSxLQUFWLENBQWdCLFlBQWhCLEdBQStCLFFBQVEsSUFBdkM7QUFDQSxrQkFBVSxTQUFWLENBQW9CLEdBQXBCLENBQXdCLGNBQXhCO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7OzBDQUdzQjtBQUNwQixVQUFJLE9BQU8sSUFBWDtBQUNBLFVBQUksVUFBVSxLQUFLLE9BQW5CO0FBQ0E7QUFDQSxVQUFJLFFBQVEsU0FBWixFQUF1QjtBQUNyQixZQUFJLGlCQUFKO0FBQ0E7QUFDQSxZQUFJLFlBQVksU0FBUyxlQUF6QjtBQUNBLGtCQUFVLEtBQVYsQ0FBZ0IsWUFBaEIsR0FBK0IsRUFBL0I7QUFDQSxrQkFBVSxTQUFWLENBQW9CLE1BQXBCLENBQTJCLGNBQTNCO0FBQ0E7QUFDQSxtQkFBVyxTQUFTLGVBQVQsQ0FBeUIsZ0JBQXpCLENBQTBDLFdBQTFDLENBQVg7QUFQcUI7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQSxnQkFRWixPQVJZOztBQVNuQixvQkFBUSxTQUFSLENBQWtCLEdBQWxCLENBQXNCLGVBQXRCO0FBQ0EsK0JBQU8scUJBQVAsQ0FBNkIsSUFBN0IsQ0FBa0MsTUFBbEMsRUFBMEMsWUFBWTtBQUNwRCxzQkFBUSxLQUFSLENBQWMsWUFBZCxHQUE2QixFQUE3QjtBQUNBLGlDQUFPLHFCQUFQLENBQTZCLElBQTdCLENBQWtDLE1BQWxDLEVBQTBDLFlBQVk7QUFDcEQsd0JBQVEsU0FBUixDQUFrQixNQUFsQixDQUF5QixlQUF6QjtBQUNELGVBRkQ7QUFHRCxhQUxEO0FBVm1COztBQVFyQixpQ0FBb0IsUUFBcEIsd0lBQThCO0FBQUE7QUFRN0I7QUFDRDtBQWpCcUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFrQnJCLG1CQUFXLFNBQVMsZUFBVCxDQUF5QixnQkFBekIsQ0FBMEMsY0FBMUMsQ0FBWDtBQWxCcUI7QUFBQTtBQUFBOztBQUFBO0FBbUJyQixpQ0FBb0IsUUFBcEIsd0lBQThCO0FBQUEsZ0JBQXJCLFNBQXFCOztBQUM1QixzQkFBUSxLQUFSLENBQWMsS0FBZCxHQUFzQixFQUF0QjtBQUNEO0FBckJvQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBc0J0QjtBQUNGOztBQUVEOzs7Ozs7OzttQ0FLZSxLLEVBQU87QUFDcEIsY0FBUSxXQUFXLEtBQVgsQ0FBUjtBQUNBLFVBQUksUUFBUSxtQkFBTyxjQUFQLEVBQVIsSUFBbUMsT0FBTyxVQUE5QyxFQUEwRDtBQUN4RCxnQkFBUSxFQUFSO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsaUJBQVMsSUFBVDtBQUNEO0FBQ0QsYUFBTyxLQUFQO0FBQ0Q7Ozs7OztBQUlIOztBQUVBLEdBQUcsUUFBSCxHQUFjO0FBQ1osVUFBUSxLQURJO0FBRVosZUFBYSxLQUZEO0FBR1osZ0JBQWM7QUFIRixDQUFkOztBQU1BOztBQUVBLE9BQU8sRUFBUCxHQUFZLEVBQVo7UUFDUSxFLEdBQUEsRTs7QUFFUjtBQUNBO0FBQ0E7O0lBRU0sUTs7O0FBRUo7Ozs7OztBQU1BLG9CQUFZLE1BQVosRUFBb0M7QUFBQSxRQUFoQixTQUFnQix1RUFBSixFQUFJOztBQUFBOztBQUFBLCtHQUM1QixNQUQ0QixFQUNwQixTQURvQixFQUNULGdCQURTO0FBRW5DOzs7RUFWb0IsRTs7QUFjdkI7O0FBRUEsU0FBUyxRQUFULEdBQW9CO0FBQ2xCLGNBQVksNkJBRE07QUFFbEIsYUFBVywrREFGTztBQUdsQixXQUFTLFFBSFM7QUFJbEIsYUFBVyxFQUFDLFlBQVksSUFBYixFQUpPO0FBS2xCLFFBQU0sT0FMWTtBQU1sQixZQUFVLElBTlE7QUFPbEIsU0FBTyxDQVBXO0FBUWxCLFNBQU87QUFSVyxDQUFwQjs7QUFXQTs7QUFFQSxPQUFPLFFBQVAsR0FBa0IsUUFBbEI7UUFDUSxRLEdBQUEsUTs7QUFFUjtBQUNBO0FBQ0E7O0lBRU0sTTs7O0FBRUo7Ozs7OztBQU1BLGtCQUFZLE1BQVosRUFBb0M7QUFBQSxRQUFoQixTQUFnQix1RUFBSixFQUFJOztBQUFBOztBQUFBLDJHQUM1QixNQUQ0QixFQUNwQixTQURvQixFQUNULGNBRFM7QUFFbkM7O0FBRUQ7Ozs7Ozs7K0JBR1c7QUFDVCxVQUFJLEtBQUssT0FBVCxFQUFrQjtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUNoQixpQ0FBZSxLQUFLLE9BQXBCLHdJQUE2QjtBQUFBLGdCQUFwQixFQUFvQjs7QUFDM0I7QUFDQSxnQkFBSSxLQUFLLE9BQUwsQ0FBYSxVQUFqQixFQUE2QjtBQUMzQixrQkFBSSxRQUFRLEtBQUssYUFBTCxFQUFaO0FBQ0Esa0JBQUksTUFBTSxNQUFWLEVBQWtCO0FBQ2hCLHdCQUFRLE1BQU0sQ0FBTixFQUFTLFNBQVQsQ0FBbUIsT0FBbkIsQ0FBMkIsTUFBM0IsRUFBbUMsR0FBbkMsRUFBd0MsSUFBeEMsRUFBUjtBQUNBLG1CQUFHLFlBQUgsQ0FBZ0IsWUFBaEIsRUFBOEIsS0FBOUI7QUFDRDtBQUNGO0FBQ0Y7QUFWZTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBV2pCO0FBQ0Y7Ozs7RUE1QmtCLEU7O0FBZ0NyQjs7QUFFQSxPQUFPLFFBQVAsR0FBa0I7QUFDaEIsY0FBWSxRQURJO0FBRWhCLGFBQVcsZ0JBRks7QUFHaEIsZ0JBQWMsNkJBSEU7QUFJaEIsV0FBUyxRQUpPO0FBS2hCLGFBQVcsRUFBQyxZQUFZLElBQWIsRUFMSztBQU1oQixRQUFNLE9BTlU7QUFPaEIsWUFBVSxJQVBNO0FBUWhCLFNBQU8sQ0FSUztBQVNoQixTQUFPLENBVFM7QUFVaEIsa0JBQWdCO0FBVkEsQ0FBbEI7O0FBYUE7O0FBRUEsT0FBTyxNQUFQLEdBQWdCLE1BQWhCO1FBQ1EsTSxHQUFBLE07O0FBRVI7QUFDQTtBQUNBOztJQUVNLFM7OztBQUVKOzs7Ozs7QUFNQSxxQkFBWSxNQUFaLEVBQW9DO0FBQUEsUUFBaEIsU0FBZ0IsdUVBQUosRUFBSTs7QUFBQTs7QUFBQSxpSEFDNUIsTUFENEIsRUFDcEIsU0FEb0IsRUFDVCxpQkFEUztBQUVuQzs7QUFFRDs7Ozs7OzsrQkFHVztBQUNUO0FBQ0EsVUFBSSxLQUFLLE9BQVQsRUFBa0I7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDaEIsaUNBQWUsS0FBSyxPQUFwQix3SUFBNkI7QUFBQSxnQkFBcEIsRUFBb0I7O0FBQzNCO0FBQ0EsZUFBRyxZQUFILENBQWdCLE1BQWhCLEVBQXdCLFFBQXhCO0FBQ0EsZUFBRyxZQUFILENBQWdCLFlBQWhCLEVBQThCLE1BQTlCO0FBQ0Q7QUFMZTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTWpCO0FBQ0Y7Ozs7RUF4QnFCLEU7O0FBNEJ4Qjs7QUFFQSxVQUFVLFFBQVYsR0FBcUI7QUFDbkIsY0FBWSw2QkFETztBQUVuQixhQUFXLHlCQUZRO0FBR25CLFdBQVMsUUFIVTtBQUluQixhQUFXLEVBQUMsWUFBWSxJQUFiLEVBSlE7QUFLbkIsUUFBTSxPQUxhO0FBTW5CLFlBQVUsSUFOUztBQU9uQixTQUFPLENBUFk7QUFRbkIsU0FBTyxDQVJZO0FBU25CLGNBQVksTUFUTztBQVVuQixjQUFZLFNBVk87QUFXbkIsZUFBYSxZQVhNO0FBWW5CLGlCQUFlLDZFQVpJO0FBYW5CLGVBQWE7QUFiTSxDQUFyQjs7QUFnQkE7O0FBRUEsT0FBTyxTQUFQLEdBQW1CLFNBQW5CO1FBQ1EsUyxHQUFBLFM7O0FBRVI7QUFDQTtBQUNBOztJQUVNLFE7OztBQUVKOzs7Ozs7QUFNQSxvQkFBWSxNQUFaLEVBQW9DO0FBQUEsUUFBaEIsU0FBZ0IsdUVBQUosRUFBSTs7QUFBQTs7QUFBQSwrR0FDNUIsTUFENEIsRUFDcEIsU0FEb0IsRUFDVCxnQkFEUztBQUVuQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Z0NBR1k7QUFDVjtBQUNBO0FBQ0EsV0FBSyxJQUFMLEdBQVksS0FBWjtBQUNBO0FBQ0EsV0FBSyxTQUFMLEdBQWlCLG1CQUFPLE9BQVAsQ0FBZSxLQUFLLE1BQXBCLEVBQTRCLGVBQTVCLENBQWpCO0FBQ0EsVUFBSSxDQUFDLEtBQUssU0FBTCxDQUFlLE1BQXBCLEVBQTRCO0FBQzFCLGFBQUssU0FBTCxHQUFpQixtQkFBTyxhQUFQLENBQXFCLGlEQUFyQixDQUFqQjtBQUNBLGFBQUssTUFBTCxDQUFZLE1BQVosQ0FBbUIsS0FBSyxTQUF4QjtBQUNBLGFBQUssU0FBTCxDQUFlLE1BQWYsQ0FBc0IsS0FBSyxNQUEzQjtBQUNBLGFBQUssU0FBTCxHQUFpQixtQkFBTyxPQUFQLENBQWUsS0FBSyxNQUFwQixFQUE0QixlQUE1QixDQUFqQjtBQUNEO0FBQ0Q7QUFDQSxXQUFLLE9BQUwsR0FBZSxLQUFLLFNBQUwsQ0FBZSxDQUFmLEVBQWtCLGdCQUFsQixDQUFtQyxXQUFuQyxDQUFmO0FBQ0EsVUFBSSxDQUFDLEtBQUssT0FBTCxDQUFhLE1BQWxCLEVBQTBCO0FBQ3hCLGFBQUssT0FBTCxHQUFlLEtBQUssTUFBTCxDQUFZLFNBQVosQ0FBc0IsSUFBdEIsQ0FBZjtBQUNBLGFBQUssT0FBTCxDQUFhLFNBQWIsQ0FBdUIsR0FBdkIsQ0FBMkIsVUFBM0I7QUFDQSxhQUFLLE9BQUwsQ0FBYSxZQUFiLENBQTBCLGFBQTFCLEVBQXlDLE1BQXpDO0FBSHdCO0FBQUE7QUFBQTs7QUFBQTtBQUl4QixpQ0FBaUIsS0FBSyxPQUFMLENBQWEsZ0JBQWIsQ0FBOEIsTUFBOUIsQ0FBakIsd0lBQXdEO0FBQUEsZ0JBQS9DLElBQStDOztBQUN0RCxpQkFBSyxZQUFMLENBQWtCLElBQWxCLEVBQXdCLEtBQUssWUFBTCxDQUFrQixJQUFsQixJQUEwQixRQUFsRDtBQUNEO0FBTnVCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBT3hCLGlDQUFtQixLQUFLLE9BQUwsQ0FBYSxnQkFBYixDQUE4QixRQUE5QixDQUFuQix3SUFBNEQ7QUFBQSxnQkFBbkQsTUFBbUQ7O0FBQzFELG1CQUFPLFlBQVAsQ0FBb0IsTUFBcEIsRUFBNEIsT0FBTyxZQUFQLENBQW9CLE1BQXBCLElBQThCLFFBQTFEO0FBQ0Q7QUFUdUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFVeEIsYUFBSyxTQUFMLENBQWUsQ0FBZixFQUFrQixNQUFsQixDQUF5QixLQUFLLE9BQTlCO0FBQ0Q7QUFDRCxXQUFLLE9BQUwsR0FBZSxtQkFBTyxTQUFQLENBQWlCLEtBQUssT0FBdEIsQ0FBZjtBQUNBO0FBQ0EsV0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixHQUF0QixDQUEwQixVQUExQjtBQUNBO0FBQ0EsVUFBSSxLQUFLLE9BQUwsQ0FBYSxJQUFiLEtBQXNCLE1BQTFCLEVBQWtDO0FBQ2hDLGFBQUssTUFBTCxDQUFZLFNBQVosQ0FBc0IsR0FBdEIsQ0FBMEIsa0JBQTFCO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsYUFBSyxNQUFMLENBQVksU0FBWixDQUFzQixNQUF0QixDQUE2QixrQkFBN0I7QUFDRDtBQUNELFVBQUksS0FBSyxPQUFMLENBQWEsSUFBYixLQUFzQixJQUExQixFQUFnQztBQUM5QixhQUFLLE1BQUwsQ0FBWSxTQUFaLENBQXNCLEdBQXRCLENBQTBCLGdCQUExQjtBQUNELE9BRkQsTUFFTztBQUNMLGFBQUssTUFBTCxDQUFZLFNBQVosQ0FBc0IsTUFBdEIsQ0FBNkIsZ0JBQTdCO0FBQ0Q7QUFDRDtBQUNBLFdBQUssTUFBTCxHQUFjLG1CQUFPLFlBQVAsRUFBZDtBQUNBLFdBQUssTUFBTCxDQUFZLEtBQVosQ0FBa0IsTUFBbEIsR0FBMkIsTUFBTSxNQUFNLEtBQUssTUFBakIsQ0FBM0I7QUFDRDs7QUFFRDs7Ozs7O2lDQUdhO0FBQ1gsVUFBSSxPQUFPLElBQVg7QUFDQSxVQUFJLFVBQVUsS0FBSyxPQUFuQjtBQUNBO0FBQ0EsVUFBSSxRQUFRLEVBQVosRUFBZ0I7QUFDZDtBQUNBLFlBQUksZ0JBQWdCLG1CQUFPLFdBQVAsQ0FBbUIsR0FBbkIsQ0FBdUIsTUFBdkIsRUFBK0IsZUFBL0IsRUFBZ0QsS0FBSyxjQUFMLENBQW9CLElBQXBCLENBQXlCLElBQXpCLENBQWhELENBQXBCO0FBQ0E7QUFDQSxZQUFJLHNDQUFhLFFBQVEsRUFBUixDQUFXLEtBQVgsQ0FBaUIsR0FBakIsQ0FBYixFQUFKO0FBSmM7QUFBQTtBQUFBOztBQUFBO0FBS2QsaUNBQWtCLE1BQWxCLHdJQUEwQjtBQUFBLGdCQUFqQixLQUFpQjs7QUFDeEIsbUJBQU8sbUJBQVAsQ0FBMkIsS0FBM0IsRUFBa0MsYUFBbEM7QUFDQSxtQkFBTyxnQkFBUCxDQUF3QixLQUF4QixFQUErQixhQUEvQjtBQUNEO0FBUmE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFTZCxlQUFPLGdCQUFQLENBQXdCLFdBQXhCLEVBQXFDLGFBQXJDO0FBQ0Q7QUFDRDtBQUNBLGFBQU8sYUFBUCxDQUFxQixJQUFJLFdBQUosQ0FBZ0IsV0FBaEIsQ0FBckI7QUFDRDs7QUFFRDs7Ozs7Ozs7bUNBS2UsTyxFQUFTLEMsRUFBRztBQUN6QixXQUFLLFdBQUwsQ0FBaUIsS0FBSyxNQUF0QjtBQUNEOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztnQ0FJWSxPLEVBQVM7QUFDbkIsVUFBSSxPQUFPLElBQVg7QUFDQSxVQUFJLFVBQVUsS0FBSyxPQUFuQjtBQUNBO0FBQ0EsVUFBSSxPQUFPLElBQVg7QUFDQSxVQUFJLE9BQU8sS0FBWDtBQUNBLFVBQUksZ0JBQWdCLEtBQXBCO0FBQ0EsVUFBSSxNQUFNLENBQVY7QUFDQSxVQUFJLFVBQVUsQ0FBZDtBQUNBLFVBQUksZUFBZSxPQUFPLFdBQTFCO0FBQ0EsVUFBSSxLQUFLLEtBQUssTUFBZDtBQUNBLFVBQUksWUFBWSxHQUFHLHFCQUFILEdBQTJCLEdBQTNDO0FBQ0EsVUFBSSxXQUFXLFdBQVcsaUJBQWlCLEVBQWpCLEVBQXFCLE1BQWhDLENBQWY7QUFDQSxVQUFJLGVBQWUsV0FBVyxpQkFBaUIsS0FBSyxPQUFMLENBQWEsQ0FBYixDQUFqQixFQUFrQyxNQUE3QyxDQUFuQjtBQUNBLFVBQUksbUJBQW1CLEtBQUssU0FBTCxDQUFlLENBQWYsRUFBa0IscUJBQWxCLEdBQTBDLEdBQWpFO0FBQ0EsVUFBSSxtQkFBbUIsU0FBUyxnQkFBaEM7QUFDQSxVQUFJLGVBQWUsaUJBQWlCLFlBQXBDO0FBQ0EsVUFBSSxZQUFZLGlCQUFpQixTQUFqQztBQUNBLFVBQUksZUFBZSxLQUFLLFlBQXhCO0FBQ0E7QUFDQSxVQUFJLFlBQVksWUFBaEIsRUFBOEI7QUFDNUIsV0FBRyxTQUFILENBQWEsTUFBYixDQUFvQixhQUFwQjtBQUNBLFdBQUcsU0FBSCxDQUFhLEdBQWIsQ0FBaUIsV0FBakI7QUFDQSx3QkFBZ0IsSUFBaEI7QUFDRCxPQUpELE1BSU87QUFDTCxXQUFHLFNBQUgsQ0FBYSxHQUFiLENBQWlCLGFBQWpCO0FBQ0EsV0FBRyxTQUFILENBQWEsTUFBYixDQUFvQixXQUFwQjtBQUNEO0FBQ0Q7QUFDQSxVQUFJLFFBQVEsSUFBUixLQUFpQixNQUFyQixFQUE2QjtBQUMzQixZQUFJLENBQUMsYUFBTCxFQUFvQjtBQUNsQixvQkFBVSxZQUFWO0FBQ0Q7QUFDRjtBQUNELFVBQUksUUFBUSxJQUFSLEtBQWlCLElBQXJCLEVBQTJCO0FBQ3pCLFlBQUksYUFBSixFQUFtQjtBQUNqQixvQkFBVSxZQUFWO0FBQ0Q7QUFDRjtBQUNEO0FBQ0EsVUFBSSxNQUFNLEtBQUssY0FBTCxDQUFvQixRQUFRLEtBQVIsQ0FBYyxLQUFkLEtBQXdCLEtBQUssT0FBakQsRUFBMEQsU0FBMUQsRUFBcUUsZ0JBQXJFLENBQVY7QUFDQSxVQUFJLFNBQVMsS0FBSyxjQUFMLENBQW9CLFFBQVEsS0FBUixDQUFjLFFBQWQsQ0FBcEIsRUFBNkMsU0FBN0MsRUFBd0QsUUFBeEQsQ0FBYjtBQUNBLFVBQUksUUFBUSxRQUFSLEtBQXFCLEtBQXpCLEVBQWdDO0FBQzlCLGtCQUFVLFlBQVY7QUFDRDtBQUNELFVBQUksUUFBUSxRQUFSLEtBQXFCLFFBQXpCLEVBQW1DO0FBQ2pDLGVBQU8sZUFBZSxZQUF0QjtBQUNBLGlCQUFTLEtBQUssR0FBTCxDQUFTLGVBQWUsWUFBZixHQUE4QixNQUF2QyxDQUFUO0FBQ0Q7QUFDRDtBQUNBLFVBQUksU0FBUyxDQUFiO0FBQ0EsVUFBSSxZQUFZLENBQWhCO0FBQ0EsVUFBSSxRQUFRLE9BQVosRUFBcUI7QUFDbkIsWUFBSSxRQUFRLE9BQVIsQ0FBZ0IsS0FBaEIsQ0FBSixFQUE0QjtBQUMxQixjQUFJLFlBQVksS0FBSyxpQkFBTCxDQUF1QixRQUFRLE9BQVIsQ0FBZ0IsS0FBaEIsQ0FBdkIsRUFBK0MsYUFBL0MsQ0FBaEI7QUFDQSxtQkFBUyxVQUFVLEdBQW5CO0FBQ0EsY0FBSSxXQUFXLElBQVgsSUFBbUIsU0FBUyxnQkFBaEMsRUFBa0Q7QUFDaEQsa0JBQU0sTUFBTjtBQUNBLGdCQUFJLENBQUMsVUFBVSxTQUFmLEVBQTBCO0FBQ3hCLHFCQUFPLEtBQVA7QUFDRDtBQUNGLFdBTEQsTUFLTztBQUNMLHFCQUFTLElBQVQ7QUFDRDtBQUNGO0FBQ0QsWUFBSSxRQUFRLE9BQVIsQ0FBZ0IsUUFBaEIsQ0FBSixFQUErQjtBQUM3QixzQkFBWSxLQUFLLGNBQUwsQ0FBb0IsUUFBUSxPQUFSLENBQWdCLFFBQWhCLENBQXBCLENBQVo7QUFDQSxjQUFJLGNBQWMsSUFBZCxJQUFzQixZQUFZLFdBQVcsTUFBakQsRUFBeUQ7QUFDdkQsa0JBQU0sWUFBWSxRQUFsQjtBQUNBLG1CQUFPLEtBQVA7QUFDRCxXQUhELE1BR087QUFDTCx3QkFBWSxJQUFaO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Q7QUFDQSxTQUFHLE9BQUgsQ0FBVyxXQUFYLEdBQXlCLElBQUksUUFBSixFQUF6QjtBQUNBO0FBQ0EsVUFBSSxXQUFXLGFBQWEsTUFBTSxHQUFOLEdBQVksT0FBeEM7QUFDQSxVQUFJLGNBQWMsWUFBWSxTQUFTLEdBQVQsR0FBZSxPQUE3QztBQUNBLFVBQUksWUFBWSxXQUFoQixFQUE2QjtBQUMzQjtBQUNBLGFBQUssT0FBTCxDQUFhLE9BQWI7QUFDQTtBQUNBLFlBQUksT0FBSixFQUFhO0FBQ1gsaUJBQU8sSUFBUDtBQUNEO0FBQ0YsT0FQRCxNQU9PO0FBQ0w7QUFDQSxhQUFLLFFBQUwsQ0FBYyxPQUFkO0FBQ0Q7QUFDRDtBQUNBLFVBQUksR0FBRyxTQUFILENBQWEsUUFBYixDQUFzQixRQUF0QixDQUFKLEVBQXFDO0FBQ25DO0FBQ0EsWUFBSSxJQUFKLEVBQVU7QUFDUixnQkFBTSxDQUFDLFFBQVA7QUFDQSxjQUFJLENBQUMsR0FBRyxTQUFILENBQWEsUUFBYixDQUFzQixhQUF0QixDQUFMLEVBQTJDO0FBQ3pDLGVBQUcsU0FBSCxDQUFhLEdBQWIsQ0FBaUIsYUFBakI7QUFDQSxlQUFHLGFBQUgsQ0FBaUIsSUFBSSxXQUFKLENBQWdCLGFBQWhCLENBQWpCO0FBQ0Q7QUFDRixTQU5ELE1BTU87QUFDTCxjQUFJLEdBQUcsU0FBSCxDQUFhLFFBQWIsQ0FBc0IsYUFBdEIsQ0FBSixFQUEwQztBQUN4QyxlQUFHLFNBQUgsQ0FBYSxNQUFiLENBQW9CLGFBQXBCO0FBQ0EsZUFBRyxhQUFILENBQWlCLElBQUksV0FBSixDQUFnQixhQUFoQixDQUFqQjtBQUNEO0FBQ0Y7QUFDRixPQWRELE1BY087QUFDTDtBQUNBLGNBQU0sQ0FBTjtBQUNBLGVBQU8sS0FBUDtBQUNEO0FBQ0Q7QUFDQSxVQUFJLFFBQVEsaUJBQWlCLFNBQTdCLEVBQXdDO0FBQ3RDLFlBQUksQ0FBQyxHQUFHLFNBQUgsQ0FBYSxRQUFiLENBQXNCLGFBQXRCLENBQUwsRUFBMkM7QUFDekMsYUFBRyxTQUFILENBQWEsR0FBYixDQUFpQixhQUFqQjtBQUNEO0FBQ0YsT0FKRCxNQUlPO0FBQ0wsWUFBSSxHQUFHLFNBQUgsQ0FBYSxRQUFiLENBQXNCLGFBQXRCLENBQUosRUFBMEM7QUFDeEMsYUFBRyxTQUFILENBQWEsTUFBYixDQUFvQixhQUFwQjtBQUNEO0FBQ0Y7QUFDRDtBQUNBLFVBQUksQ0FBQyxRQUFMLEVBQWU7QUFDYixZQUFJLENBQUMsR0FBRyxTQUFILENBQWEsUUFBYixDQUFzQixZQUF0QixDQUFMLEVBQTBDO0FBQ3hDLGFBQUcsU0FBSCxDQUFhLEdBQWIsQ0FBaUIsWUFBakI7QUFDRDtBQUNGLE9BSkQsTUFJTztBQUNMLFlBQUksR0FBRyxTQUFILENBQWEsUUFBYixDQUFzQixZQUF0QixDQUFKLEVBQXlDO0FBQ3ZDLGFBQUcsU0FBSCxDQUFhLE1BQWIsQ0FBb0IsWUFBcEI7QUFDRDtBQUNGO0FBQ0QsVUFBSSxDQUFDLFdBQUwsRUFBa0I7QUFDaEIsWUFBSSxDQUFDLEdBQUcsU0FBSCxDQUFhLFFBQWIsQ0FBc0IsZUFBdEIsQ0FBTCxFQUE2QztBQUMzQyxhQUFHLFNBQUgsQ0FBYSxHQUFiLENBQWlCLGVBQWpCO0FBQ0Q7QUFDRixPQUpELE1BSU87QUFDTCxZQUFJLEdBQUcsU0FBSCxDQUFhLFFBQWIsQ0FBc0IsZUFBdEIsQ0FBSixFQUE0QztBQUMxQyxhQUFHLFNBQUgsQ0FBYSxNQUFiLENBQW9CLGVBQXBCO0FBQ0Q7QUFDRjtBQUNEO0FBQ0EsVUFBSSxRQUFRLEtBQUssTUFBakIsRUFBeUI7QUFDdkIsV0FBRyxTQUFILENBQWEsR0FBYixDQUFpQixlQUFqQjtBQUNBLFlBQUksS0FBSyxNQUFMLEtBQWdCLFNBQXBCLEVBQStCO0FBQzdCLGFBQUcsS0FBSCxDQUFTLFFBQVEsUUFBakIsSUFBNkIsWUFBWSxJQUF6QztBQUNEO0FBQ0QsMkJBQU8sb0JBQVAsQ0FBNEIsSUFBNUIsQ0FBaUMsTUFBakMsRUFBeUMsS0FBSyxVQUE5QztBQUNBLGFBQUssVUFBTCxHQUFrQixtQkFBTyxxQkFBUCxDQUE2QixJQUE3QixDQUFrQyxNQUFsQyxFQUEwQyxZQUFZO0FBQ3RFLGFBQUcsU0FBSCxDQUFhLE1BQWIsQ0FBb0IsZUFBcEI7QUFDQSxhQUFHLEtBQUgsQ0FBUyxRQUFRLFFBQWpCLElBQTZCLE1BQU0sSUFBbkM7QUFDRCxTQUhpQixDQUFsQjtBQUlEO0FBQ0Q7QUFDQSxVQUFJLFFBQVEsS0FBSyxjQUFMLENBQW9CLEtBQUssU0FBTCxDQUFlLENBQWYsRUFBa0IsV0FBdEMsQ0FBWjtBQUNBLFVBQUksR0FBRyxLQUFILENBQVMsS0FBVCxLQUFtQixLQUF2QixFQUE4QjtBQUM1QixXQUFHLEtBQUgsQ0FBUyxLQUFULEdBQWlCLEtBQWpCO0FBQ0Q7QUFDRDtBQUNBLFdBQUssTUFBTCxHQUFjLEdBQWQ7QUFDQSxXQUFLLFlBQUwsR0FBb0IsU0FBcEI7QUFDRDs7QUFFRDs7Ozs7Ozs7OzttQ0FPZSxNLEVBQW1DO0FBQUEsVUFBM0IsU0FBMkIsdUVBQWYsQ0FBZTtBQUFBLFVBQVosR0FBWSx1RUFBTixJQUFNOztBQUNoRCxVQUFJLENBQUMsTUFBTSxXQUFXLE1BQVgsQ0FBTixDQUFMLEVBQWdDO0FBQzlCLGNBQU0sTUFBTjtBQUNELE9BRkQsTUFFTztBQUNMLFlBQUksV0FBVyxNQUFNLE9BQU4sQ0FBYyxNQUFkLElBQXdCLE1BQXhCLEdBQWlDLFNBQVMsZUFBVCxDQUF5QixnQkFBekIsQ0FBMEMsTUFBMUMsQ0FBaEQ7QUFDQSxZQUFJLFNBQVMsTUFBYixFQUFxQjtBQUNuQixjQUFJLFFBQVEsS0FBWjtBQUNBLGdCQUFNLENBQU47QUFGbUI7QUFBQTtBQUFBOztBQUFBO0FBR25CLG1DQUFlLFFBQWYsd0lBQXlCO0FBQUEsa0JBQWhCLEVBQWdCOztBQUN2QixrQkFBSSxZQUFZLFdBQVcsR0FBRyxPQUFILENBQVcsV0FBdEIsQ0FBaEI7QUFDQSxrQkFBSSxTQUFKLEVBQWU7QUFBRTtBQUNmLG9CQUFJLFFBQVEsaUJBQWlCLEVBQWpCLENBQVo7QUFDQSxvQkFBSSxNQUFNLE9BQU4sS0FBa0IsTUFBdEIsRUFBOEI7QUFDNUIseUJBQU8sU0FBUDtBQUNBLDBCQUFRLElBQVI7QUFDRDtBQUNGLGVBTkQsTUFNTztBQUNMLG9CQUFJLE9BQU8sR0FBRyxxQkFBSCxFQUFYO0FBQ0EsdUJBQU8sS0FBSyxHQUFaO0FBQ0Esd0JBQVEsSUFBUjtBQUNEO0FBQ0Y7QUFoQmtCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBaUJuQixjQUFJLEtBQUosRUFBVztBQUNULG1CQUFPLFNBQVA7QUFDRCxXQUZELE1BRU87QUFDTCxrQkFBTSxJQUFOO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsYUFBTyxHQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7c0NBT2tCLE0sRUFBUSxhLEVBQTJCO0FBQUEsVUFBWixHQUFZLHVFQUFOLElBQU07O0FBQ25ELFVBQUksWUFBWSxLQUFoQjtBQUNBLFVBQUksQ0FBQyxNQUFNLFdBQVcsTUFBWCxDQUFOLENBQUwsRUFBZ0M7QUFDOUIsY0FBTSxNQUFOO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsWUFBSSxXQUFXLE1BQU0sT0FBTixDQUFjLE1BQWQsSUFBd0IsTUFBeEIsR0FBaUMsU0FBUyxlQUFULENBQXlCLGdCQUF6QixDQUEwQyxNQUExQyxDQUFoRDtBQUNBLFlBQUksU0FBUyxNQUFiLEVBQXFCO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ25CLG1DQUFlLFFBQWYsd0lBQXlCO0FBQUEsa0JBQWhCLEVBQWdCOztBQUN2QixrQkFBSSxHQUFHLFNBQUgsQ0FBYSxRQUFiLENBQXNCLGtCQUF0QixLQUE2QyxHQUFHLFNBQUgsQ0FBYSxRQUFiLENBQXNCLFFBQXRCLENBQWpELEVBQWtGO0FBQ2hGLG9CQUFJLGFBQUosRUFBbUI7QUFDakIseUJBQU8sR0FBRyxZQUFWO0FBQ0EsOEJBQVksSUFBWjtBQUNEO0FBQ0YsZUFMRCxNQUtPLElBQUksR0FBRyxTQUFILENBQWEsUUFBYixDQUFzQixnQkFBdEIsS0FBMkMsR0FBRyxTQUFILENBQWEsUUFBYixDQUFzQixRQUF0QixDQUEvQyxFQUFnRjtBQUNyRixvQkFBSSxDQUFDLGFBQUwsRUFBb0I7QUFDbEIseUJBQU8sR0FBRyxZQUFWO0FBQ0EsOEJBQVksSUFBWjtBQUNEO0FBQ0YsZUFMTSxNQUtBO0FBQ0wsdUJBQU8sR0FBRyxZQUFWO0FBQ0Q7QUFDRjtBQWZrQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBZ0JwQjtBQUNGO0FBQ0QsYUFBTyxFQUFDLEtBQUssR0FBTixFQUFXLFdBQVcsU0FBdEIsRUFBUDtBQUNEOzs7O0VBaFZvQixFOztBQW9WdkI7O0FBRUEsU0FBUyxRQUFULEdBQW9CO0FBQ2xCLFdBQVMsUUFEUztBQUVsQixRQUFNLGVBRlk7QUFHbEIsU0FBTyxDQUhXO0FBSWxCLFNBQU8sUUFKVztBQUtsQixjQUFZLEtBTE07QUFNbEIsV0FBUyxFQUFDLFVBQVUsUUFBWCxFQU5TO0FBT2xCLGFBQVcsS0FQTztBQVFsQixVQUFRO0FBUlUsQ0FBcEI7O0FBV0E7O0FBRUEsT0FBTyxRQUFQLEdBQWtCLFFBQWxCO1FBQ1EsUSxHQUFBLFE7O0FBRVI7QUFDQTtBQUNBOztJQUVNLE07OztBQUVKOzs7Ozs7QUFNQSxrQkFBWSxNQUFaLEVBQW9DO0FBQUEsUUFBaEIsU0FBZ0IsdUVBQUosRUFBSTs7QUFBQTs7QUFBQSwyR0FDNUIsTUFENEIsRUFDcEIsU0FEb0IsRUFDVCxjQURTO0FBRW5DOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztpQ0FHYTtBQUNYLFVBQUksT0FBTyxJQUFYO0FBQ0EsVUFBSSxVQUFVLEtBQUssT0FBbkI7QUFDQTtBQUNBLFVBQUksUUFBUSxFQUFaLEVBQWdCO0FBQ2Q7QUFDQSxZQUFJLGNBQWMsbUJBQU8sV0FBUCxDQUFtQixHQUFuQixDQUF1QixNQUF2QixFQUErQixhQUEvQixFQUE4QyxLQUFLLGNBQUwsQ0FBb0IsSUFBcEIsQ0FBeUIsSUFBekIsQ0FBOUMsQ0FBbEI7QUFDQTtBQUNBLFlBQUksc0NBQWEsUUFBUSxFQUFSLENBQVcsS0FBWCxDQUFpQixHQUFqQixDQUFiLEVBQUo7QUFKYztBQUFBO0FBQUE7O0FBQUE7QUFLZCxpQ0FBa0IsTUFBbEIsd0lBQTBCO0FBQUEsZ0JBQWpCLEtBQWlCOztBQUN4QixtQkFBTyxtQkFBUCxDQUEyQixLQUEzQixFQUFrQyxXQUFsQztBQUNBLG1CQUFPLGdCQUFQLENBQXdCLEtBQXhCLEVBQStCLFdBQS9CO0FBQ0Q7QUFSYTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQVNkLGVBQU8sZ0JBQVAsQ0FBd0IsU0FBeEIsRUFBbUMsV0FBbkM7QUFDRDtBQUNEO0FBQ0EsYUFBTyxhQUFQLENBQXFCLElBQUksV0FBSixDQUFnQixTQUFoQixDQUFyQjtBQUNEOztBQUVEOzs7Ozs7OzttQ0FLZSxPLEVBQVMsQyxFQUFHO0FBQ3pCLFdBQUssV0FBTCxDQUFpQixLQUFLLE1BQXRCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOzs7Ozs7a0NBR2M7QUFDWixVQUFJLE9BQU8sSUFBWDtBQUNBLFVBQUksVUFBVSxLQUFLLE9BQW5CO0FBQ0E7QUFDQSxVQUFJLFVBQVUsQ0FBZDtBQUNBLFVBQUksV0FBVyxFQUFmO0FBQ0EsVUFBSSxnQkFBZ0IsS0FBcEI7QUFDQSxVQUFJLGVBQWUsT0FBTyxXQUExQjtBQUNBLFVBQUksbUJBQW1CLFNBQVMsZ0JBQWhDO0FBQ0EsVUFBSSxZQUFZLGlCQUFpQixTQUFqQztBQUNBLFVBQUksZUFBZSxLQUFLLFlBQXhCO0FBQ0E7QUFDQSxVQUFJLFlBQVksWUFBaEIsRUFBOEI7QUFDNUIsd0JBQWdCLElBQWhCO0FBQ0Q7QUFDRDtBQWZZO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUEsY0FnQkgsRUFoQkc7O0FBaUJWLGNBQUksR0FBRyxZQUFILElBQW1CLENBQUMsR0FBRyxTQUFILENBQWEsUUFBYixDQUFzQixZQUF0QixDQUF4QixFQUE2RDtBQUMzRDtBQUNBLGdCQUFJLFlBQVksR0FBRyxZQUFILENBQWdCLHFCQUFoQixHQUF3QyxHQUF4QyxHQUE4QyxHQUFHLFNBQWpFLENBRjJELENBRWlCO0FBQzVFLGdCQUFJLFdBQVcsV0FBVyxpQkFBaUIsRUFBakIsRUFBcUIsTUFBaEMsQ0FBZjtBQUNBO0FBQ0EsZ0JBQUksVUFBVSxLQUFkO0FBQ0EsZ0JBQUksTUFBTSxZQUFZLFNBQXRCO0FBQ0EsZ0JBQUksU0FBUyxNQUFNLFFBQW5CO0FBQ0EsZ0JBQUksT0FBTyxlQUFlLFFBQVEsUUFBbEM7QUFDQTtBQUNBLGdCQUFJLFdBQVcsWUFBWSxZQUFaLElBQTRCLE1BQU0sSUFBakQ7QUFDQSxnQkFBSSxjQUFjLFlBQVksU0FBUyxJQUF2QztBQUNBLGdCQUFJLFlBQVksV0FBaEIsRUFBNkI7QUFDM0I7QUFDQSx3QkFBVSxLQUFLLE9BQUwsQ0FBYSxFQUFiLENBQVY7QUFDQSxrQkFBSSxPQUFKLEVBQWE7QUFDWCx5QkFBUyxJQUFULENBQWMsRUFBZDtBQUNBLG1DQUFPLG9CQUFQLENBQTRCLElBQTVCLENBQWlDLE1BQWpDLEVBQXlDLEdBQUcsT0FBSCxDQUFXLFVBQXBEO0FBQ0EsbUJBQUcsT0FBSCxDQUFXLFVBQVgsR0FBd0IsbUJBQU8scUJBQVAsQ0FBNkIsSUFBN0IsQ0FBa0MsTUFBbEMsRUFBMEMsWUFBWTtBQUM1RSxzQkFBSSxRQUFRLE9BQVosRUFBcUI7QUFDbkIsd0JBQUksT0FBTyxJQUFJLFFBQUosQ0FBYSxTQUFiLEVBQXdCLE9BQXhCLEVBQWlDLFFBQVEsT0FBekMsQ0FBWDtBQUNBLHVCQUFHLE9BQUgsQ0FBVyxTQUFYLEdBQXVCLEtBQUssT0FBTCxFQUFjLFNBQVMsTUFBdkIsRUFBK0IsUUFBL0IsRUFBdkI7QUFDQTtBQUNEO0FBQ0QsdUJBQUssT0FBTCxDQUFhLEVBQWI7QUFDRCxpQkFQdUIsQ0FBeEI7QUFRRDtBQUNGLGFBZkQsTUFlTztBQUNMO0FBQ0Esd0JBQVUsS0FBSyxRQUFMLENBQWMsRUFBZCxDQUFWO0FBQ0EsaUJBQUcsU0FBSCxDQUFhLEdBQWIsQ0FBaUIsY0FBakI7QUFDQSxrQkFBSSxPQUFKLEVBQWE7QUFDWCxtQkFBRyxTQUFILENBQWEsR0FBYixDQUFpQixhQUFqQjtBQUNBLHlCQUFTLElBQVQsQ0FBYyxFQUFkO0FBQ0EsbUNBQU8sb0JBQVAsQ0FBNEIsSUFBNUIsQ0FBaUMsTUFBakMsRUFBeUMsR0FBRyxPQUFILENBQVcsVUFBcEQ7QUFDQSxtQkFBRyxPQUFILENBQVcsVUFBWCxHQUF3QixtQkFBTyxxQkFBUCxDQUE2QixJQUE3QixDQUFrQyxNQUFsQyxFQUEwQyxZQUFZO0FBQzVFLHNCQUFJLFFBQVEsUUFBWixFQUFzQjtBQUNwQix3QkFBSSxPQUFPLElBQUksUUFBSixDQUFhLFNBQWIsRUFBd0IsT0FBeEIsRUFBaUMsUUFBUSxRQUF6QyxDQUFYO0FBQ0EsdUJBQUcsT0FBSCxDQUFXLFVBQVgsR0FBd0IsS0FBSyxPQUFMLEVBQWMsU0FBUyxNQUF2QixFQUErQixRQUEvQixFQUF4QjtBQUNBO0FBQ0Q7QUFDRCw0QkFBVSxLQUFLLFFBQUwsQ0FBYyxFQUFkLENBQVY7QUFDRCxpQkFQdUIsQ0FBeEI7QUFRRDtBQUNGO0FBQ0Q7QUFDQSxnQkFBSSxPQUFKLEVBQWE7QUFDWCxrQkFBSSxhQUFKLEVBQW1CO0FBQ2pCLG1CQUFHLFNBQUgsQ0FBYSxNQUFiLENBQW9CLFdBQXBCO0FBQ0EsbUJBQUcsU0FBSCxDQUFhLEdBQWIsQ0FBaUIsU0FBakI7QUFDRCxlQUhELE1BR087QUFDTCxtQkFBRyxTQUFILENBQWEsR0FBYixDQUFpQixXQUFqQjtBQUNBLG1CQUFHLFNBQUgsQ0FBYSxNQUFiLENBQW9CLFNBQXBCO0FBQ0Q7QUFDRjtBQUNGO0FBeEVTOztBQWdCWiwrQkFBZSxLQUFLLFFBQXBCLHdJQUE4QjtBQUFBO0FBeUQ3QjtBQUNEO0FBMUVZO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBMkVaLFdBQUssWUFBTCxHQUFvQixTQUFwQjtBQUNEOzs7O0VBbElrQixFOztBQXNJckI7O0FBRUEsT0FBTyxRQUFQLEdBQWtCO0FBQ2hCLGNBQVksT0FESTtBQUVoQixXQUFTLElBRk87QUFHaEIsUUFBTSxlQUhVO0FBSWhCLFNBQU8sQ0FKUztBQUtoQixTQUFPLFFBTFM7QUFNaEIsY0FBWSxHQU5JO0FBT2hCLGFBQVcsS0FQSztBQVFoQixjQUFZO0FBUkksQ0FBbEI7O0FBV0E7O0FBRUEsT0FBTyxNQUFQLEdBQWdCLE1BQWhCO1FBQ1EsTSxHQUFBLE0iLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIvLyAyMi4xLjMuMzEgQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgVU5TQ09QQUJMRVMgPSByZXF1aXJlKCcuL193a3MnKSgndW5zY29wYWJsZXMnKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuaWYgKEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZCkgcmVxdWlyZSgnLi9faGlkZScpKEFycmF5UHJvdG8sIFVOU0NPUEFCTEVTLCB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgQXJyYXlQcm90b1tVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIENvbnN0cnVjdG9yLCBuYW1lLCBmb3JiaWRkZW5GaWVsZCkge1xuICBpZiAoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSB8fCAoZm9yYmlkZGVuRmllbGQgIT09IHVuZGVmaW5lZCAmJiBmb3JiaWRkZW5GaWVsZCBpbiBpdCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IobmFtZSArICc6IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICB9IHJldHVybiBpdDtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIvLyAyMi4xLjMuMyBBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0LCBlbmQgPSB0aGlzLmxlbmd0aClcbid1c2Ugc3RyaWN0JztcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBbXS5jb3B5V2l0aGluIHx8IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0IC8qID0gMCAqLywgc3RhcnQgLyogPSAwLCBlbmQgPSBAbGVuZ3RoICovKSB7XG4gIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gIHZhciBsZW4gPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciB0byA9IHRvQWJzb2x1dGVJbmRleCh0YXJnZXQsIGxlbik7XG4gIHZhciBmcm9tID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW4pO1xuICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciBjb3VudCA9IE1hdGgubWluKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbikpIC0gZnJvbSwgbGVuIC0gdG8pO1xuICB2YXIgaW5jID0gMTtcbiAgaWYgKGZyb20gPCB0byAmJiB0byA8IGZyb20gKyBjb3VudCkge1xuICAgIGluYyA9IC0xO1xuICAgIGZyb20gKz0gY291bnQgLSAxO1xuICAgIHRvICs9IGNvdW50IC0gMTtcbiAgfVxuICB3aGlsZSAoY291bnQtLSA+IDApIHtcbiAgICBpZiAoZnJvbSBpbiBPKSBPW3RvXSA9IE9bZnJvbV07XG4gICAgZWxzZSBkZWxldGUgT1t0b107XG4gICAgdG8gKz0gaW5jO1xuICAgIGZyb20gKz0gaW5jO1xuICB9IHJldHVybiBPO1xufTtcbiIsIi8vIDIyLjEuMy42IEFycmF5LnByb3RvdHlwZS5maWxsKHZhbHVlLCBzdGFydCA9IDAsIGVuZCA9IHRoaXMubGVuZ3RoKVxuJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qICwgc3RhcnQgPSAwLCBlbmQgPSBAbGVuZ3RoICovKSB7XG4gIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGgpO1xuICB2YXIgZW5kID0gYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciBlbmRQb3MgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbmd0aCk7XG4gIHdoaWxlIChlbmRQb3MgPiBpbmRleCkgT1tpbmRleCsrXSA9IHZhbHVlO1xuICByZXR1cm4gTztcbn07XG4iLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykge1xuICAgICAgaWYgKE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcbiIsIi8vIDAgLT4gQXJyYXkjZm9yRWFjaFxuLy8gMSAtPiBBcnJheSNtYXBcbi8vIDIgLT4gQXJyYXkjZmlsdGVyXG4vLyAzIC0+IEFycmF5I3NvbWVcbi8vIDQgLT4gQXJyYXkjZXZlcnlcbi8vIDUgLT4gQXJyYXkjZmluZFxuLy8gNiAtPiBBcnJheSNmaW5kSW5kZXhcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBhc2MgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVFlQRSwgJGNyZWF0ZSkge1xuICB2YXIgSVNfTUFQID0gVFlQRSA9PSAxO1xuICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PSAyO1xuICB2YXIgSVNfU09NRSA9IFRZUEUgPT0gMztcbiAgdmFyIElTX0VWRVJZID0gVFlQRSA9PSA0O1xuICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNjtcbiAgdmFyIE5PX0hPTEVTID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVg7XG4gIHZhciBjcmVhdGUgPSAkY3JlYXRlIHx8IGFzYztcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCkge1xuICAgIHZhciBPID0gdG9PYmplY3QoJHRoaXMpO1xuICAgIHZhciBzZWxmID0gSU9iamVjdChPKTtcbiAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCB0aGF0LCAzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbCwgcmVzO1xuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuICAgICAgdmFsID0gc2VsZltpbmRleF07XG4gICAgICByZXMgPSBmKHZhbCwgaW5kZXgsIE8pO1xuICAgICAgaWYgKFRZUEUpIHtcbiAgICAgICAgaWYgKElTX01BUCkgcmVzdWx0W2luZGV4XSA9IHJlczsgICAvLyBtYXBcbiAgICAgICAgZWxzZSBpZiAocmVzKSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsOyAgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuICAgICAgICAgIGNhc2UgMjogcmVzdWx0LnB1c2godmFsKTsgICAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2UgaWYgKElTX0VWRVJZKSByZXR1cm4gZmFsc2U7IC8vIGV2ZXJ5XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiByZXN1bHQ7XG4gIH07XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsKSB7XG4gIHZhciBDO1xuICBpZiAoaXNBcnJheShvcmlnaW5hbCkpIHtcbiAgICBDID0gb3JpZ2luYWwuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZiAodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKSBDID0gdW5kZWZpbmVkO1xuICAgIGlmIChpc09iamVjdChDKSkge1xuICAgICAgQyA9IENbU1BFQ0lFU107XG4gICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQztcbn07XG4iLCIvLyA5LjQuMi4zIEFycmF5U3BlY2llc0NyZWF0ZShvcmlnaW5hbEFycmF5LCBsZW5ndGgpXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbCkpKGxlbmd0aCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGludm9rZSA9IHJlcXVpcmUoJy4vX2ludm9rZScpO1xudmFyIGFycmF5U2xpY2UgPSBbXS5zbGljZTtcbnZhciBmYWN0b3JpZXMgPSB7fTtcblxudmFyIGNvbnN0cnVjdCA9IGZ1bmN0aW9uIChGLCBsZW4sIGFyZ3MpIHtcbiAgaWYgKCEobGVuIGluIGZhY3RvcmllcykpIHtcbiAgICBmb3IgKHZhciBuID0gW10sIGkgPSAwOyBpIDwgbGVuOyBpKyspIG5baV0gPSAnYVsnICsgaSArICddJztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICBmYWN0b3JpZXNbbGVuXSA9IEZ1bmN0aW9uKCdGLGEnLCAncmV0dXJuIG5ldyBGKCcgKyBuLmpvaW4oJywnKSArICcpJyk7XG4gIH0gcmV0dXJuIGZhY3Rvcmllc1tsZW5dKEYsIGFyZ3MpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5iaW5kIHx8IGZ1bmN0aW9uIGJpbmQodGhhdCAvKiAsIC4uLmFyZ3MgKi8pIHtcbiAgdmFyIGZuID0gYUZ1bmN0aW9uKHRoaXMpO1xuICB2YXIgcGFydEFyZ3MgPSBhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgdmFyIGJvdW5kID0gZnVuY3Rpb24gKC8qIGFyZ3MuLi4gKi8pIHtcbiAgICB2YXIgYXJncyA9IHBhcnRBcmdzLmNvbmNhdChhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBib3VuZCA/IGNvbnN0cnVjdChmbiwgYXJncy5sZW5ndGgsIGFyZ3MpIDogaW52b2tlKGZuLCBhcmdzLCB0aGF0KTtcbiAgfTtcbiAgaWYgKGlzT2JqZWN0KGZuLnByb3RvdHlwZSkpIGJvdW5kLnByb3RvdHlwZSA9IGZuLnByb3RvdHlwZTtcbiAgcmV0dXJuIGJvdW5kO1xufTtcbiIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciAkaXRlckRlZmluZSA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBmYXN0S2V5ID0gcmVxdWlyZSgnLi9fbWV0YScpLmZhc3RLZXk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgU0laRSA9IERFU0NSSVBUT1JTID8gJ19zJyA6ICdzaXplJztcblxudmFyIGdldEVudHJ5ID0gZnVuY3Rpb24gKHRoYXQsIGtleSkge1xuICAvLyBmYXN0IGNhc2VcbiAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpO1xuICB2YXIgZW50cnk7XG4gIGlmIChpbmRleCAhPT0gJ0YnKSByZXR1cm4gdGhhdC5faVtpbmRleF07XG4gIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICBmb3IgKGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubikge1xuICAgIGlmIChlbnRyeS5rID09IGtleSkgcmV0dXJuIGVudHJ5O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX3QgPSBOQU1FOyAgICAgICAgIC8vIGNvbGxlY3Rpb24gdHlwZVxuICAgICAgdGhhdC5faSA9IGNyZWF0ZShudWxsKTsgLy8gaW5kZXhcbiAgICAgIHRoYXQuX2YgPSB1bmRlZmluZWQ7ICAgIC8vIGZpcnN0IGVudHJ5XG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAgICAvLyBsYXN0IGVudHJ5XG4gICAgICB0aGF0W1NJWkVdID0gMDsgICAgICAgICAvLyBzaXplXG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIGZvciAodmFyIHRoYXQgPSB2YWxpZGF0ZSh0aGlzLCBOQU1FKSwgZGF0YSA9IHRoYXQuX2ksIGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubikge1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmIChlbnRyeS5wKSBlbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuX2YgPSB0aGF0Ll9sID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGF0W1NJWkVdID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB0aGF0ID0gdmFsaWRhdGUodGhpcywgTkFNRSk7XG4gICAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIHZhciBuZXh0ID0gZW50cnkubjtcbiAgICAgICAgICB2YXIgcHJldiA9IGVudHJ5LnA7XG4gICAgICAgICAgZGVsZXRlIHRoYXQuX2lbZW50cnkuaV07XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYgKHByZXYpIHByZXYubiA9IG5leHQ7XG4gICAgICAgICAgaWYgKG5leHQpIG5leHQucCA9IHByZXY7XG4gICAgICAgICAgaWYgKHRoYXQuX2YgPT0gZW50cnkpIHRoYXQuX2YgPSBuZXh0O1xuICAgICAgICAgIGlmICh0aGF0Ll9sID09IGVudHJ5KSB0aGF0Ll9sID0gcHJldjtcbiAgICAgICAgICB0aGF0W1NJWkVdLS07XG4gICAgICAgIH0gcmV0dXJuICEhZW50cnk7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMi4zLjYgU2V0LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICAvLyAyMy4xLjMuNSBNYXAucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICAgICAgdmFsaWRhdGUodGhpcywgTkFNRSk7XG4gICAgICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKTtcbiAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICB3aGlsZSAoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGlzLl9mKSB7XG4gICAgICAgICAgZihlbnRyeS52LCBlbnRyeS5rLCB0aGlzKTtcbiAgICAgICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucikgZW50cnkgPSBlbnRyeS5wO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodmFsaWRhdGUodGhpcywgTkFNRSksIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKERFU0NSSVBUT1JTKSBkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHRoaXMsIE5BTUUpW1NJWkVdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICB2YXIgcHJldiwgaW5kZXg7XG4gICAgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBlbnRyeS52ID0gdmFsdWU7XG4gICAgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGF0Ll9sID0gZW50cnkgPSB7XG4gICAgICAgIGk6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLCAvLyA8LSBpbmRleFxuICAgICAgICBrOiBrZXksICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0ga2V5XG4gICAgICAgIHY6IHZhbHVlLCAgICAgICAgICAgICAgICAgICAgICAvLyA8LSB2YWx1ZVxuICAgICAgICBwOiBwcmV2ID0gdGhhdC5fbCwgICAgICAgICAgICAgLy8gPC0gcHJldmlvdXMgZW50cnlcbiAgICAgICAgbjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgIC8vIDwtIG5leHQgZW50cnlcbiAgICAgICAgcjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHJlbW92ZWRcbiAgICAgIH07XG4gICAgICBpZiAoIXRoYXQuX2YpIHRoYXQuX2YgPSBlbnRyeTtcbiAgICAgIGlmIChwcmV2KSBwcmV2Lm4gPSBlbnRyeTtcbiAgICAgIHRoYXRbU0laRV0rKztcbiAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgaWYgKGluZGV4ICE9PSAnRicpIHRoYXQuX2lbaW5kZXhdID0gZW50cnk7XG4gICAgfSByZXR1cm4gdGhhdDtcbiAgfSxcbiAgZ2V0RW50cnk6IGdldEVudHJ5LFxuICBzZXRTdHJvbmc6IGZ1bmN0aW9uIChDLCBOQU1FLCBJU19NQVApIHtcbiAgICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cbiAgICAvLyAyMy4xLjMuNCwgMjMuMS4zLjgsIDIzLjEuMy4xMSwgMjMuMS4zLjEyLCAyMy4yLjMuNSwgMjMuMi4zLjgsIDIzLjIuMy4xMCwgMjMuMi4zLjExXG4gICAgJGl0ZXJEZWZpbmUoQywgTkFNRSwgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gICAgICB0aGlzLl90ID0gdmFsaWRhdGUoaXRlcmF0ZWQsIE5BTUUpOyAvLyB0YXJnZXRcbiAgICAgIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAgICAgIC8vIGtpbmRcbiAgICAgIHRoaXMuX2wgPSB1bmRlZmluZWQ7ICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzXG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdmFyIGtpbmQgPSB0aGF0Ll9rO1xuICAgICAgdmFyIGVudHJ5ID0gdGhhdC5fbDtcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnIpIGVudHJ5ID0gZW50cnkucDtcbiAgICAgIC8vIGdldCBuZXh0IGVudHJ5XG4gICAgICBpZiAoIXRoYXQuX3QgfHwgISh0aGF0Ll9sID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGF0Ll90Ll9mKSkge1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICB0aGF0Ll90ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc3RlcCgxKTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcbiAgICAgIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgZW50cnkuayk7XG4gICAgICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgZW50cnkudik7XG4gICAgICByZXR1cm4gc3RlcCgwLCBbZW50cnkuaywgZW50cnkudl0pO1xuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnLCAhSVNfTUFQLCB0cnVlKTtcblxuICAgIC8vIGFkZCBbQEBzcGVjaWVzXSwgMjMuMS4yLjIsIDIzLjIuMi4yXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGdldFdlYWsgPSByZXF1aXJlKCcuL19tZXRhJykuZ2V0V2VhaztcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBjcmVhdGVBcnJheU1ldGhvZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKTtcbnZhciAkaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgYXJyYXlGaW5kID0gY3JlYXRlQXJyYXlNZXRob2QoNSk7XG52YXIgYXJyYXlGaW5kSW5kZXggPSBjcmVhdGVBcnJheU1ldGhvZCg2KTtcbnZhciBpZCA9IDA7XG5cbi8vIGZhbGxiYWNrIGZvciB1bmNhdWdodCBmcm96ZW4ga2V5c1xudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAodGhhdCkge1xuICByZXR1cm4gdGhhdC5fbCB8fCAodGhhdC5fbCA9IG5ldyBVbmNhdWdodEZyb3plblN0b3JlKCkpO1xufTtcbnZhciBVbmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmEgPSBbXTtcbn07XG52YXIgZmluZFVuY2F1Z2h0RnJvemVuID0gZnVuY3Rpb24gKHN0b3JlLCBrZXkpIHtcbiAgcmV0dXJuIGFycmF5RmluZChzdG9yZS5hLCBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgfSk7XG59O1xuVW5jYXVnaHRGcm96ZW5TdG9yZS5wcm90b3R5cGUgPSB7XG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmIChlbnRyeSkgcmV0dXJuIGVudHJ5WzFdO1xuICB9LFxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gISFmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmIChlbnRyeSkgZW50cnlbMV0gPSB2YWx1ZTtcbiAgICBlbHNlIHRoaXMuYS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0sXG4gICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGluZGV4ID0gYXJyYXlGaW5kSW5kZXgodGhpcy5hLCBmdW5jdGlvbiAoaXQpIHtcbiAgICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICAgIH0pO1xuICAgIGlmICh+aW5kZXgpIHRoaXMuYS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiAhIX5pbmRleDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll90ID0gTkFNRTsgICAgICAvLyBjb2xsZWN0aW9uIHR5cGVcbiAgICAgIHRoYXQuX2kgPSBpZCsrOyAgICAgIC8vIGNvbGxlY3Rpb24gaWRcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7IC8vIGxlYWsgc3RvcmUgZm9yIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RzXG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjMuMy4yIFdlYWtNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy40LjMuMyBXZWFrU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmICRoYXMoZGF0YSwgdGhpcy5faSkgJiYgZGVsZXRlIGRhdGFbdGhpcy5faV07XG4gICAgICB9LFxuICAgICAgLy8gMjMuMy4zLjQgV2Vha01hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjQuMy40IFdlYWtTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSkuaGFzKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmICRoYXMoZGF0YSwgdGhpcy5faSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZGF0YSA9IGdldFdlYWsoYW5PYmplY3Qoa2V5KSwgdHJ1ZSk7XG4gICAgaWYgKGRhdGEgPT09IHRydWUpIHVuY2F1Z2h0RnJvemVuU3RvcmUodGhhdCkuc2V0KGtleSwgdmFsdWUpO1xuICAgIGVsc2UgZGF0YVt0aGF0Ll9pXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGF0O1xuICB9LFxuICB1ZnN0b3JlOiB1bmNhdWdodEZyb3plblN0b3JlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgJGl0ZXJEZXRlY3QgPSByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSwgd3JhcHBlciwgbWV0aG9kcywgY29tbW9uLCBJU19NQVAsIElTX1dFQUspIHtcbiAgdmFyIEJhc2UgPSBnbG9iYWxbTkFNRV07XG4gIHZhciBDID0gQmFzZTtcbiAgdmFyIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJztcbiAgdmFyIHByb3RvID0gQyAmJiBDLnByb3RvdHlwZTtcbiAgdmFyIE8gPSB7fTtcbiAgdmFyIGZpeE1ldGhvZCA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgICB2YXIgZm4gPSBwcm90b1tLRVldO1xuICAgIHJlZGVmaW5lKHByb3RvLCBLRVksXG4gICAgICBLRVkgPT0gJ2RlbGV0ZScgPyBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyBmYWxzZSA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2hhcycgPyBmdW5jdGlvbiBoYXMoYSkge1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyBmYWxzZSA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2dldCcgPyBmdW5jdGlvbiBnZXQoYSkge1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyB1bmRlZmluZWQgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdhZGQnID8gZnVuY3Rpb24gYWRkKGEpIHsgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpOyByZXR1cm4gdGhpczsgfVxuICAgICAgICA6IGZ1bmN0aW9uIHNldChhLCBiKSB7IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhLCBiKTsgcmV0dXJuIHRoaXM7IH1cbiAgICApO1xuICB9O1xuICBpZiAodHlwZW9mIEMgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgcHJvdG8uZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyBDKCkuZW50cmllcygpLm5leHQoKTtcbiAgfSkpKSB7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgICBtZXRhLk5FRUQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDKCk7XG4gICAgLy8gZWFybHkgaW1wbGVtZW50YXRpb25zIG5vdCBzdXBwb3J0cyBjaGFpbmluZ1xuICAgIHZhciBIQVNOVF9DSEFJTklORyA9IGluc3RhbmNlW0FEREVSXShJU19XRUFLID8ge30gOiAtMCwgMSkgIT0gaW5zdGFuY2U7XG4gICAgLy8gVjggfiAgQ2hyb21pdW0gNDAtIHdlYWstY29sbGVjdGlvbnMgdGhyb3dzIG9uIHByaW1pdGl2ZXMsIGJ1dCBzaG91bGQgcmV0dXJuIGZhbHNlXG4gICAgdmFyIFRIUk9XU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkgeyBpbnN0YW5jZS5oYXMoMSk7IH0pO1xuICAgIC8vIG1vc3QgZWFybHkgaW1wbGVtZW50YXRpb25zIGRvZXNuJ3Qgc3VwcG9ydHMgaXRlcmFibGVzLCBtb3N0IG1vZGVybiAtIG5vdCBjbG9zZSBpdCBjb3JyZWN0bHlcbiAgICB2YXIgQUNDRVBUX0lURVJBQkxFUyA9ICRpdGVyRGV0ZWN0KGZ1bmN0aW9uIChpdGVyKSB7IG5ldyBDKGl0ZXIpOyB9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAvLyBmb3IgZWFybHkgaW1wbGVtZW50YXRpb25zIC0wIGFuZCArMCBub3QgdGhlIHNhbWVcbiAgICB2YXIgQlVHR1lfWkVSTyA9ICFJU19XRUFLICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFY4IH4gQ2hyb21pdW0gNDItIGZhaWxzIG9ubHkgd2l0aCA1KyBlbGVtZW50c1xuICAgICAgdmFyICRpbnN0YW5jZSA9IG5ldyBDKCk7XG4gICAgICB2YXIgaW5kZXggPSA1O1xuICAgICAgd2hpbGUgKGluZGV4LS0pICRpbnN0YW5jZVtBRERFUl0oaW5kZXgsIGluZGV4KTtcbiAgICAgIHJldHVybiAhJGluc3RhbmNlLmhhcygtMCk7XG4gICAgfSk7XG4gICAgaWYgKCFBQ0NFUFRfSVRFUkFCTEVTKSB7XG4gICAgICBDID0gd3JhcHBlcihmdW5jdGlvbiAodGFyZ2V0LCBpdGVyYWJsZSkge1xuICAgICAgICBhbkluc3RhbmNlKHRhcmdldCwgQywgTkFNRSk7XG4gICAgICAgIHZhciB0aGF0ID0gaW5oZXJpdElmUmVxdWlyZWQobmV3IEJhc2UoKSwgdGFyZ2V0LCBDKTtcbiAgICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICAgIH0pO1xuICAgICAgQy5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgIHByb3RvLmNvbnN0cnVjdG9yID0gQztcbiAgICB9XG4gICAgaWYgKFRIUk9XU19PTl9QUklNSVRJVkVTIHx8IEJVR0dZX1pFUk8pIHtcbiAgICAgIGZpeE1ldGhvZCgnZGVsZXRlJyk7XG4gICAgICBmaXhNZXRob2QoJ2hhcycpO1xuICAgICAgSVNfTUFQICYmIGZpeE1ldGhvZCgnZ2V0Jyk7XG4gICAgfVxuICAgIGlmIChCVUdHWV9aRVJPIHx8IEhBU05UX0NIQUlOSU5HKSBmaXhNZXRob2QoQURERVIpO1xuICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgc2hvdWxkIG5vdCBjb250YWlucyAuY2xlYXIgbWV0aG9kXG4gICAgaWYgKElTX1dFQUsgJiYgcHJvdG8uY2xlYXIpIGRlbGV0ZSBwcm90by5jbGVhcjtcbiAgfVxuXG4gIHNldFRvU3RyaW5nVGFnKEMsIE5BTUUpO1xuXG4gIE9bTkFNRV0gPSBDO1xuICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChDICE9IEJhc2UpLCBPKTtcblxuICBpZiAoIUlTX1dFQUspIGNvbW1vbi5zZXRTdHJvbmcoQywgTkFNRSwgSVNfTUFQKTtcblxuICByZXR1cm4gQztcbn07XG4iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi41LjcnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgaW5kZXgsIHZhbHVlKSB7XG4gIGlmIChpbmRleCBpbiBvYmplY3QpICRkZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwgaW5kZXgsIGNyZWF0ZURlc2MoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG59O1xuIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcbiIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSk7XG4gIHZhciBrZXksIG93biwgb3V0LCBleHA7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgZXhwID0gSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIGlmICh0YXJnZXQpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmIChleHBvcnRzW2tleV0gIT0gb3V0KSBoaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZiAoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpIGV4cFByb3RvW2tleV0gPSBvdXQ7XG4gIH1cbn07XG5nbG9iYWwuY29yZSA9IGNvcmU7XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG4iLCJ2YXIgTUFUQ0ggPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSkge1xuICB2YXIgcmUgPSAvLi87XG4gIHRyeSB7XG4gICAgJy8uLydbS0VZXShyZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0cnkge1xuICAgICAgcmVbTUFUQ0hdID0gZmFsc2U7XG4gICAgICByZXR1cm4gIScvLi8nW0tFWV0ocmUpO1xuICAgIH0gY2F0Y2ggKGYpIHsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiB0cnVlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBsZW5ndGgsIGV4ZWMpIHtcbiAgdmFyIFNZTUJPTCA9IHdrcyhLRVkpO1xuICB2YXIgZm5zID0gZXhlYyhkZWZpbmVkLCBTWU1CT0wsICcnW0tFWV0pO1xuICB2YXIgc3RyZm4gPSBmbnNbMF07XG4gIHZhciByeGZuID0gZm5zWzFdO1xuICBpZiAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xuICB9KSkge1xuICAgIHJlZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgc3RyZm4pO1xuICAgIGhpZGUoUmVnRXhwLnByb3RvdHlwZSwgU1lNQk9MLCBsZW5ndGggPT0gMlxuICAgICAgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdKHN0cmluZywgcmVwbGFjZVZhbHVlKVxuICAgICAgLy8gMjEuMi41LjExIFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF0oc3RyaW5nLCBsaW1pdClcbiAgICAgID8gZnVuY3Rpb24gKHN0cmluZywgYXJnKSB7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzLCBhcmcpOyB9XG4gICAgICAvLyAyMS4yLjUuNiBSZWdFeHAucHJvdG90eXBlW0BAbWF0Y2hdKHN0cmluZylcbiAgICAgIC8vIDIxLjIuNS45IFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdKHN0cmluZylcbiAgICAgIDogZnVuY3Rpb24gKHN0cmluZykgeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcyk7IH1cbiAgICApO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gYW5PYmplY3QodGhpcyk7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoYXQuZ2xvYmFsKSByZXN1bHQgKz0gJ2cnO1xuICBpZiAodGhhdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuICBpZiAodGhhdC5tdWx0aWxpbmUpIHJlc3VsdCArPSAnbSc7XG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG4gIGlmICh0aGF0LnN0aWNreSkgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xudmFyIEJSRUFLID0ge307XG52YXIgUkVUVVJOID0ge307XG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCwgSVRFUkFUT1IpIHtcbiAgdmFyIGl0ZXJGbiA9IElURVJBVE9SID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcmFibGU7IH0gOiBnZXRJdGVyRm4oaXRlcmFibGUpO1xuICB2YXIgZiA9IGN0eChmbiwgdGhhdCwgZW50cmllcyA/IDIgOiAxKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3IsIHJlc3VsdDtcbiAgaWYgKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ZXJhYmxlICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIC8vIGZhc3QgY2FzZSBmb3IgYXJyYXlzIHdpdGggZGVmYXVsdCBpdGVyYXRvclxuICBpZiAoaXNBcnJheUl0ZXIoaXRlckZuKSkgZm9yIChsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgIHJlc3VsdCA9IGVudHJpZXMgPyBmKGFuT2JqZWN0KHN0ZXAgPSBpdGVyYWJsZVtpbmRleF0pWzBdLCBzdGVwWzFdKSA6IGYoaXRlcmFibGVbaW5kZXhdKTtcbiAgICBpZiAocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTikgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTspIHtcbiAgICByZXN1bHQgPSBjYWxsKGl0ZXJhdG9yLCBmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKTtcbiAgICBpZiAocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTikgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbmV4cG9ydHMuQlJFQUsgPSBCUkVBSztcbmV4cG9ydHMuUkVUVVJOID0gUkVUVVJOO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsInZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCB0YXJnZXQsIEMpIHtcbiAgdmFyIFMgPSB0YXJnZXQuY29uc3RydWN0b3I7XG4gIHZhciBQO1xuICBpZiAoUyAhPT0gQyAmJiB0eXBlb2YgUyA9PSAnZnVuY3Rpb24nICYmIChQID0gUy5wcm90b3R5cGUpICE9PSBDLnByb3RvdHlwZSAmJiBpc09iamVjdChQKSAmJiBzZXRQcm90b3R5cGVPZikge1xuICAgIHNldFByb3RvdHlwZU9mKHRoYXQsIFApO1xuICB9IHJldHVybiB0aGF0O1xufTtcbiIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIGFyZ3MsIHRoYXQpIHtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcbiIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG4iLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcbiIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuIiwiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzSW50ZWdlcihpdCkge1xuICByZXR1cm4gIWlzT2JqZWN0KGl0KSAmJiBpc0Zpbml0ZShpdCkgJiYgZmxvb3IoaXQpID09PSBpdDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcbiIsIi8vIDcuMi44IElzUmVnRXhwKGFyZ3VtZW50KVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgTUFUQ0ggPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBpc1JlZ0V4cDtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiAoKGlzUmVnRXhwID0gaXRbTUFUQ0hdKSAhPT0gdW5kZWZpbmVkID8gISFpc1JlZ0V4cCA6IGNvZihpdCkgPT0gJ1JlZ0V4cCcpO1xufTtcbiIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcykge1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkgYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBkZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgJGl0ZXJDcmVhdGUgPSByZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpOyAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG52YXIgRkZfSVRFUkFUT1IgPSAnQEBpdGVyYXRvcic7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gKGtpbmQpIHtcbiAgICBpZiAoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pIHJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTO1xuICB2YXIgVkFMVUVTX0JVRyA9IGZhbHNlO1xuICB2YXIgcHJvdG8gPSBCYXNlLnByb3RvdHlwZTtcbiAgdmFyICRuYXRpdmUgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF07XG4gIHZhciAkZGVmYXVsdCA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpO1xuICB2YXIgJGVudHJpZXMgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkO1xuICB2YXIgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmU7XG4gIHZhciBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmICgkYW55TmF0aXZlKSB7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UoKSkpO1xuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYgKCFMSUJSQVJZICYmIHR5cGVvZiBJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0gIT0gJ2Z1bmN0aW9uJykgaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKSB7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSA9IHJldHVyblRoaXM7XG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKGtleSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoIShrZXkgaW4gcHJvdG8pKSByZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuIiwidmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtJVEVSQVRPUl0oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24gKCkgeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xufSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMsIHNraXBDbG9zaW5nKSB7XG4gIGlmICghc2tpcENsb3NpbmcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBbN107XG4gICAgdmFyIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4geyBkb25lOiBzYWZlID0gdHJ1ZSB9OyB9O1xuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbmUsIHZhbHVlKSB7XG4gIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lIH07XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG4iLCIvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxudmFyICRleHBtMSA9IE1hdGguZXhwbTE7XG5tb2R1bGUuZXhwb3J0cyA9ICghJGV4cG0xXG4gIC8vIE9sZCBGRiBidWdcbiAgfHwgJGV4cG0xKDEwKSA+IDIyMDI1LjQ2NTc5NDgwNjcxOSB8fCAkZXhwbTEoMTApIDwgMjIwMjUuNDY1Nzk0ODA2NzE2NTE2OFxuICAvLyBUb3IgQnJvd3NlciBidWdcbiAgfHwgJGV4cG0xKC0yZS0xNykgIT0gLTJlLTE3XG4pID8gZnVuY3Rpb24gZXhwbTEoeCkge1xuICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiB4ID4gLTFlLTYgJiYgeCA8IDFlLTYgPyB4ICsgeCAqIHggLyAyIDogTWF0aC5leHAoeCkgLSAxO1xufSA6ICRleHBtMTtcbiIsIi8vIDIwLjIuMi4xNiBNYXRoLmZyb3VuZCh4KVxudmFyIHNpZ24gPSByZXF1aXJlKCcuL19tYXRoLXNpZ24nKTtcbnZhciBwb3cgPSBNYXRoLnBvdztcbnZhciBFUFNJTE9OID0gcG93KDIsIC01Mik7XG52YXIgRVBTSUxPTjMyID0gcG93KDIsIC0yMyk7XG52YXIgTUFYMzIgPSBwb3coMiwgMTI3KSAqICgyIC0gRVBTSUxPTjMyKTtcbnZhciBNSU4zMiA9IHBvdygyLCAtMTI2KTtcblxudmFyIHJvdW5kVGllc1RvRXZlbiA9IGZ1bmN0aW9uIChuKSB7XG4gIHJldHVybiBuICsgMSAvIEVQU0lMT04gLSAxIC8gRVBTSUxPTjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0aC5mcm91bmQgfHwgZnVuY3Rpb24gZnJvdW5kKHgpIHtcbiAgdmFyICRhYnMgPSBNYXRoLmFicyh4KTtcbiAgdmFyICRzaWduID0gc2lnbih4KTtcbiAgdmFyIGEsIHJlc3VsdDtcbiAgaWYgKCRhYnMgPCBNSU4zMikgcmV0dXJuICRzaWduICogcm91bmRUaWVzVG9FdmVuKCRhYnMgLyBNSU4zMiAvIEVQU0lMT04zMikgKiBNSU4zMiAqIEVQU0lMT04zMjtcbiAgYSA9ICgxICsgRVBTSUxPTjMyIC8gRVBTSUxPTikgKiAkYWJzO1xuICByZXN1bHQgPSBhIC0gKGEgLSAkYWJzKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICBpZiAocmVzdWx0ID4gTUFYMzIgfHwgcmVzdWx0ICE9IHJlc3VsdCkgcmV0dXJuICRzaWduICogSW5maW5pdHk7XG4gIHJldHVybiAkc2lnbiAqIHJlc3VsdDtcbn07XG4iLCIvLyAyMC4yLjIuMjAgTWF0aC5sb2cxcCh4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLmxvZzFwIHx8IGZ1bmN0aW9uIGxvZzFwKHgpIHtcbiAgcmV0dXJuICh4ID0gK3gpID4gLTFlLTggJiYgeCA8IDFlLTggPyB4IC0geCAqIHggLyAyIDogTWF0aC5sb2coMSArIHgpO1xufTtcbiIsIi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbm1vZHVsZS5leHBvcnRzID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uIHNpZ24oeCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHJldHVybiAoeCA9ICt4KSA9PSAwIHx8IHggIT0geCA/IHggOiB4IDwgMCA/IC0xIDogMTtcbn07XG4iLCJ2YXIgTUVUQSA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBzZXREZXNjID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBpZCA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIHNldERlc2MoaXQsIE1FVEEsIHsgdmFsdWU6IHtcbiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IH0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSkgc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6IE1FVEEsXG4gIE5FRUQ6IGZhbHNlLFxuICBmYXN0S2V5OiBmYXN0S2V5LFxuICBnZXRXZWFrOiBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgbWFjcm90YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcbnZhciBPYnNlcnZlciA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBQcm9taXNlID0gZ2xvYmFsLlByb21pc2U7XG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYgKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKSBwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICBmbiA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGhlYWQpIG5vdGlmeSgpO1xuICAgICAgICBlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIE5vZGUuanNcbiAgaWYgKGlzTm9kZSkge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlciwgZXhjZXB0IGlPUyBTYWZhcmkgLSBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzM5XG4gIH0gZWxzZSBpZiAoT2JzZXJ2ZXIgJiYgIShnbG9iYWwubmF2aWdhdG9yICYmIGdsb2JhbC5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSkpIHtcbiAgICB2YXIgdG9nZ2xlID0gdHJ1ZTtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBuZXcgT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmIChQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSkge1xuICAgIC8vIFByb21pc2UucmVzb2x2ZSB3aXRob3V0IGFuIGFyZ3VtZW50IHRocm93cyBhbiBlcnJvciBpbiBMRyBXZWJPUyAyXG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuY2FsbChnbG9iYWwpXG4gICAgICBtYWNyb3Rhc2suY2FsbChnbG9iYWwsIGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIHZhciB0YXNrID0geyBmbjogZm4sIG5leHQ6IHVuZGVmaW5lZCB9O1xuICAgIGlmIChsYXN0KSBsYXN0Lm5leHQgPSB0YXNrO1xuICAgIGlmICghaGVhZCkge1xuICAgICAgaGVhZCA9IHRhc2s7XG4gICAgICBub3RpZnkoKTtcbiAgICB9IGxhc3QgPSB0YXNrO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDI1LjQuMS41IE5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG5mdW5jdGlvbiBQcm9taXNlQ2FwYWJpbGl0eShDKSB7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7XG4gICAgaWYgKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ID0gYUZ1bmN0aW9uKHJlamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgUyA9IFN5bWJvbCgpO1xuICB2YXIgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikgaWYgKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpIFRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBkUHMgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKTtcbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuIiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG4iLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4iLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMpIHtcbiAgdmFyIGZuID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldO1xuICB2YXIgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkgeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTtcbiIsInZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgaXNFbnVtID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpc0VudHJpZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KGl0KTtcbiAgICB2YXIga2V5cyA9IGdldEtleXMoTyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaSkgaWYgKGlzRW51bS5jYWxsKE8sIGtleSA9IGtleXNbaSsrXSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGlzRW50cmllcyA/IFtrZXksIE9ba2V5XV0gOiBPW2tleV0pO1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07XG4iLCIvLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBSZWZsZWN0ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdDtcbm1vZHVsZS5leHBvcnRzID0gUmVmbGVjdCAmJiBSZWZsZWN0Lm93bktleXMgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICB2YXIga2V5cyA9IGdPUE4uZihhbk9iamVjdChpdCkpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgcmV0dXJuIGdldFN5bWJvbHMgPyBrZXlzLmNvbmNhdChnZXRTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4geyBlOiBmYWxzZSwgdjogZXhlYygpIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4geyBlOiB0cnVlLCB2OiBlIH07XG4gIH1cbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDLCB4KSB7XG4gIGFuT2JqZWN0KEMpO1xuICBpZiAoaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgcmVzb2x2ZSh4KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcbiIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgc2FmZSkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSByZWRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0sIHNhZmUpO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFNSQyA9IHJlcXVpcmUoJy4vX3VpZCcpKCdzcmMnKTtcbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyICR0b1N0cmluZyA9IEZ1bmN0aW9uW1RPX1NUUklOR107XG52YXIgVFBMID0gKCcnICsgJHRvU3RyaW5nKS5zcGxpdChUT19TVFJJTkcpO1xuXG5yZXF1aXJlKCcuL19jb3JlJykuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoaXQpO1xufTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsLCBzYWZlKSB7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgJ25hbWUnKSB8fCBoaWRlKHZhbCwgJ25hbWUnLCBrZXkpO1xuICBpZiAoT1trZXldID09PSB2YWwpIHJldHVybjtcbiAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsIFNSQykgfHwgaGlkZSh2YWwsIFNSQywgT1trZXldID8gJycgKyBPW2tleV0gOiBUUEwuam9pbihTdHJpbmcoa2V5KSkpO1xuICBpZiAoTyA9PT0gZ2xvYmFsKSB7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2UgaWYgKCFzYWZlKSB7XG4gICAgZGVsZXRlIE9ba2V5XTtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfSBlbHNlIGlmIChPW2tleV0pIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgaGlkZShPLCBrZXksIHZhbCk7XG4gIH1cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzW1NSQ10gfHwgJHRvU3RyaW5nLmNhbGwodGhpcyk7XG59KTtcbiIsIi8vIDcuMi45IFNhbWVWYWx1ZSh4LCB5KVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuaXMgfHwgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHJldHVybiB4ID09PSB5ID8geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkgOiB4ICE9IHggJiYgeSAhPSB5O1xufTtcbiIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoTywgcHJvdG8pIHtcbiAgYW5PYmplY3QoTyk7XG4gIGlmICghaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKSB0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbiAodGVzdCwgYnVnZ3ksIHNldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZiAoYnVnZ3kpIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciBDID0gZ2xvYmFsW0tFWV07XG4gIGlmIChERVNDUklQVE9SUyAmJiBDICYmICFDW1NQRUNJRVNdKSBkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTtcbiIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgdGFnLCBzdGF0KSB7XG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKSBkZWYoaXQsIFRBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWcgfSk7XG59O1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246IGNvcmUudmVyc2lvbixcbiAgbW9kZTogcmVxdWlyZSgnLi9fbGlicmFyeScpID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTggRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG59KTtcbiIsIi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywgRCkge1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yO1xuICB2YXIgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogYUZ1bmN0aW9uKFMpO1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBwb3MpIHtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbiAgICB2YXIgaSA9IHRvSW50ZWdlcihwb3MpO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gbCkgcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG4iLCIvLyBoZWxwZXIgZm9yIFN0cmluZyN7c3RhcnRzV2l0aCwgZW5kc1dpdGgsIGluY2x1ZGVzfVxudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhhdCwgc2VhcmNoU3RyaW5nLCBOQU1FKSB7XG4gIGlmIChpc1JlZ0V4cChzZWFyY2hTdHJpbmcpKSB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZyMnICsgTkFNRSArIFwiIGRvZXNuJ3QgYWNjZXB0IHJlZ2V4IVwiKTtcbiAgcmV0dXJuIFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbn07XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgcmVwZWF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIG1heExlbmd0aCwgZmlsbFN0cmluZywgbGVmdCkge1xuICB2YXIgUyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbiAgdmFyIHN0cmluZ0xlbmd0aCA9IFMubGVuZ3RoO1xuICB2YXIgZmlsbFN0ciA9IGZpbGxTdHJpbmcgPT09IHVuZGVmaW5lZCA/ICcgJyA6IFN0cmluZyhmaWxsU3RyaW5nKTtcbiAgdmFyIGludE1heExlbmd0aCA9IHRvTGVuZ3RoKG1heExlbmd0aCk7XG4gIGlmIChpbnRNYXhMZW5ndGggPD0gc3RyaW5nTGVuZ3RoIHx8IGZpbGxTdHIgPT0gJycpIHJldHVybiBTO1xuICB2YXIgZmlsbExlbiA9IGludE1heExlbmd0aCAtIHN0cmluZ0xlbmd0aDtcbiAgdmFyIHN0cmluZ0ZpbGxlciA9IHJlcGVhdC5jYWxsKGZpbGxTdHIsIE1hdGguY2VpbChmaWxsTGVuIC8gZmlsbFN0ci5sZW5ndGgpKTtcbiAgaWYgKHN0cmluZ0ZpbGxlci5sZW5ndGggPiBmaWxsTGVuKSBzdHJpbmdGaWxsZXIgPSBzdHJpbmdGaWxsZXIuc2xpY2UoMCwgZmlsbExlbik7XG4gIHJldHVybiBsZWZ0ID8gc3RyaW5nRmlsbGVyICsgUyA6IFMgKyBzdHJpbmdGaWxsZXI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGVhdChjb3VudCkge1xuICB2YXIgc3RyID0gU3RyaW5nKGRlZmluZWQodGhpcykpO1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBuID0gdG9JbnRlZ2VyKGNvdW50KTtcbiAgaWYgKG4gPCAwIHx8IG4gPT0gSW5maW5pdHkpIHRocm93IFJhbmdlRXJyb3IoXCJDb3VudCBjYW4ndCBiZSBuZWdhdGl2ZVwiKTtcbiAgZm9yICg7biA+IDA7IChuID4+Pj0gMSkgJiYgKHN0ciArPSBzdHIpKSBpZiAobiAmIDEpIHJlcyArPSBzdHI7XG4gIHJldHVybiByZXM7XG59O1xuIiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGludm9rZSA9IHJlcXVpcmUoJy4vX2ludm9rZScpO1xudmFyIGh0bWwgPSByZXF1aXJlKCcuL19odG1sJyk7XG52YXIgY2VsID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBzZXRUYXNrID0gZ2xvYmFsLnNldEltbWVkaWF0ZTtcbnZhciBjbGVhclRhc2sgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGU7XG52YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWw7XG52YXIgRGlzcGF0Y2ggPSBnbG9iYWwuRGlzcGF0Y2g7XG52YXIgY291bnRlciA9IDA7XG52YXIgcXVldWUgPSB7fTtcbnZhciBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbnZhciBkZWZlciwgY2hhbm5lbCwgcG9ydDtcbnZhciBydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpZCA9ICt0aGlzO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIGlmIChxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmICghc2V0VGFzayB8fCAhY2xlYXJUYXNrKSB7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBpID0gMTtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKSB7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmIChyZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2VzcycpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxuICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3coY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZiAoTWVzc2FnZUNoYW5uZWwpIHtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZiAoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0JykpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b2luZGV4XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7XG4gIHZhciBudW1iZXIgPSB0b0ludGVnZXIoaXQpO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgobnVtYmVyKTtcbiAgaWYgKG51bWJlciAhPT0gbGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBsZW5ndGghJyk7XG4gIHJldHVybiBsZW5ndGg7XG59O1xuIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG4iLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG4iLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbmlmIChyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpKSB7XG4gIHZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xuICB2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG4gIHZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG4gIHZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4gIHZhciAkdHlwZWQgPSByZXF1aXJlKCcuL190eXBlZCcpO1xuICB2YXIgJGJ1ZmZlciA9IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpO1xuICB2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG4gIHZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbiAgdmFyIHByb3BlcnR5RGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbiAgdmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG4gIHZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xuICB2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xuICB2YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbiAgdmFyIHRvSW5kZXggPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xuICB2YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbiAgdmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG4gIHZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbiAgdmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG4gIHZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuICB2YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbiAgdmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xuICB2YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xuICB2YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG4gIHZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xuICB2YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbiAgdmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xuICB2YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG4gIHZhciBjcmVhdGVBcnJheU1ldGhvZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKTtcbiAgdmFyIGNyZWF0ZUFycmF5SW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpO1xuICB2YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuICB2YXIgQXJyYXlJdGVyYXRvcnMgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xuICB2YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG4gIHZhciAkaXRlckRldGVjdCA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0Jyk7XG4gIHZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKTtcbiAgdmFyIGFycmF5RmlsbCA9IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKTtcbiAgdmFyIGFycmF5Q29weVdpdGhpbiA9IHJlcXVpcmUoJy4vX2FycmF5LWNvcHktd2l0aGluJyk7XG4gIHZhciAkRFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbiAgdmFyICRHT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbiAgdmFyIGRQID0gJERQLmY7XG4gIHZhciBnT1BEID0gJEdPUEQuZjtcbiAgdmFyIFJhbmdlRXJyb3IgPSBnbG9iYWwuUmFuZ2VFcnJvcjtcbiAgdmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG4gIHZhciBVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXk7XG4gIHZhciBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xuICB2YXIgU0hBUkVEX0JVRkZFUiA9ICdTaGFyZWQnICsgQVJSQVlfQlVGRkVSO1xuICB2YXIgQllURVNfUEVSX0VMRU1FTlQgPSAnQllURVNfUEVSX0VMRU1FTlQnO1xuICB2YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXlbUFJPVE9UWVBFXTtcbiAgdmFyICRBcnJheUJ1ZmZlciA9ICRidWZmZXIuQXJyYXlCdWZmZXI7XG4gIHZhciAkRGF0YVZpZXcgPSAkYnVmZmVyLkRhdGFWaWV3O1xuICB2YXIgYXJyYXlGb3JFYWNoID0gY3JlYXRlQXJyYXlNZXRob2QoMCk7XG4gIHZhciBhcnJheUZpbHRlciA9IGNyZWF0ZUFycmF5TWV0aG9kKDIpO1xuICB2YXIgYXJyYXlTb21lID0gY3JlYXRlQXJyYXlNZXRob2QoMyk7XG4gIHZhciBhcnJheUV2ZXJ5ID0gY3JlYXRlQXJyYXlNZXRob2QoNCk7XG4gIHZhciBhcnJheUZpbmQgPSBjcmVhdGVBcnJheU1ldGhvZCg1KTtcbiAgdmFyIGFycmF5RmluZEluZGV4ID0gY3JlYXRlQXJyYXlNZXRob2QoNik7XG4gIHZhciBhcnJheUluY2x1ZGVzID0gY3JlYXRlQXJyYXlJbmNsdWRlcyh0cnVlKTtcbiAgdmFyIGFycmF5SW5kZXhPZiA9IGNyZWF0ZUFycmF5SW5jbHVkZXMoZmFsc2UpO1xuICB2YXIgYXJyYXlWYWx1ZXMgPSBBcnJheUl0ZXJhdG9ycy52YWx1ZXM7XG4gIHZhciBhcnJheUtleXMgPSBBcnJheUl0ZXJhdG9ycy5rZXlzO1xuICB2YXIgYXJyYXlFbnRyaWVzID0gQXJyYXlJdGVyYXRvcnMuZW50cmllcztcbiAgdmFyIGFycmF5TGFzdEluZGV4T2YgPSBBcnJheVByb3RvLmxhc3RJbmRleE9mO1xuICB2YXIgYXJyYXlSZWR1Y2UgPSBBcnJheVByb3RvLnJlZHVjZTtcbiAgdmFyIGFycmF5UmVkdWNlUmlnaHQgPSBBcnJheVByb3RvLnJlZHVjZVJpZ2h0O1xuICB2YXIgYXJyYXlKb2luID0gQXJyYXlQcm90by5qb2luO1xuICB2YXIgYXJyYXlTb3J0ID0gQXJyYXlQcm90by5zb3J0O1xuICB2YXIgYXJyYXlTbGljZSA9IEFycmF5UHJvdG8uc2xpY2U7XG4gIHZhciBhcnJheVRvU3RyaW5nID0gQXJyYXlQcm90by50b1N0cmluZztcbiAgdmFyIGFycmF5VG9Mb2NhbGVTdHJpbmcgPSBBcnJheVByb3RvLnRvTG9jYWxlU3RyaW5nO1xuICB2YXIgSVRFUkFUT1IgPSB3a3MoJ2l0ZXJhdG9yJyk7XG4gIHZhciBUQUcgPSB3a3MoJ3RvU3RyaW5nVGFnJyk7XG4gIHZhciBUWVBFRF9DT05TVFJVQ1RPUiA9IHVpZCgndHlwZWRfY29uc3RydWN0b3InKTtcbiAgdmFyIERFRl9DT05TVFJVQ1RPUiA9IHVpZCgnZGVmX2NvbnN0cnVjdG9yJyk7XG4gIHZhciBBTExfQ09OU1RSVUNUT1JTID0gJHR5cGVkLkNPTlNUUjtcbiAgdmFyIFRZUEVEX0FSUkFZID0gJHR5cGVkLlRZUEVEO1xuICB2YXIgVklFVyA9ICR0eXBlZC5WSUVXO1xuICB2YXIgV1JPTkdfTEVOR1RIID0gJ1dyb25nIGxlbmd0aCEnO1xuXG4gIHZhciAkbWFwID0gY3JlYXRlQXJyYXlNZXRob2QoMSwgZnVuY3Rpb24gKE8sIGxlbmd0aCkge1xuICAgIHJldHVybiBhbGxvY2F0ZShzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSwgbGVuZ3RoKTtcbiAgfSk7XG5cbiAgdmFyIExJVFRMRV9FTkRJQU4gPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBVaW50MTZBcnJheShbMV0pLmJ1ZmZlcilbMF0gPT09IDE7XG4gIH0pO1xuXG4gIHZhciBGT1JDRURfU0VUID0gISFVaW50OEFycmF5ICYmICEhVWludDhBcnJheVtQUk9UT1RZUEVdLnNldCAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IFVpbnQ4QXJyYXkoMSkuc2V0KHt9KTtcbiAgfSk7XG5cbiAgdmFyIHRvT2Zmc2V0ID0gZnVuY3Rpb24gKGl0LCBCWVRFUykge1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXIoaXQpO1xuICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCAlIEJZVEVTKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQhJyk7XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfTtcblxuICB2YXIgdmFsaWRhdGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICBpZiAoaXNPYmplY3QoaXQpICYmIFRZUEVEX0FSUkFZIGluIGl0KSByZXR1cm4gaXQ7XG4gICAgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSB0eXBlZCBhcnJheSEnKTtcbiAgfTtcblxuICB2YXIgYWxsb2NhdGUgPSBmdW5jdGlvbiAoQywgbGVuZ3RoKSB7XG4gICAgaWYgKCEoaXNPYmplY3QoQykgJiYgVFlQRURfQ09OU1RSVUNUT1IgaW4gQykpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignSXQgaXMgbm90IGEgdHlwZWQgYXJyYXkgY29uc3RydWN0b3IhJyk7XG4gICAgfSByZXR1cm4gbmV3IEMobGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgc3BlY2llc0Zyb21MaXN0ID0gZnVuY3Rpb24gKE8sIGxpc3QpIHtcbiAgICByZXR1cm4gZnJvbUxpc3Qoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSksIGxpc3QpO1xuICB9O1xuXG4gIHZhciBmcm9tTGlzdCA9IGZ1bmN0aW9uIChDLCBsaXN0KSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IGFsbG9jYXRlKEMsIGxlbmd0aCk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gbGlzdFtpbmRleCsrXTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciBhZGRHZXR0ZXIgPSBmdW5jdGlvbiAoaXQsIGtleSwgaW50ZXJuYWwpIHtcbiAgICBkUChpdCwga2V5LCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZFtpbnRlcm5hbF07IH0gfSk7XG4gIH07XG5cbiAgdmFyICRmcm9tID0gZnVuY3Rpb24gZnJvbShzb3VyY2UgLyogLCBtYXBmbiwgdGhpc0FyZyAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3Qoc291cmNlKTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIG1hcGZuID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGksIGxlbmd0aCwgdmFsdWVzLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmIChpdGVyRm4gIT0gdW5kZWZpbmVkICYmICFpc0FycmF5SXRlcihpdGVyRm4pKSB7XG4gICAgICBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHZhbHVlcyA9IFtdLCBpID0gMDsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpKyspIHtcbiAgICAgICAgdmFsdWVzLnB1c2goc3RlcC52YWx1ZSk7XG4gICAgICB9IE8gPSB2YWx1ZXM7XG4gICAgfVxuICAgIGlmIChtYXBwaW5nICYmIGFMZW4gPiAyKSBtYXBmbiA9IGN0eChtYXBmbiwgYXJndW1lbnRzWzJdLCAyKTtcbiAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCksIHJlc3VsdCA9IGFsbG9jYXRlKHRoaXMsIGxlbmd0aCk7IGxlbmd0aCA+IGk7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gbWFwcGluZyA/IG1hcGZuKE9baV0sIGkpIDogT1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgJG9mID0gZnVuY3Rpb24gb2YoLyogLi4uaXRlbXMgKi8pIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBhbGxvY2F0ZSh0aGlzLCBsZW5ndGgpO1xuICAgIHdoaWxlIChsZW5ndGggPiBpbmRleCkgcmVzdWx0W2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleCsrXTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIGlPUyBTYWZhcmkgNi54IGZhaWxzIGhlcmVcbiAgdmFyIFRPX0xPQ0FMRV9CVUcgPSAhIVVpbnQ4QXJyYXkgJiYgZmFpbHMoZnVuY3Rpb24gKCkgeyBhcnJheVRvTG9jYWxlU3RyaW5nLmNhbGwobmV3IFVpbnQ4QXJyYXkoMSkpOyB9KTtcblxuICB2YXIgJHRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gdG9Mb2NhbGVTdHJpbmcoKSB7XG4gICAgcmV0dXJuIGFycmF5VG9Mb2NhbGVTdHJpbmcuYXBwbHkoVE9fTE9DQUxFX0JVRyA/IGFycmF5U2xpY2UuY2FsbCh2YWxpZGF0ZSh0aGlzKSkgOiB2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgfTtcblxuICB2YXIgcHJvdG8gPSB7XG4gICAgY29weVdpdGhpbjogZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0IC8qICwgZW5kICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlDb3B5V2l0aGluLmNhbGwodmFsaWRhdGUodGhpcyksIHRhcmdldCwgc3RhcnQsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIGFycmF5RXZlcnkodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZpbGw6IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyogLCBzdGFydCwgZW5kICovKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUZpbGwuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheUZpbHRlcih2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbixcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpKTtcbiAgICB9LFxuICAgIGZpbmQ6IGZ1bmN0aW9uIGZpbmQocHJlZGljYXRlIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgcmV0dXJuIGFycmF5RmluZCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChwcmVkaWNhdGUgLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlGaW5kSW5kZXgodmFsaWRhdGUodGhpcyksIHByZWRpY2F0ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgICAgYXJyYXlGb3JFYWNoKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggKi8pIHtcbiAgICAgIHJldHVybiBhcnJheUluZGV4T2YodmFsaWRhdGUodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7XG4gICAgICByZXR1cm4gYXJyYXlJbmNsdWRlcyh2YWxpZGF0ZSh0aGlzKSwgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5Sm9pbi5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUxhc3RJbmRleE9mLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgbWFwOiBmdW5jdGlvbiBtYXAobWFwZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgICByZXR1cm4gJG1hcCh2YWxpZGF0ZSh0aGlzKSwgbWFwZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlUmlnaHQuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdmFyIGxlbmd0aCA9IHZhbGlkYXRlKHRoYXQpLmxlbmd0aDtcbiAgICAgIHZhciBtaWRkbGUgPSBNYXRoLmZsb29yKGxlbmd0aCAvIDIpO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIHdoaWxlIChpbmRleCA8IG1pZGRsZSkge1xuICAgICAgICB2YWx1ZSA9IHRoYXRbaW5kZXhdO1xuICAgICAgICB0aGF0W2luZGV4KytdID0gdGhhdFstLWxlbmd0aF07XG4gICAgICAgIHRoYXRbbGVuZ3RoXSA9IHZhbHVlO1xuICAgICAgfSByZXR1cm4gdGhhdDtcbiAgICB9LFxuICAgIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICAgIHJldHVybiBhcnJheVNvbWUodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZWZuKSB7XG4gICAgICByZXR1cm4gYXJyYXlTb3J0LmNhbGwodmFsaWRhdGUodGhpcyksIGNvbXBhcmVmbik7XG4gICAgfSxcbiAgICBzdWJhcnJheTogZnVuY3Rpb24gc3ViYXJyYXkoYmVnaW4sIGVuZCkge1xuICAgICAgdmFyIE8gPSB2YWxpZGF0ZSh0aGlzKTtcbiAgICAgIHZhciBsZW5ndGggPSBPLmxlbmd0aDtcbiAgICAgIHZhciAkYmVnaW4gPSB0b0Fic29sdXRlSW5kZXgoYmVnaW4sIGxlbmd0aCk7XG4gICAgICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSkoXG4gICAgICAgIE8uYnVmZmVyLFxuICAgICAgICBPLmJ5dGVPZmZzZXQgKyAkYmVnaW4gKiBPLkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICB0b0xlbmd0aCgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW5ndGgpKSAtICRiZWdpbilcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIHZhciAkc2xpY2UgPSBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcyksIHN0YXJ0LCBlbmQpKTtcbiAgfTtcblxuICB2YXIgJHNldCA9IGZ1bmN0aW9uIHNldChhcnJheUxpa2UgLyogLCBvZmZzZXQgKi8pIHtcbiAgICB2YWxpZGF0ZSh0aGlzKTtcbiAgICB2YXIgb2Zmc2V0ID0gdG9PZmZzZXQoYXJndW1lbnRzWzFdLCAxKTtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgdmFyIHNyYyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKHNyYy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgaWYgKGxlbiArIG9mZnNldCA+IGxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHdoaWxlIChpbmRleCA8IGxlbikgdGhpc1tvZmZzZXQgKyBpbmRleF0gPSBzcmNbaW5kZXgrK107XG4gIH07XG5cbiAgdmFyICRpdGVyYXRvcnMgPSB7XG4gICAgZW50cmllczogZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICAgIHJldHVybiBhcnJheUVudHJpZXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfSxcbiAgICBrZXlzOiBmdW5jdGlvbiBrZXlzKCkge1xuICAgICAgcmV0dXJuIGFycmF5S2V5cy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9LFxuICAgIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgcmV0dXJuIGFycmF5VmFsdWVzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNUQUluZGV4ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHRhcmdldClcbiAgICAgICYmIHRhcmdldFtUWVBFRF9BUlJBWV1cbiAgICAgICYmIHR5cGVvZiBrZXkgIT0gJ3N5bWJvbCdcbiAgICAgICYmIGtleSBpbiB0YXJnZXRcbiAgICAgICYmIFN0cmluZygra2V5KSA9PSBTdHJpbmcoa2V5KTtcbiAgfTtcbiAgdmFyICRnZXREZXNjID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSB7XG4gICAgcmV0dXJuIGlzVEFJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpXG4gICAgICA/IHByb3BlcnR5RGVzYygyLCB0YXJnZXRba2V5XSlcbiAgICAgIDogZ09QRCh0YXJnZXQsIGtleSk7XG4gIH07XG4gIHZhciAkc2V0RGVzYyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgaWYgKGlzVEFJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpXG4gICAgICAmJiBpc09iamVjdChkZXNjKVxuICAgICAgJiYgaGFzKGRlc2MsICd2YWx1ZScpXG4gICAgICAmJiAhaGFzKGRlc2MsICdnZXQnKVxuICAgICAgJiYgIWhhcyhkZXNjLCAnc2V0JylcbiAgICAgIC8vIFRPRE86IGFkZCB2YWxpZGF0aW9uIGRlc2NyaXB0b3Igdy9vIGNhbGxpbmcgYWNjZXNzb3JzXG4gICAgICAmJiAhZGVzYy5jb25maWd1cmFibGVcbiAgICAgICYmICghaGFzKGRlc2MsICd3cml0YWJsZScpIHx8IGRlc2Mud3JpdGFibGUpXG4gICAgICAmJiAoIWhhcyhkZXNjLCAnZW51bWVyYWJsZScpIHx8IGRlc2MuZW51bWVyYWJsZSlcbiAgICApIHtcbiAgICAgIHRhcmdldFtrZXldID0gZGVzYy52YWx1ZTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSByZXR1cm4gZFAodGFyZ2V0LCBrZXksIGRlc2MpO1xuICB9O1xuXG4gIGlmICghQUxMX0NPTlNUUlVDVE9SUykge1xuICAgICRHT1BELmYgPSAkZ2V0RGVzYztcbiAgICAkRFAuZiA9ICRzZXREZXNjO1xuICB9XG5cbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhQUxMX0NPTlNUUlVDVE9SUywgJ09iamVjdCcsIHtcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXREZXNjLFxuICAgIGRlZmluZVByb3BlcnR5OiAkc2V0RGVzY1xuICB9KTtcblxuICBpZiAoZmFpbHMoZnVuY3Rpb24gKCkgeyBhcnJheVRvU3RyaW5nLmNhbGwoe30pOyB9KSkge1xuICAgIGFycmF5VG9TdHJpbmcgPSBhcnJheVRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYXJyYXlKb2luLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciAkVHlwZWRBcnJheVByb3RvdHlwZSQgPSByZWRlZmluZUFsbCh7fSwgcHJvdG8pO1xuICByZWRlZmluZUFsbCgkVHlwZWRBcnJheVByb3RvdHlwZSQsICRpdGVyYXRvcnMpO1xuICBoaWRlKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgSVRFUkFUT1IsICRpdGVyYXRvcnMudmFsdWVzKTtcbiAgcmVkZWZpbmVBbGwoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCB7XG4gICAgc2xpY2U6ICRzbGljZSxcbiAgICBzZXQ6ICRzZXQsXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHsgLyogbm9vcCAqLyB9LFxuICAgIHRvU3RyaW5nOiBhcnJheVRvU3RyaW5nLFxuICAgIHRvTG9jYWxlU3RyaW5nOiAkdG9Mb2NhbGVTdHJpbmdcbiAgfSk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdidWZmZXInLCAnYicpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnl0ZU9mZnNldCcsICdvJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdieXRlTGVuZ3RoJywgJ2wnKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2xlbmd0aCcsICdlJyk7XG4gIGRQKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgVEFHLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzW1RZUEVEX0FSUkFZXTsgfVxuICB9KTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBCWVRFUywgd3JhcHBlciwgQ0xBTVBFRCkge1xuICAgIENMQU1QRUQgPSAhIUNMQU1QRUQ7XG4gICAgdmFyIE5BTUUgPSBLRVkgKyAoQ0xBTVBFRCA/ICdDbGFtcGVkJyA6ICcnKSArICdBcnJheSc7XG4gICAgdmFyIEdFVFRFUiA9ICdnZXQnICsgS0VZO1xuICAgIHZhciBTRVRURVIgPSAnc2V0JyArIEtFWTtcbiAgICB2YXIgVHlwZWRBcnJheSA9IGdsb2JhbFtOQU1FXTtcbiAgICB2YXIgQmFzZSA9IFR5cGVkQXJyYXkgfHwge307XG4gICAgdmFyIFRBQyA9IFR5cGVkQXJyYXkgJiYgZ2V0UHJvdG90eXBlT2YoVHlwZWRBcnJheSk7XG4gICAgdmFyIEZPUkNFRCA9ICFUeXBlZEFycmF5IHx8ICEkdHlwZWQuQUJWO1xuICAgIHZhciBPID0ge307XG4gICAgdmFyIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5ICYmIFR5cGVkQXJyYXlbUFJPVE9UWVBFXTtcbiAgICB2YXIgZ2V0dGVyID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoYXQuX2Q7XG4gICAgICByZXR1cm4gZGF0YS52W0dFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEubywgTElUVExFX0VORElBTik7XG4gICAgfTtcbiAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGF0Ll9kO1xuICAgICAgaWYgKENMQU1QRUQpIHZhbHVlID0gKHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSkpIDwgMCA/IDAgOiB2YWx1ZSA+IDB4ZmYgPyAweGZmIDogdmFsdWUgJiAweGZmO1xuICAgICAgZGF0YS52W1NFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEubywgdmFsdWUsIExJVFRMRV9FTkRJQU4pO1xuICAgIH07XG4gICAgdmFyIGFkZEVsZW1lbnQgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgpIHtcbiAgICAgIGRQKHRoYXQsIGluZGV4LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBnZXR0ZXIodGhpcywgaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBzZXR0ZXIodGhpcywgaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSB7XG4gICAgICBUeXBlZEFycmF5ID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgZGF0YSwgJG9mZnNldCwgJGxlbmd0aCkge1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXksIE5BTUUsICdfZCcpO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIGJ1ZmZlciwgYnl0ZUxlbmd0aCwgbGVuZ3RoLCBrbGFzcztcbiAgICAgICAgaWYgKCFpc09iamVjdChkYXRhKSkge1xuICAgICAgICAgIGxlbmd0aCA9IHRvSW5kZXgoZGF0YSk7XG4gICAgICAgICAgYnl0ZUxlbmd0aCA9IGxlbmd0aCAqIEJZVEVTO1xuICAgICAgICAgIGJ1ZmZlciA9IG5ldyAkQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mICRBcnJheUJ1ZmZlciB8fCAoa2xhc3MgPSBjbGFzc29mKGRhdGEpKSA9PSBBUlJBWV9CVUZGRVIgfHwga2xhc3MgPT0gU0hBUkVEX0JVRkZFUikge1xuICAgICAgICAgIGJ1ZmZlciA9IGRhdGE7XG4gICAgICAgICAgb2Zmc2V0ID0gdG9PZmZzZXQoJG9mZnNldCwgQllURVMpO1xuICAgICAgICAgIHZhciAkbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGlmICgkbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICgkbGVuICUgQllURVMpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSAkbGVuIC0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggPCAwKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSB0b0xlbmd0aCgkbGVuZ3RoKSAqIEJZVEVTO1xuICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggKyBvZmZzZXQgPiAkbGVuKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbmd0aCA9IGJ5dGVMZW5ndGggLyBCWVRFUztcbiAgICAgICAgfSBlbHNlIGlmIChUWVBFRF9BUlJBWSBpbiBkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGhpZGUodGhhdCwgJ19kJywge1xuICAgICAgICAgIGI6IGJ1ZmZlcixcbiAgICAgICAgICBvOiBvZmZzZXQsXG4gICAgICAgICAgbDogYnl0ZUxlbmd0aCxcbiAgICAgICAgICBlOiBsZW5ndGgsXG4gICAgICAgICAgdjogbmV3ICREYXRhVmlldyhidWZmZXIpXG4gICAgICAgIH0pO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIGFkZEVsZW1lbnQodGhhdCwgaW5kZXgrKyk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5W1BST1RPVFlQRV0gPSBjcmVhdGUoJFR5cGVkQXJyYXlQcm90b3R5cGUkKTtcbiAgICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgVHlwZWRBcnJheSk7XG4gICAgfSBlbHNlIGlmICghZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgVHlwZWRBcnJheSgxKTtcbiAgICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgbmV3IFR5cGVkQXJyYXkoLTEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH0pIHx8ICEkaXRlckRldGVjdChmdW5jdGlvbiAoaXRlcikge1xuICAgICAgbmV3IFR5cGVkQXJyYXkoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIG5ldyBUeXBlZEFycmF5KG51bGwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkoMS41KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIG5ldyBUeXBlZEFycmF5KGl0ZXIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH0sIHRydWUpKSB7XG4gICAgICBUeXBlZEFycmF5ID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgZGF0YSwgJG9mZnNldCwgJGxlbmd0aCkge1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXksIE5BTUUpO1xuICAgICAgICB2YXIga2xhc3M7XG4gICAgICAgIC8vIGB3c2AgbW9kdWxlIGJ1ZywgdGVtcG9yYXJpbHkgcmVtb3ZlIHZhbGlkYXRpb24gbGVuZ3RoIGZvciBVaW50OEFycmF5XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL3B1bGwvNjQ1XG4gICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHJldHVybiBuZXcgQmFzZSh0b0luZGV4KGRhdGEpKTtcbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiAkQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihkYXRhKSkgPT0gQVJSQVlfQlVGRkVSIHx8IGtsYXNzID09IFNIQVJFRF9CVUZGRVIpIHtcbiAgICAgICAgICByZXR1cm4gJGxlbmd0aCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IG5ldyBCYXNlKGRhdGEsIHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKSwgJGxlbmd0aClcbiAgICAgICAgICAgIDogJG9mZnNldCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpKVxuICAgICAgICAgICAgICA6IG5ldyBCYXNlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChUWVBFRF9BUlJBWSBpbiBkYXRhKSByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgfSk7XG4gICAgICBhcnJheUZvckVhY2goVEFDICE9PSBGdW5jdGlvbi5wcm90b3R5cGUgPyBnT1BOKEJhc2UpLmNvbmNhdChnT1BOKFRBQykpIDogZ09QTihCYXNlKSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gVHlwZWRBcnJheSkpIGhpZGUoVHlwZWRBcnJheSwga2V5LCBCYXNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5W1BST1RPVFlQRV0gPSBUeXBlZEFycmF5UHJvdG90eXBlO1xuICAgICAgaWYgKCFMSUJSQVJZKSBUeXBlZEFycmF5UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHlwZWRBcnJheTtcbiAgICB9XG4gICAgdmFyICRuYXRpdmVJdGVyYXRvciA9IFR5cGVkQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdO1xuICAgIHZhciBDT1JSRUNUX0lURVJfTkFNRSA9ICEhJG5hdGl2ZUl0ZXJhdG9yXG4gICAgICAmJiAoJG5hdGl2ZUl0ZXJhdG9yLm5hbWUgPT0gJ3ZhbHVlcycgfHwgJG5hdGl2ZUl0ZXJhdG9yLm5hbWUgPT0gdW5kZWZpbmVkKTtcbiAgICB2YXIgJGl0ZXJhdG9yID0gJGl0ZXJhdG9ycy52YWx1ZXM7XG4gICAgaGlkZShUeXBlZEFycmF5LCBUWVBFRF9DT05TVFJVQ1RPUiwgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBUWVBFRF9BUlJBWSwgTkFNRSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBWSUVXLCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIERFRl9DT05TVFJVQ1RPUiwgVHlwZWRBcnJheSk7XG5cbiAgICBpZiAoQ0xBTVBFRCA/IG5ldyBUeXBlZEFycmF5KDEpW1RBR10gIT0gTkFNRSA6ICEoVEFHIGluIFR5cGVkQXJyYXlQcm90b3R5cGUpKSB7XG4gICAgICBkUChUeXBlZEFycmF5UHJvdG90eXBlLCBUQUcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBOQU1FOyB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBPW05BTUVdID0gVHlwZWRBcnJheTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKFR5cGVkQXJyYXkgIT0gQmFzZSksIE8pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlMsIE5BTUUsIHtcbiAgICAgIEJZVEVTX1BFUl9FTEVNRU5UOiBCWVRFU1xuICAgIH0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7IEJhc2Uub2YuY2FsbChUeXBlZEFycmF5LCAxKTsgfSksIE5BTUUsIHtcbiAgICAgIGZyb206ICRmcm9tLFxuICAgICAgb2Y6ICRvZlxuICAgIH0pO1xuXG4gICAgaWYgKCEoQllURVNfUEVSX0VMRU1FTlQgaW4gVHlwZWRBcnJheVByb3RvdHlwZSkpIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgQllURVNfUEVSX0VMRU1FTlQsIEJZVEVTKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QLCBOQU1FLCBwcm90byk7XG5cbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBGT1JDRURfU0VULCBOQU1FLCB7IHNldDogJHNldCB9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIUNPUlJFQ1RfSVRFUl9OQU1FLCBOQU1FLCAkaXRlcmF0b3JzKTtcblxuICAgIGlmICghTElCUkFSWSAmJiBUeXBlZEFycmF5UHJvdG90eXBlLnRvU3RyaW5nICE9IGFycmF5VG9TdHJpbmcpIFR5cGVkQXJyYXlQcm90b3R5cGUudG9TdHJpbmcgPSBhcnJheVRvU3RyaW5nO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBuZXcgVHlwZWRBcnJheSgxKS5zbGljZSgpO1xuICAgIH0pLCBOQU1FLCB7IHNsaWNlOiAkc2xpY2UgfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gWzEsIDJdLnRvTG9jYWxlU3RyaW5nKCkgIT0gbmV3IFR5cGVkQXJyYXkoWzEsIDJdKS50b0xvY2FsZVN0cmluZygpO1xuICAgIH0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nLmNhbGwoWzEsIDJdKTtcbiAgICB9KSksIE5BTUUsIHsgdG9Mb2NhbGVTdHJpbmc6ICR0b0xvY2FsZVN0cmluZyB9KTtcblxuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IENPUlJFQ1RfSVRFUl9OQU1FID8gJG5hdGl2ZUl0ZXJhdG9yIDogJGl0ZXJhdG9yO1xuICAgIGlmICghTElCUkFSWSAmJiAhQ09SUkVDVF9JVEVSX05BTUUpIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgSVRFUkFUT1IsICRpdGVyYXRvcik7XG4gIH07XG59IGVsc2UgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgJHR5cGVkID0gcmVxdWlyZSgnLi9fdHlwZWQnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvSW5kZXggPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGFycmF5RmlsbCA9IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcbnZhciBEQVRBX1ZJRVcgPSAnRGF0YVZpZXcnO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIFdST05HX0xFTkdUSCA9ICdXcm9uZyBsZW5ndGghJztcbnZhciBXUk9OR19JTkRFWCA9ICdXcm9uZyBpbmRleCEnO1xudmFyICRBcnJheUJ1ZmZlciA9IGdsb2JhbFtBUlJBWV9CVUZGRVJdO1xudmFyICREYXRhVmlldyA9IGdsb2JhbFtEQVRBX1ZJRVddO1xudmFyIE1hdGggPSBnbG9iYWwuTWF0aDtcbnZhciBSYW5nZUVycm9yID0gZ2xvYmFsLlJhbmdlRXJyb3I7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93LXJlc3RyaWN0ZWQtbmFtZXNcbnZhciBJbmZpbml0eSA9IGdsb2JhbC5JbmZpbml0eTtcbnZhciBCYXNlQnVmZmVyID0gJEFycmF5QnVmZmVyO1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIHBvdyA9IE1hdGgucG93O1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBsb2cgPSBNYXRoLmxvZztcbnZhciBMTjIgPSBNYXRoLkxOMjtcbnZhciBCVUZGRVIgPSAnYnVmZmVyJztcbnZhciBCWVRFX0xFTkdUSCA9ICdieXRlTGVuZ3RoJztcbnZhciBCWVRFX09GRlNFVCA9ICdieXRlT2Zmc2V0JztcbnZhciAkQlVGRkVSID0gREVTQ1JJUFRPUlMgPyAnX2InIDogQlVGRkVSO1xudmFyICRMRU5HVEggPSBERVNDUklQVE9SUyA/ICdfbCcgOiBCWVRFX0xFTkdUSDtcbnZhciAkT0ZGU0VUID0gREVTQ1JJUFRPUlMgPyAnX28nIDogQllURV9PRkZTRVQ7XG5cbi8vIElFRUU3NTQgY29udmVyc2lvbnMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pZWVlNzU0XG5mdW5jdGlvbiBwYWNrSUVFRTc1NCh2YWx1ZSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobkJ5dGVzKTtcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBydCA9IG1MZW4gPT09IDIzID8gcG93KDIsIC0yNCkgLSBwb3coMiwgLTc3KSA6IDA7XG4gIHZhciBpID0gMDtcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCA/IDEgOiAwO1xuICB2YXIgZSwgbSwgYztcbiAgdmFsdWUgPSBhYnModmFsdWUpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIGlmICh2YWx1ZSAhPSB2YWx1ZSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgbSA9IHZhbHVlICE9IHZhbHVlID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IGZsb29yKGxvZyh2YWx1ZSkgLyBMTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gcG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIHBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBwb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBwb3coMiwgZUJpYXMgLSAxKSAqIHBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbaSsrXSA9IG0gJiAyNTUsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuICBlID0gZSA8PCBtTGVuIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltpKytdID0gZSAmIDI1NSwgZSAvPSAyNTYsIGVMZW4gLT0gOCk7XG4gIGJ1ZmZlclstLWldIHw9IHMgKiAxMjg7XG4gIHJldHVybiBidWZmZXI7XG59XG5mdW5jdGlvbiB1bnBhY2tJRUVFNzU0KGJ1ZmZlciwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgbkJpdHMgPSBlTGVuIC0gNztcbiAgdmFyIGkgPSBuQnl0ZXMgLSAxO1xuICB2YXIgcyA9IGJ1ZmZlcltpLS1dO1xuICB2YXIgZSA9IHMgJiAxMjc7XG4gIHZhciBtO1xuICBzID4+PSA3O1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltpXSwgaS0tLCBuQml0cyAtPSA4KTtcbiAgbSA9IGUgJiAoMSA8PCAtbkJpdHMpIC0gMTtcbiAgZSA+Pj0gLW5CaXRzO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltpXSwgaS0tLCBuQml0cyAtPSA4KTtcbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6IHMgPyAtSW5maW5pdHkgOiBJbmZpbml0eTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIHBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9IHJldHVybiAocyA/IC0xIDogMSkgKiBtICogcG93KDIsIGUgLSBtTGVuKTtcbn1cblxuZnVuY3Rpb24gdW5wYWNrSTMyKGJ5dGVzKSB7XG4gIHJldHVybiBieXRlc1szXSA8PCAyNCB8IGJ5dGVzWzJdIDw8IDE2IHwgYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xufVxuZnVuY3Rpb24gcGFja0k4KGl0KSB7XG4gIHJldHVybiBbaXQgJiAweGZmXTtcbn1cbmZ1bmN0aW9uIHBhY2tJMTYoaXQpIHtcbiAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmXTtcbn1cbmZ1bmN0aW9uIHBhY2tJMzIoaXQpIHtcbiAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmLCBpdCA+PiAxNiAmIDB4ZmYsIGl0ID4+IDI0ICYgMHhmZl07XG59XG5mdW5jdGlvbiBwYWNrRjY0KGl0KSB7XG4gIHJldHVybiBwYWNrSUVFRTc1NChpdCwgNTIsIDgpO1xufVxuZnVuY3Rpb24gcGFja0YzMihpdCkge1xuICByZXR1cm4gcGFja0lFRUU3NTQoaXQsIDIzLCA0KTtcbn1cblxuZnVuY3Rpb24gYWRkR2V0dGVyKEMsIGtleSwgaW50ZXJuYWwpIHtcbiAgZFAoQ1tQUk9UT1RZUEVdLCBrZXksIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzW2ludGVybmFsXTsgfSB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0KHZpZXcsIGJ5dGVzLCBpbmRleCwgaXNMaXR0bGVFbmRpYW4pIHtcbiAgdmFyIG51bUluZGV4ID0gK2luZGV4O1xuICB2YXIgaW50SW5kZXggPSB0b0luZGV4KG51bUluZGV4KTtcbiAgaWYgKGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0lOREVYKTtcbiAgdmFyIHN0b3JlID0gdmlld1skQlVGRkVSXS5fYjtcbiAgdmFyIHN0YXJ0ID0gaW50SW5kZXggKyB2aWV3WyRPRkZTRVRdO1xuICB2YXIgcGFjayA9IHN0b3JlLnNsaWNlKHN0YXJ0LCBzdGFydCArIGJ5dGVzKTtcbiAgcmV0dXJuIGlzTGl0dGxlRW5kaWFuID8gcGFjayA6IHBhY2sucmV2ZXJzZSgpO1xufVxuZnVuY3Rpb24gc2V0KHZpZXcsIGJ5dGVzLCBpbmRleCwgY29udmVyc2lvbiwgdmFsdWUsIGlzTGl0dGxlRW5kaWFuKSB7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleDtcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleChudW1JbmRleCk7XG4gIGlmIChpbnRJbmRleCArIGJ5dGVzID4gdmlld1skTEVOR1RIXSkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBzdG9yZSA9IHZpZXdbJEJVRkZFUl0uX2I7XG4gIHZhciBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXTtcbiAgdmFyIHBhY2sgPSBjb252ZXJzaW9uKCt2YWx1ZSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXM7IGkrKykgc3RvcmVbc3RhcnQgKyBpXSA9IHBhY2tbaXNMaXR0bGVFbmRpYW4gPyBpIDogYnl0ZXMgLSBpIC0gMV07XG59XG5cbmlmICghJHR5cGVkLkFCVikge1xuICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbiAgICB2YXIgYnl0ZUxlbmd0aCA9IHRvSW5kZXgobGVuZ3RoKTtcbiAgICB0aGlzLl9iID0gYXJyYXlGaWxsLmNhbGwobmV3IEFycmF5KGJ5dGVMZW5ndGgpLCAwKTtcbiAgICB0aGlzWyRMRU5HVEhdID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICAkRGF0YVZpZXcgPSBmdW5jdGlvbiBEYXRhVmlldyhidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICREYXRhVmlldywgREFUQV9WSUVXKTtcbiAgICBhbkluc3RhbmNlKGJ1ZmZlciwgJEFycmF5QnVmZmVyLCBEQVRBX1ZJRVcpO1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBidWZmZXJbJExFTkdUSF07XG4gICAgdmFyIG9mZnNldCA9IHRvSW50ZWdlcihieXRlT2Zmc2V0KTtcbiAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBidWZmZXJMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCEnKTtcbiAgICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gYnVmZmVyTGVuZ3RoIC0gb2Zmc2V0IDogdG9MZW5ndGgoYnl0ZUxlbmd0aCk7XG4gICAgaWYgKG9mZnNldCArIGJ5dGVMZW5ndGggPiBidWZmZXJMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICB0aGlzWyRCVUZGRVJdID0gYnVmZmVyO1xuICAgIHRoaXNbJE9GRlNFVF0gPSBvZmZzZXQ7XG4gICAgdGhpc1skTEVOR1RIXSA9IGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgaWYgKERFU0NSSVBUT1JTKSB7XG4gICAgYWRkR2V0dGVyKCRBcnJheUJ1ZmZlciwgQllURV9MRU5HVEgsICdfbCcpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJVRkZFUiwgJ19iJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQllURV9MRU5HVEgsICdfbCcpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfT0ZGU0VULCAnX28nKTtcbiAgfVxuXG4gIHJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgZ2V0SW50ODogZnVuY3Rpb24gZ2V0SW50OChieXRlT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdIDw8IDI0ID4+IDI0O1xuICAgIH0sXG4gICAgZ2V0VWludDg6IGZ1bmN0aW9uIGdldFVpbnQ4KGJ5dGVPZmZzZXQpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF07XG4gICAgfSxcbiAgICBnZXRJbnQxNjogZnVuY3Rpb24gZ2V0SW50MTYoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gKGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXSkgPDwgMTYgPj4gMTY7XG4gICAgfSxcbiAgICBnZXRVaW50MTY6IGZ1bmN0aW9uIGdldFVpbnQxNihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKTtcbiAgICAgIHJldHVybiBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG4gICAgfSxcbiAgICBnZXRJbnQzMjogZnVuY3Rpb24gZ2V0SW50MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0kzMihnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSk7XG4gICAgfSxcbiAgICBnZXRVaW50MzI6IGZ1bmN0aW9uIGdldFVpbnQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSTMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKSA+Pj4gMDtcbiAgICB9LFxuICAgIGdldEZsb2F0MzI6IGZ1bmN0aW9uIGdldEZsb2F0MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSksIDIzLCA0KTtcbiAgICB9LFxuICAgIGdldEZsb2F0NjQ6IGZ1bmN0aW9uIGdldEZsb2F0NjQoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSksIDUyLCA4KTtcbiAgICB9LFxuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSTgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJOCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0SW50MTY6IGZ1bmN0aW9uIHNldEludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0kxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRVaW50MTY6IGZ1bmN0aW9uIHNldFVpbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJMTYsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0SW50MzI6IGZ1bmN0aW9uIHNldEludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0kzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRVaW50MzI6IGZ1bmN0aW9uIHNldFVpbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0RmxvYXQzMjogZnVuY3Rpb24gc2V0RmxvYXQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tGMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0RmxvYXQ2NDogZnVuY3Rpb24gc2V0RmxvYXQ2NChieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIHBhY2tGNjQsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBpZiAoIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAkQXJyYXlCdWZmZXIoMSk7XG4gIH0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3ICRBcnJheUJ1ZmZlcigtMSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gIH0pIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgJEFycmF5QnVmZmVyKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbmV3ICRBcnJheUJ1ZmZlcigxLjUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoTmFOKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICByZXR1cm4gJEFycmF5QnVmZmVyLm5hbWUgIT0gQVJSQVlfQlVGRkVSO1xuICB9KSkge1xuICAgICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCkge1xuICAgICAgYW5JbnN0YW5jZSh0aGlzLCAkQXJyYXlCdWZmZXIpO1xuICAgICAgcmV0dXJuIG5ldyBCYXNlQnVmZmVyKHRvSW5kZXgobGVuZ3RoKSk7XG4gICAgfTtcbiAgICB2YXIgQXJyYXlCdWZmZXJQcm90byA9ICRBcnJheUJ1ZmZlcltQUk9UT1RZUEVdID0gQmFzZUJ1ZmZlcltQUk9UT1RZUEVdO1xuICAgIGZvciAodmFyIGtleXMgPSBnT1BOKEJhc2VCdWZmZXIpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7KSB7XG4gICAgICBpZiAoISgoa2V5ID0ga2V5c1tqKytdKSBpbiAkQXJyYXlCdWZmZXIpKSBoaWRlKCRBcnJheUJ1ZmZlciwga2V5LCBCYXNlQnVmZmVyW2tleV0pO1xuICAgIH1cbiAgICBpZiAoIUxJQlJBUlkpIEFycmF5QnVmZmVyUHJvdG8uY29uc3RydWN0b3IgPSAkQXJyYXlCdWZmZXI7XG4gIH1cbiAgLy8gaU9TIFNhZmFyaSA3LnggYnVnXG4gIHZhciB2aWV3ID0gbmV3ICREYXRhVmlldyhuZXcgJEFycmF5QnVmZmVyKDIpKTtcbiAgdmFyICRzZXRJbnQ4ID0gJERhdGFWaWV3W1BST1RPVFlQRV0uc2V0SW50ODtcbiAgdmlldy5zZXRJbnQ4KDAsIDIxNDc0ODM2NDgpO1xuICB2aWV3LnNldEludDgoMSwgMjE0NzQ4MzY0OSk7XG4gIGlmICh2aWV3LmdldEludDgoMCkgfHwgIXZpZXcuZ2V0SW50OCgxKSkgcmVkZWZpbmVBbGwoJERhdGFWaWV3W1BST1RPVFlQRV0sIHtcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICAkc2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfVxuICB9LCB0cnVlKTtcbn1cbnNldFRvU3RyaW5nVGFnKCRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbnNldFRvU3RyaW5nVGFnKCREYXRhVmlldywgREFUQV9WSUVXKTtcbmhpZGUoJERhdGFWaWV3W1BST1RPVFlQRV0sICR0eXBlZC5WSUVXLCB0cnVlKTtcbmV4cG9ydHNbQVJSQVlfQlVGRkVSXSA9ICRBcnJheUJ1ZmZlcjtcbmV4cG9ydHNbREFUQV9WSUVXXSA9ICREYXRhVmlldztcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFRZUEVEID0gdWlkKCd0eXBlZF9hcnJheScpO1xudmFyIFZJRVcgPSB1aWQoJ3ZpZXcnKTtcbnZhciBBQlYgPSAhIShnbG9iYWwuQXJyYXlCdWZmZXIgJiYgZ2xvYmFsLkRhdGFWaWV3KTtcbnZhciBDT05TVFIgPSBBQlY7XG52YXIgaSA9IDA7XG52YXIgbCA9IDk7XG52YXIgVHlwZWQ7XG5cbnZhciBUeXBlZEFycmF5Q29uc3RydWN0b3JzID0gKFxuICAnSW50OEFycmF5LFVpbnQ4QXJyYXksVWludDhDbGFtcGVkQXJyYXksSW50MTZBcnJheSxVaW50MTZBcnJheSxJbnQzMkFycmF5LFVpbnQzMkFycmF5LEZsb2F0MzJBcnJheSxGbG9hdDY0QXJyYXknXG4pLnNwbGl0KCcsJyk7XG5cbndoaWxlIChpIDwgbCkge1xuICBpZiAoVHlwZWQgPSBnbG9iYWxbVHlwZWRBcnJheUNvbnN0cnVjdG9yc1tpKytdXSkge1xuICAgIGhpZGUoVHlwZWQucHJvdG90eXBlLCBUWVBFRCwgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZC5wcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICB9IGVsc2UgQ09OU1RSID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBBQlY6IEFCVixcbiAgQ09OU1RSOiBDT05TVFIsXG4gIFRZUEVEOiBUWVBFRCxcbiAgVklFVzogVklFV1xufTtcbiIsInZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIG5hdmlnYXRvciA9IGdsb2JhbC5uYXZpZ2F0b3I7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJyc7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBUWVBFKSB7XG4gIGlmICghaXNPYmplY3QoaXQpIHx8IGl0Ll90ICE9PSBUWVBFKSB0aHJvdyBUeXBlRXJyb3IoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkIScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pO1xuICBpZiAobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSkgZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwgeyB2YWx1ZTogd2tzRXh0LmYobmFtZSkgfSk7XG59O1xuIiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7XG4iLCJ2YXIgc3RvcmUgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sO1xudmFyIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG4iLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcbiIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHsgY29weVdpdGhpbjogcmVxdWlyZSgnLi9fYXJyYXktY29weS13aXRoaW4nKSB9KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2NvcHlXaXRoaW4nKTtcbiIsIi8vIDIyLjEuMy42IEFycmF5LnByb3RvdHlwZS5maWxsKHZhbHVlLCBzdGFydCA9IDAsIGVuZCA9IHRoaXMubGVuZ3RoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHsgZmlsbDogcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpIH0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnZmlsbCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjkgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRmaW5kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDYpO1xudmFyIEtFWSA9ICdmaW5kSW5kZXgnO1xudmFyIGZvcmNlZCA9IHRydWU7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYgKEtFWSBpbiBbXSkgQXJyYXkoMSlbS0VZXShmdW5jdGlvbiAoKSB7IGZvcmNlZCA9IGZhbHNlOyB9KTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZm9yY2VkLCAnQXJyYXknLCB7XG4gIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKShLRVkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjggQXJyYXkucHJvdG90eXBlLmZpbmQocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkZmluZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg1KTtcbnZhciBLRVkgPSAnZmluZCc7XG52YXIgZm9yY2VkID0gdHJ1ZTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZiAoS0VZIGluIFtdKSBBcnJheSgxKVtLRVldKGZ1bmN0aW9uICgpIHsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZDogZnVuY3Rpb24gZmluZChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoS0VZKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24gKGl0ZXIpIHsgQXJyYXkuZnJvbShpdGVyKTsgfSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjEgQXJyYXkuZnJvbShhcnJheUxpa2UsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICBmcm9tOiBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZSAvKiAsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdChhcnJheUxpa2UpO1xuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIG1hcGZuID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGl0ZXJGbiA9IGdldEl0ZXJGbihPKTtcbiAgICB2YXIgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmIChtYXBwaW5nKSBtYXBmbiA9IGN0eChtYXBmbiwgYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpO1xuICAgIC8vIGlmIG9iamVjdCBpc24ndCBpdGVyYWJsZSBvciBpdCdzIGFycmF5IHdpdGggZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBzaW1wbGUgY2FzZVxuICAgIGlmIChpdGVyRm4gIT0gdW5kZWZpbmVkICYmICEoQyA9PSBBcnJheSAmJiBpc0FycmF5SXRlcihpdGVyRm4pKSkge1xuICAgICAgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQygpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4KyspIHtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICBmb3IgKHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBraW5kID0gdGhpcy5faztcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG4vLyBXZWJLaXQgQXJyYXkub2YgaXNuJ3QgZ2VuZXJpY1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gIShBcnJheS5vZi5jYWxsKEYpIGluc3RhbmNlb2YgRik7XG59KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMyBBcnJheS5vZiggLi4uaXRlbXMpXG4gIG9mOiBmdW5jdGlvbiBvZigvKiAuLi5hcmdzICovKSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyAodHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheSkoYUxlbik7XG4gICAgd2hpbGUgKGFMZW4gPiBpbmRleCkgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICByZXN1bHQubGVuZ3RoID0gYUxlbjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgRlByb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIG5hbWVSRSA9IC9eXFxzKmZ1bmN0aW9uIChbXiAoXSopLztcbnZhciBOQU1FID0gJ25hbWUnO1xuXG4vLyAxOS4yLjQuMiBuYW1lXG5OQU1FIGluIEZQcm90byB8fCByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmIGRQKEZQcm90bywgTkFNRSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKCcnICsgdGhpcykubWF0Y2gobmFtZVJFKVsxXTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIE1BUCA9ICdNYXAnO1xuXG4vLyAyMy4xIE1hcCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShNQVAsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIE1hcCgpIHsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjEuMy42IE1hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gc3Ryb25nLmdldEVudHJ5KHZhbGlkYXRlKHRoaXMsIE1BUCksIGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnY7XG4gIH0sXG4gIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih2YWxpZGF0ZSh0aGlzLCBNQVApLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZywgdHJ1ZSk7XG4iLCIvLyAyMC4yLjIuMyBNYXRoLmFjb3NoKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGxvZzFwID0gcmVxdWlyZSgnLi9fbWF0aC1sb2cxcCcpO1xudmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG52YXIgJGFjb3NoID0gTWF0aC5hY29zaDtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhY29zaFxuICAvLyBWOCBidWc6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zNTA5XG4gICYmIE1hdGguZmxvb3IoJGFjb3NoKE51bWJlci5NQVhfVkFMVUUpKSA9PSA3MTBcbiAgLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmFjb3NoKEluZmluaXR5KSAtPiBOYU5cbiAgJiYgJGFjb3NoKEluZmluaXR5KSA9PSBJbmZpbml0eVxuKSwgJ01hdGgnLCB7XG4gIGFjb3NoOiBmdW5jdGlvbiBhY29zaCh4KSB7XG4gICAgcmV0dXJuICh4ID0gK3gpIDwgMSA/IE5hTiA6IHggPiA5NDkwNjI2NS42MjQyNTE1NlxuICAgICAgPyBNYXRoLmxvZyh4KSArIE1hdGguTE4yXG4gICAgICA6IGxvZzFwKHggLSAxICsgc3FydCh4IC0gMSkgKiBzcXJ0KHggKyAxKSk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjUgTWF0aC5hc2luaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkYXNpbmggPSBNYXRoLmFzaW5oO1xuXG5mdW5jdGlvbiBhc2luaCh4KSB7XG4gIHJldHVybiAhaXNGaW5pdGUoeCA9ICt4KSB8fCB4ID09IDAgPyB4IDogeCA8IDAgPyAtYXNpbmgoLXgpIDogTWF0aC5sb2coeCArIE1hdGguc3FydCh4ICogeCArIDEpKTtcbn1cblxuLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmFzaW5oKDApIC0+IC0wXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGFzaW5oICYmIDEgLyAkYXNpbmgoMCkgPiAwKSwgJ01hdGgnLCB7IGFzaW5oOiBhc2luaCB9KTtcbiIsIi8vIDIwLjIuMi43IE1hdGguYXRhbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGF0YW5oID0gTWF0aC5hdGFuaDtcblxuLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmF0YW5oKC0wKSAtPiAwXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGF0YW5oICYmIDEgLyAkYXRhbmgoLTApIDwgMCksICdNYXRoJywge1xuICBhdGFuaDogZnVuY3Rpb24gYXRhbmgoeCkge1xuICAgIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IE1hdGgubG9nKCgxICsgeCkgLyAoMSAtIHgpKSAvIDI7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjkgTWF0aC5jYnJ0KHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHNpZ24gPSByZXF1aXJlKCcuL19tYXRoLXNpZ24nKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjYnJ0OiBmdW5jdGlvbiBjYnJ0KHgpIHtcbiAgICByZXR1cm4gc2lnbih4ID0gK3gpICogTWF0aC5wb3coTWF0aC5hYnMoeCksIDEgLyAzKTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMTEgTWF0aC5jbHozMih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjbHozMjogZnVuY3Rpb24gY2x6MzIoeCkge1xuICAgIHJldHVybiAoeCA+Pj49IDApID8gMzEgLSBNYXRoLmZsb29yKE1hdGgubG9nKHggKyAwLjUpICogTWF0aC5MT0cyRSkgOiAzMjtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMTIgTWF0aC5jb3NoKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGV4cCA9IE1hdGguZXhwO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNvc2g6IGZ1bmN0aW9uIGNvc2goeCkge1xuICAgIHJldHVybiAoZXhwKHggPSAreCkgKyBleHAoLXgpKSAvIDI7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGV4cG0xID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICgkZXhwbTEgIT0gTWF0aC5leHBtMSksICdNYXRoJywgeyBleHBtMTogJGV4cG0xIH0pO1xuIiwiLy8gMjAuMi4yLjE2IE1hdGguZnJvdW5kKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7IGZyb3VuZDogcmVxdWlyZSgnLi9fbWF0aC1mcm91bmQnKSB9KTtcbiIsIi8vIDIwLjIuMi4xNyBNYXRoLmh5cG90KFt2YWx1ZTFbLCB2YWx1ZTJbLCDigKYgXV1dKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhYnMgPSBNYXRoLmFicztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBoeXBvdDogZnVuY3Rpb24gaHlwb3QodmFsdWUxLCB2YWx1ZTIpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciBzdW0gPSAwO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGxhcmcgPSAwO1xuICAgIHZhciBhcmcsIGRpdjtcbiAgICB3aGlsZSAoaSA8IGFMZW4pIHtcbiAgICAgIGFyZyA9IGFicyhhcmd1bWVudHNbaSsrXSk7XG4gICAgICBpZiAobGFyZyA8IGFyZykge1xuICAgICAgICBkaXYgPSBsYXJnIC8gYXJnO1xuICAgICAgICBzdW0gPSBzdW0gKiBkaXYgKiBkaXYgKyAxO1xuICAgICAgICBsYXJnID0gYXJnO1xuICAgICAgfSBlbHNlIGlmIChhcmcgPiAwKSB7XG4gICAgICAgIGRpdiA9IGFyZyAvIGxhcmc7XG4gICAgICAgIHN1bSArPSBkaXYgKiBkaXY7XG4gICAgICB9IGVsc2Ugc3VtICs9IGFyZztcbiAgICB9XG4gICAgcmV0dXJuIGxhcmcgPT09IEluZmluaXR5ID8gSW5maW5pdHkgOiBsYXJnICogTWF0aC5zcXJ0KHN1bSk7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjE4IE1hdGguaW11bCh4LCB5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkaW11bCA9IE1hdGguaW11bDtcblxuLy8gc29tZSBXZWJLaXQgdmVyc2lvbnMgZmFpbHMgd2l0aCBiaWcgbnVtYmVycywgc29tZSBoYXMgd3JvbmcgYXJpdHlcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAkaW11bCgweGZmZmZmZmZmLCA1KSAhPSAtNSB8fCAkaW11bC5sZW5ndGggIT0gMjtcbn0pLCAnTWF0aCcsIHtcbiAgaW11bDogZnVuY3Rpb24gaW11bCh4LCB5KSB7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZjtcbiAgICB2YXIgeG4gPSAreDtcbiAgICB2YXIgeW4gPSAreTtcbiAgICB2YXIgeGwgPSBVSU5UMTYgJiB4bjtcbiAgICB2YXIgeWwgPSBVSU5UMTYgJiB5bjtcbiAgICByZXR1cm4gMCB8IHhsICogeWwgKyAoKFVJTlQxNiAmIHhuID4+PiAxNikgKiB5bCArIHhsICogKFVJTlQxNiAmIHluID4+PiAxNikgPDwgMTYgPj4+IDApO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4yMSBNYXRoLmxvZzEwKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGxvZzEwOiBmdW5jdGlvbiBsb2cxMCh4KSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpICogTWF0aC5MT0cxMEU7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjIwIE1hdGgubG9nMXAoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgbG9nMXA6IHJlcXVpcmUoJy4vX21hdGgtbG9nMXAnKSB9KTtcbiIsIi8vIDIwLjIuMi4yMiBNYXRoLmxvZzIoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgbG9nMjogZnVuY3Rpb24gbG9nMih4KSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjI7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywgeyBzaWduOiByZXF1aXJlKCcuL19tYXRoLXNpZ24nKSB9KTtcbiIsIi8vIDIwLjIuMi4zMCBNYXRoLnNpbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZXhwbTEgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJyk7XG52YXIgZXhwID0gTWF0aC5leHA7XG5cbi8vIFY4IG5lYXIgQ2hyb21pdW0gMzggaGFzIGEgcHJvYmxlbSB3aXRoIHZlcnkgc21hbGwgbnVtYmVyc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICFNYXRoLnNpbmgoLTJlLTE3KSAhPSAtMmUtMTc7XG59KSwgJ01hdGgnLCB7XG4gIHNpbmg6IGZ1bmN0aW9uIHNpbmgoeCkge1xuICAgIHJldHVybiBNYXRoLmFicyh4ID0gK3gpIDwgMVxuICAgICAgPyAoZXhwbTEoeCkgLSBleHBtMSgteCkpIC8gMlxuICAgICAgOiAoZXhwKHggLSAxKSAtIGV4cCgteCAtIDEpKSAqIChNYXRoLkUgLyAyKTtcbiAgfVxufSk7XG4iLCIvLyAyMC4yLjIuMzMgTWF0aC50YW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGV4cG0xID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpO1xudmFyIGV4cCA9IE1hdGguZXhwO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHRhbmg6IGZ1bmN0aW9uIHRhbmgoeCkge1xuICAgIHZhciBhID0gZXhwbTEoeCA9ICt4KTtcbiAgICB2YXIgYiA9IGV4cG0xKC14KTtcbiAgICByZXR1cm4gYSA9PSBJbmZpbml0eSA/IDEgOiBiID09IEluZmluaXR5ID8gLTEgOiAoYSAtIGIpIC8gKGV4cCh4KSArIGV4cCgteCkpO1xuICB9XG59KTtcbiIsIi8vIDIwLjIuMi4zNCBNYXRoLnRydW5jKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHRydW5jOiBmdW5jdGlvbiB0cnVuYyhpdCkge1xuICAgIHJldHVybiAoaXQgPiAwID8gTWF0aC5mbG9vciA6IE1hdGguY2VpbCkoaXQpO1xuICB9XG59KTtcbiIsIi8vIDIwLjEuMi4xIE51bWJlci5FUFNJTE9OXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHsgRVBTSUxPTjogTWF0aC5wb3coMiwgLTUyKSB9KTtcbiIsIi8vIDIwLjEuMi4yIE51bWJlci5pc0Zpbml0ZShudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIF9pc0Zpbml0ZSA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmlzRmluaXRlO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNGaW5pdGU6IGZ1bmN0aW9uIGlzRmluaXRlKGl0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnbnVtYmVyJyAmJiBfaXNGaW5pdGUoaXQpO1xuICB9XG59KTtcbiIsIi8vIDIwLjEuMi4zIE51bWJlci5pc0ludGVnZXIobnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7IGlzSW50ZWdlcjogcmVxdWlyZSgnLi9faXMtaW50ZWdlcicpIH0pO1xuIiwiLy8gMjAuMS4yLjQgTnVtYmVyLmlzTmFOKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc05hTjogZnVuY3Rpb24gaXNOYU4obnVtYmVyKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHJldHVybiBudW1iZXIgIT0gbnVtYmVyO1xuICB9XG59KTtcbiIsIi8vIDIwLjEuMi41IE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaXNJbnRlZ2VyID0gcmVxdWlyZSgnLi9faXMtaW50ZWdlcicpO1xudmFyIGFicyA9IE1hdGguYWJzO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNTYWZlSW50ZWdlcjogZnVuY3Rpb24gaXNTYWZlSW50ZWdlcihudW1iZXIpIHtcbiAgICByZXR1cm4gaXNJbnRlZ2VyKG51bWJlcikgJiYgYWJzKG51bWJlcikgPD0gMHgxZmZmZmZmZmZmZmZmZjtcbiAgfVxufSk7XG4iLCIvLyAyMC4xLjIuNiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7IE1BWF9TQUZFX0lOVEVHRVI6IDB4MWZmZmZmZmZmZmZmZmYgfSk7XG4iLCIvLyAyMC4xLjIuMTAgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBNSU5fU0FGRV9JTlRFR0VSOiAtMHgxZmZmZmZmZmZmZmZmZiB9KTtcbiIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHsgYXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJykgfSk7XG4iLCIvLyAxOS4xLjIuNSBPYmplY3QuZnJlZXplKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2ZyZWV6ZScsIGZ1bmN0aW9uICgkZnJlZXplKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmcmVlemUoaXQpIHtcbiAgICByZXR1cm4gJGZyZWV6ZSAmJiBpc09iamVjdChpdCkgPyAkZnJlZXplKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0b0lPYmplY3QoaXQpLCBrZXkpO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eU5hbWVzJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0JykuZjtcbn0pO1xuIiwiLy8gMTkuMS4yLjkgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciAkZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0UHJvdG90eXBlT2YnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCkge1xuICAgIHJldHVybiAkZ2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjExIE9iamVjdC5pc0V4dGVuc2libGUoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzRXh0ZW5zaWJsZScsIGZ1bmN0aW9uICgkaXNFeHRlbnNpYmxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpc0V4dGVuc2libGUoaXQpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUoaXQpIDogdHJ1ZSA6IGZhbHNlO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuMTIgT2JqZWN0LmlzRnJvemVuKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc0Zyb3plbicsIGZ1bmN0aW9uICgkaXNGcm96ZW4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzRnJvemVuKGl0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc0Zyb3plbiA/ICRpc0Zyb3plbihpdCkgOiBmYWxzZSA6IHRydWU7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi4xMyBPYmplY3QuaXNTZWFsZWQoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzU2VhbGVkJywgZnVuY3Rpb24gKCRpc1NlYWxlZCkge1xuICByZXR1cm4gZnVuY3Rpb24gaXNTZWFsZWQoaXQpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzU2VhbGVkID8gJGlzU2VhbGVkKGl0KSA6IGZhbHNlIDogdHJ1ZTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4zLjEwIE9iamVjdC5pcyh2YWx1ZTEsIHZhbHVlMilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgaXM6IHJlcXVpcmUoJy4vX3NhbWUtdmFsdWUnKSB9KTtcbiIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2tleXMnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBrZXlzKGl0KSB7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi4xNSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgncHJldmVudEV4dGVuc2lvbnMnLCBmdW5jdGlvbiAoJHByZXZlbnRFeHRlbnNpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyhpdCkge1xuICAgIHJldHVybiAkcHJldmVudEV4dGVuc2lvbnMgJiYgaXNPYmplY3QoaXQpID8gJHByZXZlbnRFeHRlbnNpb25zKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuMTcgT2JqZWN0LnNlYWwoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnc2VhbCcsIGZ1bmN0aW9uICgkc2VhbCkge1xuICByZXR1cm4gZnVuY3Rpb24gc2VhbChpdCkge1xuICAgIHJldHVybiAkc2VhbCAmJiBpc09iamVjdChpdCkgPyAkc2VhbChtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgc2V0UHJvdG90eXBlT2Y6IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldCB9KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIHRhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0O1xudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKCk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG52YXIgcGVyZm9ybSA9IHJlcXVpcmUoJy4vX3BlcmZvcm0nKTtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuL191c2VyLWFnZW50Jyk7XG52YXIgcHJvbWlzZVJlc29sdmUgPSByZXF1aXJlKCcuL19wcm9taXNlLXJlc29sdmUnKTtcbnZhciBQUk9NSVNFID0gJ1Byb21pc2UnO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjggfHwgJyc7XG52YXIgJFByb21pc2UgPSBnbG9iYWxbUFJPTUlTRV07XG52YXIgaXNOb2RlID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG52YXIgZW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgSW50ZXJuYWwsIG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSwgT3duUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mO1xuXG52YXIgVVNFX05BVElWRSA9ICEhZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlID0gJFByb21pc2UucmVzb2x2ZSgxKTtcbiAgICB2YXIgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uIChleGVjKSB7XG4gICAgICBleGVjKGVtcHR5LCBlbXB0eSk7XG4gICAgfTtcbiAgICAvLyB1bmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG4gICAgcmV0dXJuIChpc05vZGUgfHwgdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCA9PSAnZnVuY3Rpb24nKVxuICAgICAgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlXG4gICAgICAvLyB2OCA2LjYgKE5vZGUgMTAgYW5kIENocm9tZSA2NikgaGF2ZSBhIGJ1ZyB3aXRoIHJlc29sdmluZyBjdXN0b20gdGhlbmFibGVzXG4gICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04MzA1NjVcbiAgICAgIC8vIHdlIGNhbid0IGRldGVjdCBpdCBzeW5jaHJvbm91c2x5LCBzbyBqdXN0IGNoZWNrIHZlcnNpb25zXG4gICAgICAmJiB2OC5pbmRleE9mKCc2LjYnKSAhPT0gMFxuICAgICAgJiYgdXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZS82NicpID09PSAtMTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChwcm9taXNlLCBpc1JlamVjdCkge1xuICBpZiAocHJvbWlzZS5fbikgcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciBvayA9IHByb21pc2UuX3MgPT0gMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uIChyZWFjdGlvbikge1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbDtcbiAgICAgIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgICAgIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7XG4gICAgICB2YXIgZG9tYWluID0gcmVhY3Rpb24uZG9tYWluO1xuICAgICAgdmFyIHJlc3VsdCwgdGhlbiwgZXhpdGVkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZS5faCA9PSAyKSBvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2UuX2ggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gdHJ1ZSkgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpOyAvLyBtYXkgdGhyb3dcbiAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICAgICAgZXhpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSkge1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChkb21haW4gJiYgIWV4aXRlZCkgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUgKGNoYWluLmxlbmd0aCA+IGkpIHJ1bihjaGFpbltpKytdKTsgLy8gdmFyaWFibGUgbGVuZ3RoIC0gY2FuJ3QgdXNlIGZvckVhY2hcbiAgICBwcm9taXNlLl9jID0gW107XG4gICAgcHJvbWlzZS5fbiA9IGZhbHNlO1xuICAgIGlmIChpc1JlamVjdCAmJiAhcHJvbWlzZS5faCkgb25VbmhhbmRsZWQocHJvbWlzZSk7XG4gIH0pO1xufTtcbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciB1bmhhbmRsZWQgPSBpc1VuaGFuZGxlZChwcm9taXNlKTtcbiAgICB2YXIgcmVzdWx0LCBoYW5kbGVyLCBjb25zb2xlO1xuICAgIGlmICh1bmhhbmRsZWQpIHtcbiAgICAgIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbikge1xuICAgICAgICAgIGhhbmRsZXIoeyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHZhbHVlIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKChjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGUpICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcbiAgICAgIHByb21pc2UuX2ggPSBpc05vZGUgfHwgaXNVbmhhbmRsZWQocHJvbWlzZSkgPyAyIDogMTtcbiAgICB9IHByb21pc2UuX2EgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHVuaGFuZGxlZCAmJiByZXN1bHQuZSkgdGhyb3cgcmVzdWx0LnY7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHJldHVybiBwcm9taXNlLl9oICE9PSAxICYmIChwcm9taXNlLl9hIHx8IHByb21pc2UuX2MpLmxlbmd0aCA9PT0gMDtcbn07XG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCkge1xuICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogcHJvbWlzZS5fdiB9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICBwcm9taXNlLl92ID0gdmFsdWU7XG4gIHByb21pc2UuX3MgPSAyO1xuICBpZiAoIXByb21pc2UuX2EpIHByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICB2YXIgdGhlbjtcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICB0cnkge1xuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkgdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSkge1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfTsgLy8gd3JhcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAkcmVqZWN0LmNhbGwoeyBfdzogcHJvbWlzZSwgX2Q6IGZhbHNlIH0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkUHJvbWlzZSwgUFJPTUlTRSwgJ19oJyk7XG4gICAgYUZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICBJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHRoaXMsIDEpLCBjdHgoJHJlamVjdCwgdGhpcywgMSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgdGhpcy5fYyA9IFtdOyAgICAgICAgICAgICAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcbiAgICB0aGlzLl9hID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIGNoZWNrZWQgaW4gaXNVbmhhbmRsZWQgcmVhY3Rpb25zXG4gICAgdGhpcy5fcyA9IDA7ICAgICAgICAgICAgICAvLyA8LSBzdGF0ZVxuICAgIHRoaXMuX2QgPSBmYWxzZTsgICAgICAgICAgLy8gPC0gZG9uZVxuICAgIHRoaXMuX3YgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gdmFsdWVcbiAgICB0aGlzLl9oID0gMDsgICAgICAgICAgICAgIC8vIDwtIHJlamVjdGlvbiBzdGF0ZSwgMCAtIGRlZmF1bHQsIDEgLSBoYW5kbGVkLCAyIC0gdW5oYW5kbGVkXG4gICAgdGhpcy5fbiA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBub3RpZnlcbiAgfTtcbiAgSW50ZXJuYWwucHJvdG90eXBlID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJykoJFByb21pc2UucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICB2YXIgcmVhY3Rpb24gPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuX2EpIHRoaXMuX2EucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fcykgbm90aWZ5KHRoaXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIE93blByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gbmV3IEludGVybmFsKCk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ID0gY3R4KCRyZWplY3QsIHByb21pc2UsIDEpO1xuICB9O1xuICBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICAgIHJldHVybiBDID09PSAkUHJvbWlzZSB8fCBDID09PSBXcmFwcGVyXG4gICAgICA/IG5ldyBPd25Qcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgOiBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgUHJvbWlzZTogJFByb21pc2UgfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpO1xuICAgIHZhciAkJHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShMSUJSQVJZICYmIHRoaXMgPT09IFdyYXBwZXIgPyAkUHJvbWlzZSA6IHRoaXMsIHgpO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24gKGl0ZXIpIHtcbiAgJFByb21pc2UuYWxsKGl0ZXIpWydjYXRjaCddKGVtcHR5KTtcbn0pKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuMSBQcm9taXNlLmFsbChpdGVyYWJsZSlcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICB2YXIgJGluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSByZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzWyRpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS4xIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3QpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHJBcHBseSA9IChyZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0IHx8IHt9KS5hcHBseTtcbnZhciBmQXBwbHkgPSBGdW5jdGlvbi5hcHBseTtcbi8vIE1TIEVkZ2UgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJBcHBseShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSksICdSZWZsZWN0Jywge1xuICBhcHBseTogZnVuY3Rpb24gYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3QpIHtcbiAgICB2YXIgVCA9IGFGdW5jdGlvbih0YXJnZXQpO1xuICAgIHZhciBMID0gYW5PYmplY3QoYXJndW1lbnRzTGlzdCk7XG4gICAgcmV0dXJuIHJBcHBseSA/IHJBcHBseShULCB0aGlzQXJndW1lbnQsIEwpIDogZkFwcGx5LmNhbGwoVCwgdGhpc0FyZ3VtZW50LCBMKTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjIgUmVmbGVjdC5jb25zdHJ1Y3QodGFyZ2V0LCBhcmd1bWVudHNMaXN0IFssIG5ld1RhcmdldF0pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9fYmluZCcpO1xudmFyIHJDb25zdHJ1Y3QgPSAocmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdCB8fCB7fSkuY29uc3RydWN0O1xuXG4vLyBNUyBFZGdlIHN1cHBvcnRzIG9ubHkgMiBhcmd1bWVudHMgYW5kIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcbi8vIEZGIE5pZ2h0bHkgc2V0cyB0aGlyZCBhcmd1bWVudCBhcyBgbmV3LnRhcmdldGAsIGJ1dCBkb2VzIG5vdCBjcmVhdGUgYHRoaXNgIGZyb20gaXRcbnZhciBORVdfVEFSR0VUX0JVRyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gIShyQ29uc3RydWN0KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgW10sIEYpIGluc3RhbmNlb2YgRik7XG59KTtcbnZhciBBUkdTX0JVRyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJDb25zdHJ1Y3QoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChORVdfVEFSR0VUX0JVRyB8fCBBUkdTX0JVRyksICdSZWZsZWN0Jywge1xuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIGNvbnN0cnVjdChUYXJnZXQsIGFyZ3MgLyogLCBuZXdUYXJnZXQgKi8pIHtcbiAgICBhRnVuY3Rpb24oVGFyZ2V0KTtcbiAgICBhbk9iamVjdChhcmdzKTtcbiAgICB2YXIgbmV3VGFyZ2V0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBUYXJnZXQgOiBhRnVuY3Rpb24oYXJndW1lbnRzWzJdKTtcbiAgICBpZiAoQVJHU19CVUcgJiYgIU5FV19UQVJHRVRfQlVHKSByZXR1cm4gckNvbnN0cnVjdChUYXJnZXQsIGFyZ3MsIG5ld1RhcmdldCk7XG4gICAgaWYgKFRhcmdldCA9PSBuZXdUYXJnZXQpIHtcbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgb3B0aW1pemF0aW9uIGZvciAwLTQgYXJndW1lbnRzXG4gICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBUYXJnZXQoKTtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdKTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgIH1cbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgbG90IG9mIGFyZ3VtZW50cyBjYXNlXG4gICAgICB2YXIgJGFyZ3MgPSBbbnVsbF07XG4gICAgICAkYXJncy5wdXNoLmFwcGx5KCRhcmdzLCBhcmdzKTtcbiAgICAgIHJldHVybiBuZXcgKGJpbmQuYXBwbHkoVGFyZ2V0LCAkYXJncykpKCk7XG4gICAgfVxuICAgIC8vIHdpdGggYWx0ZXJlZCBuZXdUYXJnZXQsIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGNvbnN0cnVjdG9yc1xuICAgIHZhciBwcm90byA9IG5ld1RhcmdldC5wcm90b3R5cGU7XG4gICAgdmFyIGluc3RhbmNlID0gY3JlYXRlKGlzT2JqZWN0KHByb3RvKSA/IHByb3RvIDogT2JqZWN0LnByb3RvdHlwZSk7XG4gICAgdmFyIHJlc3VsdCA9IEZ1bmN0aW9uLmFwcGx5LmNhbGwoVGFyZ2V0LCBpbnN0YW5jZSwgYXJncyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiBpbnN0YW5jZTtcbiAgfVxufSk7XG4iLCIvLyAyNi4xLjMgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKVxudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxuLy8gTVMgRWRnZSBoYXMgYnJva2VuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkgLSB0aHJvd2luZyBpbnN0ZWFkIG9mIHJldHVybmluZyBmYWxzZVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkoZFAuZih7fSwgMSwgeyB2YWx1ZTogMSB9KSwgMSwgeyB2YWx1ZTogMiB9KTtcbn0pLCAnUmVmbGVjdCcsIHtcbiAgZGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpIHtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHByb3BlcnR5S2V5ID0gdG9QcmltaXRpdmUocHJvcGVydHlLZXksIHRydWUpO1xuICAgIGFuT2JqZWN0KGF0dHJpYnV0ZXMpO1xuICAgIHRyeSB7XG4gICAgICBkUC5mKHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG4iLCIvLyAyNi4xLjQgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICB2YXIgZGVzYyA9IGdPUEQoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICAgIHJldHVybiBkZXNjICYmICFkZXNjLmNvbmZpZ3VyYWJsZSA/IGZhbHNlIDogZGVsZXRlIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS43IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIHJldHVybiBnT1BELmYoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICB9XG59KTtcbiIsIi8vIDI2LjEuOCBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgZ2V0UHJvdG8gPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSB7XG4gICAgcmV0dXJuIGdldFByb3RvKGFuT2JqZWN0KHRhcmdldCkpO1xuICB9XG59KTtcbiIsIi8vIDI2LjEuNiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3BlcnR5S2V5IFssIHJlY2VpdmVyXSlcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG5mdW5jdGlvbiBnZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSAvKiAsIHJlY2VpdmVyICovKSB7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogYXJndW1lbnRzWzJdO1xuICB2YXIgZGVzYywgcHJvdG87XG4gIGlmIChhbk9iamVjdCh0YXJnZXQpID09PSByZWNlaXZlcikgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIGlmIChkZXNjID0gZ09QRC5mKHRhcmdldCwgcHJvcGVydHlLZXkpKSByZXR1cm4gaGFzKGRlc2MsICd2YWx1ZScpXG4gICAgPyBkZXNjLnZhbHVlXG4gICAgOiBkZXNjLmdldCAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgaWYgKGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpIHJldHVybiBnZXQocHJvdG8sIHByb3BlcnR5S2V5LCByZWNlaXZlcik7XG59XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHsgZ2V0OiBnZXQgfSk7XG4iLCIvLyAyNi4xLjkgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wZXJ0eUtleSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgaGFzOiBmdW5jdGlvbiBoYXModGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIHJldHVybiBwcm9wZXJ0eUtleSBpbiB0YXJnZXQ7XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS4xMCBSZWZsZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgJGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgaXNFeHRlbnNpYmxlOiBmdW5jdGlvbiBpc0V4dGVuc2libGUodGFyZ2V0KSB7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICByZXR1cm4gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUodGFyZ2V0KSA6IHRydWU7XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS4xMSBSZWZsZWN0Lm93bktleXModGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0JywgeyBvd25LZXlzOiByZXF1aXJlKCcuL19vd24ta2V5cycpIH0pO1xuIiwiLy8gMjYuMS4xMiBSZWZsZWN0LnByZXZlbnRFeHRlbnNpb25zKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciAkcHJldmVudEV4dGVuc2lvbnMgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgcHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCkge1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICgkcHJldmVudEV4dGVuc2lvbnMpICRwcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG4iLCIvLyAyNi4xLjE0IFJlZmxlY3Quc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgc2V0UHJvdG8gPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKTtcblxuaWYgKHNldFByb3RvKSAkZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIHNldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKSB7XG4gICAgc2V0UHJvdG8uY2hlY2sodGFyZ2V0LCBwcm90byk7XG4gICAgdHJ5IHtcbiAgICAgIHNldFByb3RvLnNldCh0YXJnZXQsIHByb3RvKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuIiwiLy8gMjYuMS4xMyBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWIFssIHJlY2VpdmVyXSlcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxuZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYgLyogLCByZWNlaXZlciAqLykge1xuICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgNCA/IHRhcmdldCA6IGFyZ3VtZW50c1szXTtcbiAgdmFyIG93bkRlc2MgPSBnT1BELmYoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICB2YXIgZXhpc3RpbmdEZXNjcmlwdG9yLCBwcm90bztcbiAgaWYgKCFvd25EZXNjKSB7XG4gICAgaWYgKGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpIHtcbiAgICAgIHJldHVybiBzZXQocHJvdG8sIHByb3BlcnR5S2V5LCBWLCByZWNlaXZlcik7XG4gICAgfVxuICAgIG93bkRlc2MgPSBjcmVhdGVEZXNjKDApO1xuICB9XG4gIGlmIChoYXMob3duRGVzYywgJ3ZhbHVlJykpIHtcbiAgICBpZiAob3duRGVzYy53cml0YWJsZSA9PT0gZmFsc2UgfHwgIWlzT2JqZWN0KHJlY2VpdmVyKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChleGlzdGluZ0Rlc2NyaXB0b3IgPSBnT1BELmYocmVjZWl2ZXIsIHByb3BlcnR5S2V5KSkge1xuICAgICAgaWYgKGV4aXN0aW5nRGVzY3JpcHRvci5nZXQgfHwgZXhpc3RpbmdEZXNjcmlwdG9yLnNldCB8fCBleGlzdGluZ0Rlc2NyaXB0b3Iud3JpdGFibGUgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICBleGlzdGluZ0Rlc2NyaXB0b3IudmFsdWUgPSBWO1xuICAgICAgZFAuZihyZWNlaXZlciwgcHJvcGVydHlLZXksIGV4aXN0aW5nRGVzY3JpcHRvcik7XG4gICAgfSBlbHNlIGRQLmYocmVjZWl2ZXIsIHByb3BlcnR5S2V5LCBjcmVhdGVEZXNjKDAsIFYpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gb3duRGVzYy5zZXQgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogKG93bkRlc2Muc2V0LmNhbGwocmVjZWl2ZXIsIFYpLCB0cnVlKTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0JywgeyBzZXQ6IHNldCB9KTtcbiIsIi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzKClcbmlmIChyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmIC8uL2cuZmxhZ3MgIT0gJ2cnKSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKFJlZ0V4cC5wcm90b3R5cGUsICdmbGFncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IHJlcXVpcmUoJy4vX2ZsYWdzJylcbn0pO1xuIiwiLy8gQEBtYXRjaCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdtYXRjaCcsIDEsIGZ1bmN0aW9uIChkZWZpbmVkLCBNQVRDSCwgJG1hdGNoKSB7XG4gIC8vIDIxLjEuMy4xMSBTdHJpbmcucHJvdG90eXBlLm1hdGNoKHJlZ2V4cClcbiAgcmV0dXJuIFtmdW5jdGlvbiBtYXRjaChyZWdleHApIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgIHZhciBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbTUFUQ0hdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW01BVENIXShTdHJpbmcoTykpO1xuICB9LCAkbWF0Y2hdO1xufSk7XG4iLCIvLyBAQHJlcGxhY2UgbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgncmVwbGFjZScsIDIsIGZ1bmN0aW9uIChkZWZpbmVkLCBSRVBMQUNFLCAkcmVwbGFjZSkge1xuICAvLyAyMS4xLjMuMTQgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpXG4gIHJldHVybiBbZnVuY3Rpb24gcmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICB2YXIgZm4gPSBzZWFyY2hWYWx1ZSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZWFyY2hWYWx1ZVtSRVBMQUNFXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZFxuICAgICAgPyBmbi5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXG4gICAgICA6ICRyZXBsYWNlLmNhbGwoU3RyaW5nKE8pLCBzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKTtcbiAgfSwgJHJlcGxhY2VdO1xufSk7XG4iLCIvLyBAQHNlYXJjaCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzZWFyY2gnLCAxLCBmdW5jdGlvbiAoZGVmaW5lZCwgU0VBUkNILCAkc2VhcmNoKSB7XG4gIC8vIDIxLjEuMy4xNSBTdHJpbmcucHJvdG90eXBlLnNlYXJjaChyZWdleHApXG4gIHJldHVybiBbZnVuY3Rpb24gc2VhcmNoKHJlZ2V4cCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgdmFyIGZuID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtTRUFSQ0hdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW1NFQVJDSF0oU3RyaW5nKE8pKTtcbiAgfSwgJHNlYXJjaF07XG59KTtcbiIsIi8vIEBAc3BsaXQgbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnc3BsaXQnLCAyLCBmdW5jdGlvbiAoZGVmaW5lZCwgU1BMSVQsICRzcGxpdCkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xuICB2YXIgX3NwbGl0ID0gJHNwbGl0O1xuICB2YXIgJHB1c2ggPSBbXS5wdXNoO1xuICB2YXIgJFNQTElUID0gJ3NwbGl0JztcbiAgdmFyIExFTkdUSCA9ICdsZW5ndGgnO1xuICB2YXIgTEFTVF9JTkRFWCA9ICdsYXN0SW5kZXgnO1xuICBpZiAoXG4gICAgJ2FiYmMnWyRTUExJVF0oLyhiKSovKVsxXSA9PSAnYycgfHxcbiAgICAndGVzdCdbJFNQTElUXSgvKD86KS8sIC0xKVtMRU5HVEhdICE9IDQgfHxcbiAgICAnYWInWyRTUExJVF0oLyg/OmFiKSovKVtMRU5HVEhdICE9IDIgfHxcbiAgICAnLidbJFNQTElUXSgvKC4/KSguPykvKVtMRU5HVEhdICE9IDQgfHxcbiAgICAnLidbJFNQTElUXSgvKCkoKS8pW0xFTkdUSF0gPiAxIHx8XG4gICAgJydbJFNQTElUXSgvLj8vKVtMRU5HVEhdXG4gICkge1xuICAgIHZhciBOUENHID0gLygpPz8vLmV4ZWMoJycpWzFdID09PSB1bmRlZmluZWQ7IC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG4gICAgLy8gYmFzZWQgb24gZXM1LXNoaW0gaW1wbGVtZW50YXRpb24sIG5lZWQgdG8gcmV3b3JrIGl0XG4gICAgJHNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcodGhpcyk7XG4gICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDApIHJldHVybiBbXTtcbiAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICBpZiAoIWlzUmVnRXhwKHNlcGFyYXRvcikpIHJldHVybiBfc3BsaXQuY2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgdmFyIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IudW5pY29kZSA/ICd1JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnN0aWNreSA/ICd5JyA6ICcnKTtcbiAgICAgIHZhciBsYXN0TGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBzcGxpdExpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IDQyOTQ5NjcyOTUgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICB2YXIgc2VwYXJhdG9yQ29weSA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgdmFyIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGgsIGk7XG4gICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgIGlmICghTlBDRykgc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoJ14nICsgc2VwYXJhdG9yQ29weS5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvckNvcHkuZXhlYyhzdHJpbmcpKSB7XG4gICAgICAgIC8vIGBzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXVtMRU5HVEhdO1xuICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvciBOUENHXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvb3AtZnVuY1xuICAgICAgICAgIGlmICghTlBDRyAmJiBtYXRjaFtMRU5HVEhdID4gMSkgbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzW0xFTkdUSF0gLSAyOyBpKyspIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKG1hdGNoW0xFTkdUSF0gPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nW0xFTkdUSF0pICRwdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXVtMRU5HVEhdO1xuICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgaWYgKG91dHB1dFtMRU5HVEhdID49IHNwbGl0TGltaXQpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdID09PSBtYXRjaC5pbmRleCkgc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICB9XG4gICAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyaW5nW0xFTkdUSF0pIHtcbiAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvckNvcHkudGVzdCgnJykpIG91dHB1dC5wdXNoKCcnKTtcbiAgICAgIH0gZWxzZSBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuICAgICAgcmV0dXJuIG91dHB1dFtMRU5HVEhdID4gc3BsaXRMaW1pdCA/IG91dHB1dC5zbGljZSgwLCBzcGxpdExpbWl0KSA6IG91dHB1dDtcbiAgICB9O1xuICAvLyBDaGFrcmEsIFY4XG4gIH0gZWxzZSBpZiAoJzAnWyRTUExJVF0odW5kZWZpbmVkLCAwKVtMRU5HVEhdKSB7XG4gICAgJHNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHJldHVybiBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMCA/IFtdIDogX3NwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbiAgfVxuICAvLyAyMS4xLjMuMTcgU3RyaW5nLnByb3RvdHlwZS5zcGxpdChzZXBhcmF0b3IsIGxpbWl0KVxuICByZXR1cm4gW2Z1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgdmFyIGZuID0gc2VwYXJhdG9yID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlcGFyYXRvcltTUExJVF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHNlcGFyYXRvciwgTywgbGltaXQpIDogJHNwbGl0LmNhbGwoU3RyaW5nKE8pLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgfSwgJHNwbGl0XTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgU0VUID0gJ1NldCc7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFNFVCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodmFsaWRhdGUodGhpcywgU0VUKSwgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKShmYWxzZSk7XG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjMgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdChwb3MpXG4gIGNvZGVQb2ludEF0OiBmdW5jdGlvbiBjb2RlUG9pbnRBdChwb3MpIHtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pO1xuIiwiLy8gMjEuMS4zLjYgU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aChzZWFyY2hTdHJpbmcgWywgZW5kUG9zaXRpb25dKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpO1xudmFyIEVORFNfV0lUSCA9ICdlbmRzV2l0aCc7XG52YXIgJGVuZHNXaXRoID0gJydbRU5EU19XSVRIXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShFTkRTX1dJVEgpLCAnU3RyaW5nJywge1xuICBlbmRzV2l0aDogZnVuY3Rpb24gZW5kc1dpdGgoc2VhcmNoU3RyaW5nIC8qICwgZW5kUG9zaXRpb24gPSBAbGVuZ3RoICovKSB7XG4gICAgdmFyIHRoYXQgPSBjb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgRU5EU19XSVRIKTtcbiAgICB2YXIgZW5kUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgodGhhdC5sZW5ndGgpO1xuICAgIHZhciBlbmQgPSBlbmRQb3NpdGlvbiA9PT0gdW5kZWZpbmVkID8gbGVuIDogTWF0aC5taW4odG9MZW5ndGgoZW5kUG9zaXRpb24pLCBsZW4pO1xuICAgIHZhciBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gJGVuZHNXaXRoXG4gICAgICA/ICRlbmRzV2l0aC5jYWxsKHRoYXQsIHNlYXJjaCwgZW5kKVxuICAgICAgOiB0aGF0LnNsaWNlKGVuZCAtIHNlYXJjaC5sZW5ndGgsIGVuZCkgPT09IHNlYXJjaDtcbiAgfVxufSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbnZhciAkZnJvbUNvZGVQb2ludCA9IFN0cmluZy5mcm9tQ29kZVBvaW50O1xuXG4vLyBsZW5ndGggc2hvdWxkIGJlIDEsIG9sZCBGRiBwcm9ibGVtXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghISRmcm9tQ29kZVBvaW50ICYmICRmcm9tQ29kZVBvaW50Lmxlbmd0aCAhPSAxKSwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4yLjIgU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY29kZVBvaW50cylcbiAgZnJvbUNvZGVQb2ludDogZnVuY3Rpb24gZnJvbUNvZGVQb2ludCh4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgcmVzID0gW107XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgY29kZTtcbiAgICB3aGlsZSAoYUxlbiA+IGkpIHtcbiAgICAgIGNvZGUgPSArYXJndW1lbnRzW2krK107XG4gICAgICBpZiAodG9BYnNvbHV0ZUluZGV4KGNvZGUsIDB4MTBmZmZmKSAhPT0gY29kZSkgdGhyb3cgUmFuZ2VFcnJvcihjb2RlICsgJyBpcyBub3QgYSB2YWxpZCBjb2RlIHBvaW50Jyk7XG4gICAgICByZXMucHVzaChjb2RlIDwgMHgxMDAwMFxuICAgICAgICA/IGZyb21DaGFyQ29kZShjb2RlKVxuICAgICAgICA6IGZyb21DaGFyQ29kZSgoKGNvZGUgLT0gMHgxMDAwMCkgPj4gMTApICsgMHhkODAwLCBjb2RlICUgMHg0MDAgKyAweGRjMDApXG4gICAgICApO1xuICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgfVxufSk7XG4iLCIvLyAyMS4xLjMuNyBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzKHNlYXJjaFN0cmluZywgcG9zaXRpb24gPSAwKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb250ZXh0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKTtcbnZhciBJTkNMVURFUyA9ICdpbmNsdWRlcyc7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoSU5DTFVERVMpLCAnU3RyaW5nJywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoU3RyaW5nIC8qICwgcG9zaXRpb24gPSAwICovKSB7XG4gICAgcmV0dXJuICEhfmNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBJTkNMVURFUylcbiAgICAgIC5pbmRleE9mKHNlYXJjaFN0cmluZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjIuNCBTdHJpbmcucmF3KGNhbGxTaXRlLCAuLi5zdWJzdGl0dXRpb25zKVxuICByYXc6IGZ1bmN0aW9uIHJhdyhjYWxsU2l0ZSkge1xuICAgIHZhciB0cGwgPSB0b0lPYmplY3QoY2FsbFNpdGUucmF3KTtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgodHBsLmxlbmd0aCk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGxlbiA+IGkpIHtcbiAgICAgIHJlcy5wdXNoKFN0cmluZyh0cGxbaSsrXSkpO1xuICAgICAgaWYgKGkgPCBhTGVuKSByZXMucHVzaChTdHJpbmcoYXJndW1lbnRzW2ldKSk7XG4gICAgfSByZXR1cm4gcmVzLmpvaW4oJycpO1xuICB9XG59KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQoY291bnQpXG4gIHJlcGVhdDogcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpXG59KTtcbiIsIi8vIDIxLjEuMy4xOCBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIFssIHBvc2l0aW9uIF0pXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY29udGV4dCA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0Jyk7XG52YXIgU1RBUlRTX1dJVEggPSAnc3RhcnRzV2l0aCc7XG52YXIgJHN0YXJ0c1dpdGggPSAnJ1tTVEFSVFNfV0lUSF07XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoU1RBUlRTX1dJVEgpLCAnU3RyaW5nJywge1xuICBzdGFydHNXaXRoOiBmdW5jdGlvbiBzdGFydHNXaXRoKHNlYXJjaFN0cmluZyAvKiAsIHBvc2l0aW9uID0gMCAqLykge1xuICAgIHZhciB0aGF0ID0gY29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIFNUQVJUU19XSVRIKTtcbiAgICB2YXIgaW5kZXggPSB0b0xlbmd0aChNYXRoLm1pbihhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgdGhhdC5sZW5ndGgpKTtcbiAgICB2YXIgc2VhcmNoID0gU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgcmV0dXJuICRzdGFydHNXaXRoXG4gICAgICA/ICRzdGFydHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBpbmRleClcbiAgICAgIDogdGhhdC5zbGljZShpbmRleCwgaW5kZXggKyBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBNRVRBID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWTtcbnZhciAkZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgd2tzRGVmaW5lID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpO1xudmFyIGVudW1LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1rZXlzJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgX2NyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBnT1BORXh0ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0Jyk7XG52YXIgJEdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyICREUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BEID0gJEdPUEQuZjtcbnZhciBkUCA9ICREUC5mO1xudmFyIGdPUE4gPSBnT1BORXh0LmY7XG52YXIgJFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgJEpTT04gPSBnbG9iYWwuSlNPTjtcbnZhciBfc3RyaW5naWZ5ID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIEhJRERFTiA9IHdrcygnX2hpZGRlbicpO1xudmFyIFRPX1BSSU1JVElWRSA9IHdrcygndG9QcmltaXRpdmUnKTtcbnZhciBpc0VudW0gPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5Jyk7XG52YXIgQWxsU3ltYm9scyA9IHNoYXJlZCgnc3ltYm9scycpO1xudmFyIE9QU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0W1BST1RPVFlQRV07XG52YXIgVVNFX05BVElWRSA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbic7XG52YXIgUU9iamVjdCA9IGdsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRQKHRoaXMsICdhJywgeyB2YWx1ZTogNyB9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uIChpdCwga2V5LCBEKSB7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZiAocHJvdG9EZXNjKSBkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmIChwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKSBkUChPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xufSA6IGRQO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpIHtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90bykgJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcbiAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpKSB7XG4gICAgaWYgKCFELmVudW1lcmFibGUpIHtcbiAgICAgIGlmICghaGFzKGl0LCBISURERU4pKSBkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkgaXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7IGVudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpIH0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApIHtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsID4gaSkgJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCkge1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSkge1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgaXQgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYgKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkgRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICB2YXIgbmFtZXMgPSBnT1BOKHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgdmFyIElTX09QID0gaXQgPT09IE9iamVjdFByb3RvO1xuICB2YXIgbmFtZXMgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmIChoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKSB0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTtcbiAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvKSAkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZiAoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSkgdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZiAoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKSBzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXQgfSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mID0gJGRlZmluZVByb3BlcnR5O1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmYgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJykuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYgKERFU0NSSVBUT1JTICYmICFyZXF1aXJlKCcuL19saWJyYXJ5JykpIHtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gd3JhcCh3a3MobmFtZSkpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7IFN5bWJvbDogJFN5bWJvbCB9KTtcblxuZm9yICh2YXIgZXM2U3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBqID0gMDsgZXM2U3ltYm9scy5sZW5ndGggPiBqOyl3a3MoZXM2U3ltYm9sc1tqKytdKTtcblxuZm9yICh2YXIgd2VsbEtub3duU3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGsgPSAwOyB3ZWxsS25vd25TeW1ib2xzLmxlbmd0aCA+IGs7KSB3a3NEZWZpbmUod2VsbEtub3duU3ltYm9sc1trKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihzeW0pIHtcbiAgICBpZiAoIWlzU3ltYm9sKHN5bSkpIHRocm93IFR5cGVFcnJvcihzeW0gKyAnIGlzIG5vdCBhIHN5bWJvbCEnKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gU3ltYm9sUmVnaXN0cnkpIGlmIChTeW1ib2xSZWdpc3RyeVtrZXldID09PSBzeW0pIHJldHVybiBrZXk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gZmFsc2U7IH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7IGE6IFMgfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pKSwgJ0pTT04nLCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7XG4gICAgdmFyIGFyZ3MgPSBbaXRdO1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgJHJlcGxhY2VyID0gcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmICghaXNPYmplY3QocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICBpZiAoIWlzQXJyYXkocmVwbGFjZXIpKSByZXBsYWNlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mICRyZXBsYWNlciA9PSAnZnVuY3Rpb24nKSB2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICR0eXBlZCA9IHJlcXVpcmUoJy4vX3R5cGVkJyk7XG52YXIgYnVmZmVyID0gcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLkFycmF5QnVmZmVyO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciAkQXJyYXlCdWZmZXIgPSBidWZmZXIuQXJyYXlCdWZmZXI7XG52YXIgJERhdGFWaWV3ID0gYnVmZmVyLkRhdGFWaWV3O1xudmFyICRpc1ZpZXcgPSAkdHlwZWQuQUJWICYmIEFycmF5QnVmZmVyLmlzVmlldztcbnZhciAkc2xpY2UgPSAkQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlO1xudmFyIFZJRVcgPSAkdHlwZWQuVklFVztcbnZhciBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChBcnJheUJ1ZmZlciAhPT0gJEFycmF5QnVmZmVyKSwgeyBBcnJheUJ1ZmZlcjogJEFycmF5QnVmZmVyIH0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEkdHlwZWQuQ09OU1RSLCBBUlJBWV9CVUZGRVIsIHtcbiAgLy8gMjQuMS4zLjEgQXJyYXlCdWZmZXIuaXNWaWV3KGFyZylcbiAgaXNWaWV3OiBmdW5jdGlvbiBpc1ZpZXcoaXQpIHtcbiAgICByZXR1cm4gJGlzVmlldyAmJiAkaXNWaWV3KGl0KSB8fCBpc09iamVjdChpdCkgJiYgVklFVyBpbiBpdDtcbiAgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5VICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhbmV3ICRBcnJheUJ1ZmZlcigyKS5zbGljZSgxLCB1bmRlZmluZWQpLmJ5dGVMZW5ndGg7XG59KSwgQVJSQVlfQlVGRkVSLCB7XG4gIC8vIDI0LjEuNC4zIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZShzdGFydCwgZW5kKVxuICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIGlmICgkc2xpY2UgIT09IHVuZGVmaW5lZCAmJiBlbmQgPT09IHVuZGVmaW5lZCkgcmV0dXJuICRzbGljZS5jYWxsKGFuT2JqZWN0KHRoaXMpLCBzdGFydCk7IC8vIEZGIGZpeFxuICAgIHZhciBsZW4gPSBhbk9iamVjdCh0aGlzKS5ieXRlTGVuZ3RoO1xuICAgIHZhciBmaXJzdCA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuKTtcbiAgICB2YXIgZmluID0gdG9BYnNvbHV0ZUluZGV4KGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogZW5kLCBsZW4pO1xuICAgIHZhciByZXN1bHQgPSBuZXcgKHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkQXJyYXlCdWZmZXIpKSh0b0xlbmd0aChmaW4gLSBmaXJzdCkpO1xuICAgIHZhciB2aWV3UyA9IG5ldyAkRGF0YVZpZXcodGhpcyk7XG4gICAgdmFyIHZpZXdUID0gbmV3ICREYXRhVmlldyhyZXN1bHQpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgd2hpbGUgKGZpcnN0IDwgZmluKSB7XG4gICAgICB2aWV3VC5zZXRVaW50OChpbmRleCsrLCB2aWV3Uy5nZXRVaW50OChmaXJzdCsrKSk7XG4gICAgfSByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShBUlJBWV9CVUZGRVIpO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnRmxvYXQzMicsIDQsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBGbG9hdDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnRmxvYXQ2NCcsIDgsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBGbG9hdDY0QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50MTYnLCAyLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50MTZBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQzMicsIDQsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDgnLCAxLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQxNicsIDIsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MTZBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDgnLCAxLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50OCcsIDEsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OENsYW1wZWRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSwgdHJ1ZSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJyk7XG52YXIgd2VhayA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24td2VhaycpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFdFQUtfTUFQID0gJ1dlYWtNYXAnO1xudmFyIGdldFdlYWsgPSBtZXRhLmdldFdlYWs7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcbnZhciB1bmNhdWdodEZyb3plblN0b3JlID0gd2Vhay51ZnN0b3JlO1xudmFyIHRtcCA9IHt9O1xudmFyIEludGVybmFsTWFwO1xuXG52YXIgd3JhcHBlciA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtNYXAoKSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gIH07XG59O1xuXG52YXIgbWV0aG9kcyA9IHtcbiAgLy8gMjMuMy4zLjMgV2Vha01hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgaWYgKGlzT2JqZWN0KGtleSkpIHtcbiAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIFdFQUtfTUFQKSkuZ2V0KGtleSk7XG4gICAgICByZXR1cm4gZGF0YSA/IGRhdGFbdGhpcy5faV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9LFxuICAvLyAyMy4zLjMuNSBXZWFrTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB3ZWFrLmRlZih2YWxpZGF0ZSh0aGlzLCBXRUFLX01BUCksIGtleSwgdmFsdWUpO1xuICB9XG59O1xuXG4vLyAyMy4zIFdlYWtNYXAgT2JqZWN0c1xudmFyICRXZWFrTWFwID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoV0VBS19NQVAsIHdyYXBwZXIsIG1ldGhvZHMsIHdlYWssIHRydWUsIHRydWUpO1xuXG4vLyBJRTExIFdlYWtNYXAgZnJvemVuIGtleXMgZml4XG5pZiAoZmFpbHMoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3ICRXZWFrTWFwKCkuc2V0KChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkodG1wKSwgNykuZ2V0KHRtcCkgIT0gNzsgfSkpIHtcbiAgSW50ZXJuYWxNYXAgPSB3ZWFrLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIFdFQUtfTUFQKTtcbiAgYXNzaWduKEludGVybmFsTWFwLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gIG1ldGEuTkVFRCA9IHRydWU7XG4gIGVhY2goWydkZWxldGUnLCAnaGFzJywgJ2dldCcsICdzZXQnXSwgZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBwcm90byA9ICRXZWFrTWFwLnByb3RvdHlwZTtcbiAgICB2YXIgbWV0aG9kID0gcHJvdG9ba2V5XTtcbiAgICByZWRlZmluZShwcm90bywga2V5LCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgLy8gc3RvcmUgZnJvemVuIG9iamVjdHMgb24gaW50ZXJuYWwgd2Vha21hcCBzaGltXG4gICAgICBpZiAoaXNPYmplY3QoYSkgJiYgIWlzRXh0ZW5zaWJsZShhKSkge1xuICAgICAgICBpZiAoIXRoaXMuX2YpIHRoaXMuX2YgPSBuZXcgSW50ZXJuYWxNYXAoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2Zba2V5XShhLCBiKTtcbiAgICAgICAgcmV0dXJuIGtleSA9PSAnc2V0JyA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICAvLyBzdG9yZSBhbGwgdGhlIHJlc3Qgb24gbmF0aXZlIHdlYWttYXBcbiAgICAgIH0gcmV0dXJuIG1ldGhvZC5jYWxsKHRoaXMsIGEsIGIpO1xuICAgIH0pO1xuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciB3ZWFrID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi13ZWFrJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgV0VBS19TRVQgPSAnV2Vha1NldCc7XG5cbi8vIDIzLjQgV2Vha1NldCBPYmplY3RzXG5yZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoV0VBS19TRVQsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtTZXQoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy40LjMuMSBXZWFrU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHdlYWsuZGVmKHZhbGlkYXRlKHRoaXMsIFdFQUtfU0VUKSwgdmFsdWUsIHRydWUpO1xuICB9XG59LCB3ZWFrLCBmYWxzZSwgdHJ1ZSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9BcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJGluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKGVsIC8qICwgZnJvbUluZGV4ID0gMCAqLykge1xuICAgIHJldHVybiAkaW5jbHVkZXModGhpcywgZWwsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdpbmNsdWRlcycpO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LXZhbHVlcy1lbnRyaWVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRlbnRyaWVzID0gcmVxdWlyZSgnLi9fb2JqZWN0LXRvLWFycmF5JykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKGl0KSB7XG4gICAgcmV0dXJuICRlbnRyaWVzKGl0KTtcbiAgfVxufSk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBvd25LZXlzID0gcmVxdWlyZSgnLi9fb3duLWtleXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqZWN0KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgICB2YXIgZ2V0RGVzYyA9IGdPUEQuZjtcbiAgICB2YXIga2V5cyA9IG93bktleXMoTyk7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIga2V5LCBkZXNjO1xuICAgIHdoaWxlIChrZXlzLmxlbmd0aCA+IGkpIHtcbiAgICAgIGRlc2MgPSBnZXREZXNjKE8sIGtleSA9IGtleXNbaSsrXSk7XG4gICAgICBpZiAoZGVzYyAhPT0gdW5kZWZpbmVkKSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGtleSwgZGVzYyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LXZhbHVlcy1lbnRyaWVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICR2YWx1ZXMgPSByZXF1aXJlKCcuL19vYmplY3QtdG8tYXJyYXknKShmYWxzZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcyhpdCkge1xuICAgIHJldHVybiAkdmFsdWVzKGl0KTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkcGFkID0gcmVxdWlyZSgnLi9fc3RyaW5nLXBhZCcpO1xudmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4vX3VzZXItYWdlbnQnKTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzI4MFxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAvVmVyc2lvblxcLzEwXFwuXFxkKyhcXC5cXGQrKT8gU2FmYXJpXFwvLy50ZXN0KHVzZXJBZ2VudCksICdTdHJpbmcnLCB7XG4gIHBhZEVuZDogZnVuY3Rpb24gcGFkRW5kKG1heExlbmd0aCAvKiAsIGZpbGxTdHJpbmcgPSAnICcgKi8pIHtcbiAgICByZXR1cm4gJHBhZCh0aGlzLCBtYXhMZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBmYWxzZSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgJHBhZCA9IHJlcXVpcmUoJy4vX3N0cmluZy1wYWQnKTtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuL191c2VyLWFnZW50Jyk7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8yODBcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogL1ZlcnNpb25cXC8xMFxcLlxcZCsoXFwuXFxkKyk/IFNhZmFyaVxcLy8udGVzdCh1c2VyQWdlbnQpLCAnU3RyaW5nJywge1xuICBwYWRTdGFydDogZnVuY3Rpb24gcGFkU3RhcnQobWF4TGVuZ3RoIC8qICwgZmlsbFN0cmluZyA9ICcgJyAqLykge1xuICAgIHJldHVybiAkcGFkKHRoaXMsIG1heExlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRydWUpO1xuICB9XG59KTtcbiIsInZhciAkaXRlcmF0b3JzID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciBJVEVSQVRPUiA9IHdrcygnaXRlcmF0b3InKTtcbnZhciBUT19TVFJJTkdfVEFHID0gd2tzKCd0b1N0cmluZ1RhZycpO1xudmFyIEFycmF5VmFsdWVzID0gSXRlcmF0b3JzLkFycmF5O1xuXG52YXIgRE9NSXRlcmFibGVzID0ge1xuICBDU1NSdWxlTGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIENTU1N0eWxlRGVjbGFyYXRpb246IGZhbHNlLFxuICBDU1NWYWx1ZUxpc3Q6IGZhbHNlLFxuICBDbGllbnRSZWN0TGlzdDogZmFsc2UsXG4gIERPTVJlY3RMaXN0OiBmYWxzZSxcbiAgRE9NU3RyaW5nTGlzdDogZmFsc2UsXG4gIERPTVRva2VuTGlzdDogdHJ1ZSxcbiAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IGZhbHNlLFxuICBGaWxlTGlzdDogZmFsc2UsXG4gIEhUTUxBbGxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTENvbGxlY3Rpb246IGZhbHNlLFxuICBIVE1MRm9ybUVsZW1lbnQ6IGZhbHNlLFxuICBIVE1MU2VsZWN0RWxlbWVudDogZmFsc2UsXG4gIE1lZGlhTGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIE1pbWVUeXBlQXJyYXk6IGZhbHNlLFxuICBOYW1lZE5vZGVNYXA6IGZhbHNlLFxuICBOb2RlTGlzdDogdHJ1ZSxcbiAgUGFpbnRSZXF1ZXN0TGlzdDogZmFsc2UsXG4gIFBsdWdpbjogZmFsc2UsXG4gIFBsdWdpbkFycmF5OiBmYWxzZSxcbiAgU1ZHTGVuZ3RoTGlzdDogZmFsc2UsXG4gIFNWR051bWJlckxpc3Q6IGZhbHNlLFxuICBTVkdQYXRoU2VnTGlzdDogZmFsc2UsXG4gIFNWR1BvaW50TGlzdDogZmFsc2UsXG4gIFNWR1N0cmluZ0xpc3Q6IGZhbHNlLFxuICBTVkdUcmFuc2Zvcm1MaXN0OiBmYWxzZSxcbiAgU291cmNlQnVmZmVyTGlzdDogZmFsc2UsXG4gIFN0eWxlU2hlZXRMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgVGV4dFRyYWNrQ3VlTGlzdDogZmFsc2UsXG4gIFRleHRUcmFja0xpc3Q6IGZhbHNlLFxuICBUb3VjaExpc3Q6IGZhbHNlXG59O1xuXG5mb3IgKHZhciBjb2xsZWN0aW9ucyA9IGdldEtleXMoRE9NSXRlcmFibGVzKSwgaSA9IDA7IGkgPCBjb2xsZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICB2YXIgTkFNRSA9IGNvbGxlY3Rpb25zW2ldO1xuICB2YXIgZXhwbGljaXQgPSBET01JdGVyYWJsZXNbTkFNRV07XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgcHJvdG8gPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICB2YXIga2V5O1xuICBpZiAocHJvdG8pIHtcbiAgICBpZiAoIXByb3RvW0lURVJBVE9SXSkgaGlkZShwcm90bywgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgICBpZiAoIXByb3RvW1RPX1NUUklOR19UQUddKSBoaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBBcnJheVZhbHVlcztcbiAgICBpZiAoZXhwbGljaXQpIGZvciAoa2V5IGluICRpdGVyYXRvcnMpIGlmICghcHJvdG9ba2V5XSkgcmVkZWZpbmUocHJvdG8sIGtleSwgJGl0ZXJhdG9yc1trZXldLCB0cnVlKTtcbiAgfVxufVxuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5CLCB7XG4gIHNldEltbWVkaWF0ZTogJHRhc2suc2V0LFxuICBjbGVhckltbWVkaWF0ZTogJHRhc2suY2xlYXJcbn0pO1xuIiwiLy8gaWU5LSBzZXRUaW1lb3V0ICYgc2V0SW50ZXJ2YWwgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZpeFxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuL191c2VyLWFnZW50Jyk7XG52YXIgc2xpY2UgPSBbXS5zbGljZTtcbnZhciBNU0lFID0gL01TSUUgLlxcLi8udGVzdCh1c2VyQWdlbnQpOyAvLyA8LSBkaXJ0eSBpZTktIGNoZWNrXG52YXIgd3JhcCA9IGZ1bmN0aW9uIChzZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChmbiwgdGltZSAvKiAsIC4uLmFyZ3MgKi8pIHtcbiAgICB2YXIgYm91bmRBcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgdmFyIGFyZ3MgPSBib3VuZEFyZ3MgPyBzbGljZS5jYWxsKGFyZ3VtZW50cywgMikgOiBmYWxzZTtcbiAgICByZXR1cm4gc2V0KGJvdW5kQXJncyA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbikpLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gOiBmbiwgdGltZSk7XG4gIH07XG59O1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkIgKyAkZXhwb3J0LkYgKiBNU0lFLCB7XG4gIHNldFRpbWVvdXQ6IHdyYXAoZ2xvYmFsLnNldFRpbWVvdXQpLFxuICBzZXRJbnRlcnZhbDogd3JhcChnbG9iYWwuc2V0SW50ZXJ2YWwpXG59KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBJbiBzbG9wcHkgbW9kZSwgdW5ib3VuZCBgdGhpc2AgcmVmZXJzIHRvIHRoZSBnbG9iYWwgb2JqZWN0LCBmYWxsYmFjayB0b1xuICAvLyBGdW5jdGlvbiBjb25zdHJ1Y3RvciBpZiB3ZSdyZSBpbiBnbG9iYWwgc3RyaWN0IG1vZGUuIFRoYXQgaXMgc2FkbHkgYSBmb3JtXG4gIC8vIG9mIGluZGlyZWN0IGV2YWwgd2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXG4gIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKClcbik7XG4iLCIvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyB4dGVuZFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5pbXBvcnQge1h0VXRpbH0gZnJvbSAnLi4vLi4vLi4vc2NyaXB0cy94dGVuZC11dGlscyc7XG4iLCIvKiEgeHRlbmQgKGh0dHBzOi8vZ2V0eHRlbmQuY29tLylcbkBjb3B5cmlnaHQgKGMpIDIwMTcgLSAyMDE4IFJpY2NhcmRvIENhcm9saVxuQGxpY2Vuc2UgTUlUIChodHRwczovL2dpdGh1Yi5jb20vbWluaW1pdC94dGVuZC1saWJyYXJ5L2Jsb2IvbWFzdGVyL0xJQ0VOU0UpICovXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0ICdiYWJlbC1wb2x5ZmlsbCc7XG5cbmltcG9ydCB7WHRUb2dnbGUsIFh0RHJvcCwgWHRPdmVybGF5LCBYdEZhZGUsIFh0U3RpY2t5fSBmcm9tICcuL3h0ZW5kJztcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gY29uc3RydWN0b3Jcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuY29uc3QgWHRVdGlsID0ge307XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIHByb3BlcnRpZXNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8gWHQgY3VycmVudHMgYmFzZWQgb24gbmFtZXNwYWNlIChzbyBzaGFyZWQgYmV0d2VlbiBYdCBvYmplY3RzKVxuXG5YdFV0aWwuY3VycmVudHMgPSB7fTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gbWV0aG9kc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIGluaXQgYWxsIGRhdGEteHQgY2xhc3Nlc1xuICovXG5YdFV0aWwuaW5pdEFsbCA9IGZ1bmN0aW9uIChjb250YWluZXIgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgLy8geHQtdG9nZ2xlXG4gIEFycmF5LmZyb20oY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXh0LXRvZ2dsZV0nKSkuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICBuZXcgWHRUb2dnbGUoZWwpO1xuICB9KTtcbiAgQXJyYXkuZnJvbShjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEteHQtZHJvcF0nKSkuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICBuZXcgWHREcm9wKGVsKTtcbiAgfSk7XG4gIEFycmF5LmZyb20oY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXh0LW92ZXJsYXldJykpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgbmV3IFh0T3ZlcmxheShlbCk7XG4gIH0pO1xuICBBcnJheS5mcm9tKGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS14dC1mYWRlXScpKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgIG5ldyBYdEZhZGUoZWwpO1xuICB9KTtcbiAgQXJyYXkuZnJvbShjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEteHQtc3RpY2t5XScpKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgIG5ldyBYdFN0aWNreShlbCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiByZXF1ZXN0IGFuaW1hdGlvbiBmcmFtZVxuICogQHJldHVybnMge051bWJlcn0gYW5pbWF0aW9uRnJhbWVJRFxuICogVVNBR0U6IGxldCBhbmltYXRpb25GcmFtZSA9IFh0VXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuY2FsbCh3aW5kb3csIGZ1bmN0aW9uICgpIHt9KTtcbiAqL1xuWHRVdGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuICB9O1xufSgpO1xuXG4vKipcbiAqIGNhbmNlbCBhbmltYXRpb24gZnJhbWVcbiAqIFVTQUdFOiBYdFV0aWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUuY2FsbCh3aW5kb3csIGFuaW1hdGlvbkZyYW1lSUQpO1xuICovXG5YdFV0aWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSB8fCBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGlkKTtcbiAgfTtcbn0oKTtcblxuLyoqXG4gKiBDaGVjayBpZiBldmVudCB0YXJnZXQgaXMgaW5zaWRlIGVsZW1lbnRzXG4gKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IHRvIGNoZWNrIHRhcmdldFxuICogQHBhcmFtIHtOb2RlTGlzdHxBcnJheX0gdGFyZ2V0cyBFbGVtZW50cyB0byBjaGVjayBpbnNpZGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblh0VXRpbC5jaGVja0luc2lkZSA9IGZ1bmN0aW9uIChlLCB0YXJnZXRzKSB7XG4gIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgZm9yIChsZXQgdCBvZiB0YXJnZXRzKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSB0IHx8IHQuY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICByZXN1bHQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBldmVudCB0YXJnZXQgaXMgb3V0c2lkZSBlbGVtZW50c1xuICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCB0byBjaGVjayB0YXJnZXRcbiAqIEBwYXJhbSB7Tm9kZUxpc3R8QXJyYXl9IHRhcmdldHMgRWxlbWVudHMgdG8gY2hlY2sgT3V0c2lkZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuWHRVdGlsLmNoZWNrT3V0c2lkZSA9IGZ1bmN0aW9uIChlLCB0YXJnZXRzKSB7XG4gIGxldCByZXN1bHQgPSB0cnVlO1xuICBmb3IgKGxldCB0IG9mIHRhcmdldHMpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IHQgfHwgdC5jb250YWlucyhlLnRhcmdldCkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBHZXQgc2Nyb2xsYmFyIHdpZHRoIG9mIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBTY3JvbGxiYXIgd2lkdGhcbiAqL1xuWHRVdGlsLnNjcm9sbGJhcldpZHRoID0gZnVuY3Rpb24gKCkge1xuICAvLyBhZGQgb3V0ZXJcbiAgbGV0IG91dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIG91dGVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgb3V0ZXIuc3R5bGUud2lkdGggPSAnMTAwcHgnO1xuICBvdXRlci5zdHlsZS5tc092ZXJmbG93U3R5bGUgPSAnc2Nyb2xsYmFyJzsgLy8gbmVlZGVkIGZvciBXaW5KUyBhcHBzXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3V0ZXIpO1xuICBsZXQgd2lkdGhOb1Njcm9sbCA9IG91dGVyLm9mZnNldFdpZHRoO1xuICAvLyBmb3JjZSBzY3JvbGxiYXJzXG4gIG91dGVyLnN0eWxlLm92ZXJmbG93ID0gJ3Njcm9sbCc7XG4gIC8vIGFkZCBpbm5lclxuICBsZXQgaW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgaW5uZXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gIG91dGVyLmFwcGVuZENoaWxkKGlubmVyKTtcbiAgbGV0IHdpZHRoV2l0aFNjcm9sbCA9IGlubmVyLm9mZnNldFdpZHRoO1xuICAvLyByZW1vdmVcbiAgb3V0ZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChvdXRlcik7XG4gIHJldHVybiB3aWR0aE5vU2Nyb2xsIC0gd2lkdGhXaXRoU2Nyb2xsO1xufTtcblxuLyoqXG4gKiBHZXQgdW5pcXVlIGlkXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBVbmlxdWUgaWRcbiAqL1xuWHRVdGlsLmdldFVuaXF1ZUlEID0gZnVuY3Rpb24gKCkge1xuICBYdFV0aWwudWlkID0gWHRVdGlsLnVpZCAhPT0gdW5kZWZpbmVkID8gWHRVdGlsLnVpZCA6IDA7XG4gIHJldHVybiAndW5pcXVlLWlkLScgKyAoWHRVdGlsLnVpZCsrKTtcbn07XG5cbi8qKlxuICogR2V0IHVuaXF1ZSBudW1iZXJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFVuaXF1ZSBudW1iZXJcbiAqL1xuWHRVdGlsLmdldFVuaXF1ZU51bSA9IGZ1bmN0aW9uICgpIHtcbiAgWHRVdGlsLnVudW1iZXIgPSBYdFV0aWwudW51bWJlciAhPT0gdW5kZWZpbmVkID8gWHRVdGlsLnVudW1iZXIgOiAwO1xuICByZXR1cm4gWHRVdGlsLnVudW1iZXIrKztcbn07XG5cbi8qKlxuICogTWVyZ2Ugb2JqZWN0c1xuICogQHBhcmFtIHtBcnJheX0gYXJyIEFycmF5IG9mIG9iamVjdHMgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIHtPYmplY3R9IE1lcmdlZCBvYmplY3RcbiAqL1xuWHRVdGlsLm1lcmdlID0gZnVuY3Rpb24gKGFycikge1xuICBsZXQgZmluYWwgPSB7fTtcbiAgZm9yIChsZXQgb2JqIG9mIGFycikge1xuICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvYmopKSB7XG4gICAgICBmaW5hbFtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaW5hbDtcbn07XG5cbi8qKlxuICogTWFrZSBhbiBhcnJheSB3aGVuIGVsZW1lbnQgaXMgb25seSBvbmVcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cblh0VXRpbC5hcnJTaW5nbGUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5sZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxldCBhcnIgPSBuZXcgQXJyYXkoMSk7XG4gICAgYXJyWzBdID0gZWxlbWVudDtcbiAgICByZXR1cm4gYXJyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZSBET00gZWxlbWVudCBmcm9tIGh0bWwgc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIEh0bWwgc3RyaW5nIChvbmx5IDEgcm9vdCBodG1sIHRhZylcbiAqIEByZXR1cm4ge05vZGV8SFRNTEVsZW1lbnR9IERPTSBlbGVtZW50XG4gKi9cblh0VXRpbC5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHN0cikge1xuICBsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pbm5lckhUTUwgPSBzdHIudHJpbSgpO1xuICByZXR1cm4gZGl2LmZpcnN0Q2hpbGQ7XG59O1xuXG4vKipcbiAqIFF1ZXJ5IGVsZW1lbnQncyBwYXJlbnRzXG4gKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IGVsZW1lbnQgQ2hpbGQgZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5IFF1ZXJ5IHBhcmVudHNcbiAqIEByZXR1cm4ge0FycmF5fSBQYXJlbnRzIGVsZW1lbnRzIGJ5IHF1ZXJ5XG4gKi9cblh0VXRpbC5wYXJlbnRzID0gZnVuY3Rpb24gKGVsZW1lbnQsIHF1ZXJ5KSB7XG4gIGxldCBwYXJlbnRzID0gW107XG4gIHdoaWxlIChlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50LmNsb3Nlc3QocXVlcnkpKSB7XG4gICAgcGFyZW50cy5wdXNoKGVsZW1lbnQpO1xuICB9XG4gIHJldHVybiBwYXJlbnRzO1xufTtcblxuLyoqXG4gKiBkYXRhU3RvcmFnZVxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjkyMjIwMjcvdmFuaWxsYS1hbHRlcm5hdGl2ZS10by1qcXVlcnktZGF0YS1mdW5jdGlvbi1hbnktbmF0aXZlLWphdmFzY3JpcHQtYWx0ZXJuYXRpXG4gKiBVU0FHRTogWHRVdGlsLmRhdGFTdG9yYWdlLnB1dChlbGVtZW50LCAna2V5JywgdmFsdWUpO1xuICovXG5YdFV0aWwuZGF0YVN0b3JhZ2UgPSB7XG4gIF9zdG9yYWdlOiBuZXcgV2Vha01hcCgpLFxuICBwdXQ6IGZ1bmN0aW9uIChlbGVtZW50LCBrZXksIG9iaikge1xuICAgIGlmICghdGhpcy5fc3RvcmFnZS5oYXMoa2V5KSkge1xuICAgICAgdGhpcy5fc3RvcmFnZS5zZXQoZWxlbWVudCwgbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgdGhpcy5fc3RvcmFnZS5nZXQoZWxlbWVudCkuc2V0KGtleSwgb2JqKTtcbiAgICByZXR1cm4gdGhpcy5fc3RvcmFnZS5nZXQoZWxlbWVudCkuZ2V0KGtleSk7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24gKGVsZW1lbnQsIGtleSkge1xuICAgIHJldHVybiB0aGlzLl9zdG9yYWdlLmdldChlbGVtZW50KS5nZXQoa2V5KTtcbiAgfSxcbiAgaGFzOiBmdW5jdGlvbiAoZWxlbWVudCwga2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2UuZ2V0KGVsZW1lbnQpLmhhcyhrZXkpO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uIChlbGVtZW50LCBrZXkpIHtcbiAgICBsZXQgcmV0ID0gdGhpcy5fc3RvcmFnZS5nZXQoZWxlbWVudCkuZGVsZXRlKGtleSk7XG4gICAgaWYgKCF0aGlzLl9zdG9yYWdlLmdldChrZXkpLnNpemUgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLl9zdG9yYWdlLmRlbGV0ZShlbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxufTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gYXBpXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbndpbmRvdy5YdFV0aWwgPSBYdFV0aWw7XG5leHBvcnQge1h0VXRpbH07XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIHNjb3BlIHBvbHlmaWxsXG4vLyBodHRwczovL2dpdGh1Yi5jb20vam9uYXRoYW50bmVhbC9lbGVtZW50LXFzYS1zY29wZVxuLy8gVVNBR0U6IHF1ZXJ5U2VsZWN0b3JBbGwoJzpzY29wZSA+IC5zZWxlY3RvcicpO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG50cnkge1xuICAvLyB0ZXN0IGZvciBzY29wZSBzdXBwb3J0XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJzpzY29wZSAqJyk7XG59IGNhdGNoIChlcnJvcikge1xuICAoZnVuY3Rpb24gKEVsZW1lbnRQcm90b3R5cGUpIHtcbiAgICAvLyBzY29wZSByZWdleFxuICAgIHZhciBzY29wZSA9IC86c2NvcGUoPyFbXFx3LV0pL2dpO1xuXG4gICAgLy8gcG9seWZpbGwgRWxlbWVudCNxdWVyeVNlbGVjdG9yXG4gICAgdmFyIHF1ZXJ5U2VsZWN0b3JXaXRoU2NvcGUgPSBwb2x5ZmlsbChFbGVtZW50UHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IpO1xuXG4gICAgRWxlbWVudFByb3RvdHlwZS5xdWVyeVNlbGVjdG9yID0gZnVuY3Rpb24gcXVlcnlTZWxlY3RvcihzZWxlY3RvcnMpIHtcbiAgICAgIHJldHVybiBxdWVyeVNlbGVjdG9yV2l0aFNjb3BlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIC8vIHBvbHlmaWxsIEVsZW1lbnQjcXVlcnlTZWxlY3RvckFsbFxuICAgIHZhciBxdWVyeVNlbGVjdG9yQWxsV2l0aFNjb3BlID0gcG9seWZpbGwoRWxlbWVudFByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsKTtcblxuICAgIEVsZW1lbnRQcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbCA9IGZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3JzKSB7XG4gICAgICByZXR1cm4gcXVlcnlTZWxlY3RvckFsbFdpdGhTY29wZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICAvLyBwb2x5ZmlsbCBFbGVtZW50I21hdGNoZXNcbiAgICBpZiAoRWxlbWVudFByb3RvdHlwZS5tYXRjaGVzKSB7XG4gICAgICB2YXIgbWF0Y2hlc1dpdGhTY29wZSA9IHBvbHlmaWxsKEVsZW1lbnRQcm90b3R5cGUubWF0Y2hlcyk7XG5cbiAgICAgIEVsZW1lbnRQcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uIG1hdGNoZXMoc2VsZWN0b3JzKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzV2l0aFNjb3BlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIHBvbHlmaWxsIEVsZW1lbnQjY2xvc2VzdFxuICAgIGlmIChFbGVtZW50UHJvdG90eXBlLmNsb3Nlc3QpIHtcbiAgICAgIHZhciBjbG9zZXN0V2l0aFNjb3BlID0gcG9seWZpbGwoRWxlbWVudFByb3RvdHlwZS5jbG9zZXN0KTtcblxuICAgICAgRWxlbWVudFByb3RvdHlwZS5jbG9zZXN0ID0gZnVuY3Rpb24gY2xvc2VzdChzZWxlY3RvcnMpIHtcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3RXaXRoU2NvcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9seWZpbGwocXNhKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHNlbGVjdG9ycykge1xuICAgICAgICAvLyB3aGV0aGVyIHRoZSBzZWxlY3RvcnMgY29udGFpbiA6c2NvcGVcbiAgICAgICAgdmFyIGhhc1Njb3BlID0gc2VsZWN0b3JzICYmIHNjb3BlLnRlc3Qoc2VsZWN0b3JzKTtcblxuICAgICAgICBpZiAoaGFzU2NvcGUpIHtcbiAgICAgICAgICAvLyBmYWxsYmFjayBhdHRyaWJ1dGVcbiAgICAgICAgICB2YXIgYXR0ciA9ICdxJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDkwMDAwMDApICsgMTAwMDAwMDtcblxuICAgICAgICAgIC8vIHJlcGxhY2UgOnNjb3BlIHdpdGggdGhlIGZhbGxiYWNrIGF0dHJpYnV0ZVxuICAgICAgICAgIGFyZ3VtZW50c1swXSA9IHNlbGVjdG9ycy5yZXBsYWNlKHNjb3BlLCAnWycgKyBhdHRyICsgJ10nKTtcblxuICAgICAgICAgIC8vIGFkZCB0aGUgZmFsbGJhY2sgYXR0cmlidXRlXG4gICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoYXR0ciwgJycpO1xuXG4gICAgICAgICAgLy8gcmVzdWx0cyBvZiB0aGUgcXNhXG4gICAgICAgICAgdmFyIGVsZW1lbnRPck5vZGVMaXN0ID0gcXNhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAvLyByZW1vdmUgdGhlIGZhbGxiYWNrIGF0dHJpYnV0ZVxuICAgICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuXG4gICAgICAgICAgLy8gcmV0dXJuIHRoZSByZXN1bHRzIG9mIHRoZSBxc2FcbiAgICAgICAgICByZXR1cm4gZWxlbWVudE9yTm9kZUxpc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcmV0dXJuIHRoZSByZXN1bHRzIG9mIHRoZSBxc2FcbiAgICAgICAgICByZXR1cm4gcXNhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9KShFbGVtZW50LnByb3RvdHlwZSk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIG1hdGNoZXMgcG9seWZpbGxcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qb25hdGhhbnRuZWFsL2Nsb3Nlc3Rcbi8vIFVTQUdFOiBlbGVtZW50Lm1hdGNoZXMocXVlcnkpO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLypcbihmdW5jdGlvbiAocHJvdG8pIHtcbiAgaWYgKHR5cGVvZiBwcm90by5tYXRjaGVzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcHJvdG8ubWF0Y2hlcyA9IHByb3RvLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IHByb3RvLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBmdW5jdGlvbiBtYXRjaGVzKHF1ZXJ5KSB7XG4gICAgICBsZXQgZWwgPSB0aGlzO1xuICAgICAgbGV0IGVscyA9IChlbC5kb2N1bWVudCB8fCBlbC5vd25lckRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KTtcbiAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICB3aGlsZSAoZWxzW2luZGV4XSAmJiBlbHNbaW5kZXhdICE9PSBlbCkge1xuICAgICAgICArK2luZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIEJvb2xlYW4oZWxzW2luZGV4XSk7XG4gICAgfTtcbiAgfVxufSkoRWxlbWVudC5wcm90b3R5cGUpO1xuKi9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGNsb3Nlc3QgcG9seWZpbGxcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qb25hdGhhbnRuZWFsL2Nsb3Nlc3Rcbi8vIFVTQUdFOiBlbGVtZW50LmNsb3Nlc3QocXVlcnkpO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKlxuKGZ1bmN0aW9uIChwcm90bykge1xuICBpZiAodHlwZW9mIHByb3RvLmNsb3Nlc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm90by5jbG9zZXN0ID0gZnVuY3Rpb24gY2xvc2VzdChxdWVyeSkge1xuICAgICAgbGV0IGVsID0gdGhpcztcbiAgICAgIHdoaWxlIChlbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICBpZiAoZWwubWF0Y2hlcyhxdWVyeSkpIHtcbiAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgZWwgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgfVxufSkoRWxlbWVudC5wcm90b3R5cGUpO1xuKi9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEN1c3RvbUV2ZW50IHBvbHlmaWxsXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQvQ3VzdG9tRXZlbnRcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuKGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMpIHtcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge2J1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgZGV0YWlsOiB1bmRlZmluZWR9O1xuICAgIGxldCBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuICAgIHJldHVybiBldnQ7XG4gIH1cblxuICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xuICB3aW5kb3cuQ3VzdG9tRXZlbnQgPSBDdXN0b21FdmVudDtcbn0pKCk7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIHNjcm9sbGluZ0VsZW1lbnQgcG9seWZpbGxcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS95YW5nZy9zY3JvbGxpbmctZWxlbWVudFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4oZnVuY3Rpb24gKCkge1xuICBpZiAoZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgZWxlbWVudCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gc2Nyb2xsaW5nRWxlbWVudCgpIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCkge1xuICAgICAgLy8gc3BlZWQgdXAgaWYgc2Nyb2xsVG9wID4gMFxuICAgICAgcmV0dXJuIChlbGVtZW50ID0gZG9jdW1lbnQuYm9keSk7XG4gICAgfVxuICAgIGxldCBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBpZnJhbWUuc3R5bGUuaGVpZ2h0ID0gJzFweCc7XG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgbGV0IGRvYyA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICAgIGRvYy53cml0ZSgnPCFET0NUWVBFIGh0bWw+PGRpdiBzdHlsZT1cImhlaWdodDo5OTk5ZW1cIj54PC9kaXY+Jyk7XG4gICAgZG9jLmNsb3NlKCk7XG4gICAgbGV0IGlzQ29tcGxpYW50ID0gZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2MuYm9keS5zY3JvbGxIZWlnaHQ7XG4gICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICByZXR1cm4gKGVsZW1lbnQgPSBpc0NvbXBsaWFudCA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA6IGRvY3VtZW50LmJvZHkpO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRvY3VtZW50LCAnc2Nyb2xsaW5nRWxlbWVudCcsIHtcbiAgICBnZXQ6IHNjcm9sbGluZ0VsZW1lbnRcbiAgfSlcbn0pKCk7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGFwcGVuZCBwb2x5ZmlsbFxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1BhcmVudE5vZGUvYXBwZW5kXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbihmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0uaGFzT3duUHJvcGVydHkoJ2FwcGVuZCcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdGVtLCAnYXBwZW5kJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZCgpIHtcbiAgICAgICAgbGV0IGFyZ0FyciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgICAgZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgICAgICBhcmdBcnIuZm9yRWFjaChmdW5jdGlvbiAoYXJnSXRlbSkge1xuICAgICAgICAgIGxldCBpc05vZGUgPSBhcmdJdGVtIGluc3RhbmNlb2YgTm9kZTtcbiAgICAgICAgICBkb2NGcmFnLmFwcGVuZENoaWxkKGlzTm9kZSA/IGFyZ0l0ZW0gOiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoYXJnSXRlbSkpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChkb2NGcmFnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59KShbRWxlbWVudC5wcm90b3R5cGUsIERvY3VtZW50LnByb3RvdHlwZSwgRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGVdKTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gYmVmb3JlIHBvbHlmaWxsXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2hpbGROb2RlL2JlZm9yZVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4oZnVuY3Rpb24gKGFycikge1xuICBhcnIuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtLmhhc093blByb3BlcnR5KCdiZWZvcmUnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaXRlbSwgJ2JlZm9yZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBiZWZvcmUoKSB7XG4gICAgICAgIGxldCBhcmdBcnIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgIGRvY0ZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICAgICAgYXJnQXJyLmZvckVhY2goZnVuY3Rpb24gKGFyZ0l0ZW0pIHtcbiAgICAgICAgICBsZXQgaXNOb2RlID0gYXJnSXRlbSBpbnN0YW5jZW9mIE5vZGU7XG4gICAgICAgICAgZG9jRnJhZy5hcHBlbmRDaGlsZChpc05vZGUgPyBhcmdJdGVtIDogZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGFyZ0l0ZW0pKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZG9jRnJhZywgdGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufSkoW0VsZW1lbnQucHJvdG90eXBlLCBDaGFyYWN0ZXJEYXRhLnByb3RvdHlwZSwgRG9jdW1lbnRUeXBlLnByb3RvdHlwZV0pO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBlbnRyaWVzIHBvbHlmaWxsXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvZW50cmllc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4oZnVuY3Rpb24gKG9iaikge1xuICBpZiAoIW9iai5lbnRyaWVzKSB7XG4gICAgb2JqLmVudHJpZXMgPSBmdW5jdGlvbiggb2JqICl7XG4gICAgICBsZXQgb3duUHJvcHMgPSBPYmplY3Qua2V5cyggb2JqICksXG4gICAgICAgIGkgPSBvd25Qcm9wcy5sZW5ndGgsXG4gICAgICAgIHJlc0FycmF5ID0gbmV3IEFycmF5KGkpOyAvLyBwcmVhbGxvY2F0ZSB0aGUgQXJyYXlcbiAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgIHJlc0FycmF5W2ldID0gW293blByb3BzW2ldLCBvYmpbb3duUHJvcHNbaV1dXTtcblxuICAgICAgcmV0dXJuIHJlc0FycmF5O1xuICAgIH07XG4gIH1cbn0pKE9iamVjdCk7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEFycmF5LmZyb20gcG9seWZpbGxcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2Zyb21cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuKGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKCFhcnIuZnJvbSkge1xuICAgIGFyci5mcm9tID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gICAgICB2YXIgaXNDYWxsYWJsZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nIHx8IHRvU3RyLmNhbGwoZm4pID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgICAgfTtcbiAgICAgIHZhciB0b0ludGVnZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIG51bWJlciA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgIGlmIChpc05hTihudW1iZXIpKSB7IHJldHVybiAwOyB9XG4gICAgICAgIGlmIChudW1iZXIgPT09IDAgfHwgIWlzRmluaXRlKG51bWJlcikpIHsgcmV0dXJuIG51bWJlcjsgfVxuICAgICAgICByZXR1cm4gKG51bWJlciA+IDAgPyAxIDogLTEpICogTWF0aC5mbG9vcihNYXRoLmFicyhudW1iZXIpKTtcbiAgICAgIH07XG4gICAgICB2YXIgbWF4U2FmZUludGVnZXIgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuICAgICAgdmFyIHRvTGVuZ3RoID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBsZW4gPSB0b0ludGVnZXIodmFsdWUpO1xuICAgICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobGVuLCAwKSwgbWF4U2FmZUludGVnZXIpO1xuICAgICAgfTtcblxuICAgICAgLy8gVGhlIGxlbmd0aCBwcm9wZXJ0eSBvZiB0aGUgZnJvbSBtZXRob2QgaXMgMS5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZS8qLCBtYXBGbiwgdGhpc0FyZyAqLykge1xuICAgICAgICAvLyAxLiBMZXQgQyBiZSB0aGUgdGhpcyB2YWx1ZS5cbiAgICAgICAgdmFyIEMgPSB0aGlzO1xuXG4gICAgICAgIC8vIDIuIExldCBpdGVtcyBiZSBUb09iamVjdChhcnJheUxpa2UpLlxuICAgICAgICB2YXIgaXRlbXMgPSBPYmplY3QoYXJyYXlMaWtlKTtcblxuICAgICAgICAvLyAzLiBSZXR1cm5JZkFicnVwdChpdGVtcykuXG4gICAgICAgIGlmIChhcnJheUxpa2UgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LmZyb20gcmVxdWlyZXMgYW4gYXJyYXktbGlrZSBvYmplY3QgLSBub3QgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDQuIElmIG1hcGZuIGlzIHVuZGVmaW5lZCwgdGhlbiBsZXQgbWFwcGluZyBiZSBmYWxzZS5cbiAgICAgICAgdmFyIG1hcEZuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB2b2lkIHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIFQ7XG4gICAgICAgIGlmICh0eXBlb2YgbWFwRm4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gNS4gZWxzZVxuICAgICAgICAgIC8vIDUuIGEgSWYgSXNDYWxsYWJsZShtYXBmbikgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgICBpZiAoIWlzQ2FsbGFibGUobWFwRm4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5mcm9tOiB3aGVuIHByb3ZpZGVkLCB0aGUgc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDUuIGIuIElmIHRoaXNBcmcgd2FzIHN1cHBsaWVkLCBsZXQgVCBiZSB0aGlzQXJnOyBlbHNlIGxldCBUIGJlIHVuZGVmaW5lZC5cbiAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIFQgPSBhcmd1bWVudHNbMl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMTAuIExldCBsZW5WYWx1ZSBiZSBHZXQoaXRlbXMsIFwibGVuZ3RoXCIpLlxuICAgICAgICAvLyAxMS4gTGV0IGxlbiBiZSBUb0xlbmd0aChsZW5WYWx1ZSkuXG4gICAgICAgIHZhciBsZW4gPSB0b0xlbmd0aChpdGVtcy5sZW5ndGgpO1xuXG4gICAgICAgIC8vIDEzLiBJZiBJc0NvbnN0cnVjdG9yKEMpIGlzIHRydWUsIHRoZW5cbiAgICAgICAgLy8gMTMuIGEuIExldCBBIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2RcbiAgICAgICAgLy8gb2YgQyB3aXRoIGFuIGFyZ3VtZW50IGxpc3QgY29udGFpbmluZyB0aGUgc2luZ2xlIGl0ZW0gbGVuLlxuICAgICAgICAvLyAxNC4gYS4gRWxzZSwgTGV0IEEgYmUgQXJyYXlDcmVhdGUobGVuKS5cbiAgICAgICAgdmFyIEEgPSBpc0NhbGxhYmxlKEMpID8gT2JqZWN0KG5ldyBDKGxlbikpIDogbmV3IEFycmF5KGxlbik7XG5cbiAgICAgICAgLy8gMTYuIExldCBrIGJlIDAuXG4gICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgLy8gMTcuIFJlcGVhdCwgd2hpbGUgayA8IGxlbuKApiAoYWxzbyBzdGVwcyBhIC0gaClcbiAgICAgICAgdmFyIGtWYWx1ZTtcbiAgICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcbiAgICAgICAgICBrVmFsdWUgPSBpdGVtc1trXTtcbiAgICAgICAgICBpZiAobWFwRm4pIHtcbiAgICAgICAgICAgIEFba10gPSB0eXBlb2YgVCA9PT0gJ3VuZGVmaW5lZCcgPyBtYXBGbihrVmFsdWUsIGspIDogbWFwRm4uY2FsbChULCBrVmFsdWUsIGspO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBBW2tdID0ga1ZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMTguIExldCBwdXRTdGF0dXMgYmUgUHV0KEEsIFwibGVuZ3RoXCIsIGxlbiwgdHJ1ZSkuXG4gICAgICAgIEEubGVuZ3RoID0gbGVuO1xuICAgICAgICAvLyAyMC4gUmV0dXJuIEEuXG4gICAgICAgIHJldHVybiBBO1xuICAgICAgfTtcbiAgICB9KCkpO1xuICB9XG59KShBcnJheSk7XG4iLCIvKiB4dGVuZCAoaHR0cHM6Ly9nZXR4dGVuZC5jb20vKVxuQGNvcHlyaWdodCAoYykgMjAxNyAtIDIwMTggUmljY2FyZG8gQ2Fyb2xpXG5AbGljZW5zZSBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS9taW5pbWl0L3h0ZW5kLWxpYnJhcnkvYmxvYi9tYXN0ZXIvTElDRU5TRSkgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgJ2JhYmVsLXBvbHlmaWxsJztcblxuaW1wb3J0IHtYdFV0aWx9IGZyb20gJy4veHRlbmQtdXRpbHMnO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBYdFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5jbGFzcyBYdCB7XG5cbiAgLyoqXG4gICAqIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gb2JqZWN0IEJhc2Ugbm9kZVxuICAgKiBAcGFyYW0ge09iamVjdH0ganNPcHRpb25zIFVzZXIgb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciBBdHRyaWJ1dGUgbmFtZSB3aXRoIGpzb24gb3B0aW9uc1xuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9iamVjdCwganNPcHRpb25zID0ge30sIGF0dHIpIHtcbiAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICBpZiAodGhpcy5vYmplY3QpIHtcbiAgICAgIHRoaXMuZGVmYXVsdHMgPSB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRzO1xuICAgICAgLy8ganMgb3B0aW9uc1xuICAgICAgdGhpcy5vcHRpb25zID0gWHRVdGlsLm1lcmdlKFt0aGlzLmRlZmF1bHRzLCBqc09wdGlvbnNdKTtcbiAgICAgIC8vIG1hcmt1cCBvcHRpb25zXG4gICAgICBsZXQgbWFya3VwT3B0aW9ucyA9IHRoaXMub2JqZWN0LmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IFh0VXRpbC5tZXJnZShbdGhpcy5vcHRpb25zLCBtYXJrdXBPcHRpb25zID8gSlNPTi5wYXJzZShtYXJrdXBPcHRpb25zKSA6IHt9XSk7XG4gICAgICAvLyBjbGFzc2VzXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNsYXNzKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5jbGFzc2VzID0gWy4uLnRoaXMub3B0aW9ucy5jbGFzcy5zcGxpdCgnICcpXTtcbiAgICAgIH1cbiAgICAgIC8vIGluaXRcbiAgICAgIHRoaXMuaW5pdFNldHVwKCk7XG4gICAgICB0aGlzLmluaXRTY29wZSgpO1xuICAgICAgdGhpcy5pbml0RXZlbnRzKCk7XG4gICAgICB0aGlzLmluaXRBcmlhKCk7XG4gICAgfVxuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBpbml0XG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAvKipcbiAgICogc2V0dXAgbmFtZXNwYWNlLCBjb250YWluZXIgYW5kIG9wdGlvbnNcbiAgICovXG4gIGluaXRTZXR1cCgpIHtcbiAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgbGV0IG9wdGlvbnMgPSBzZWxmLm9wdGlvbnM7XG4gICAgLy8gc2V0dXAgKGJhc2VkIG9uIHh0ZW5kIG1vZGUpXG4gICAgaWYgKG9wdGlvbnMudGFyZ2V0cyAmJiBvcHRpb25zLnRhcmdldHMuaW5kZXhPZignIycpICE9PSAtMSkge1xuICAgICAgLy8geHRlbmQgYWxsIG1vZGVcbiAgICAgIHRoaXMubW9kZSA9ICdhbGwnO1xuICAgICAgdGhpcy5jb250YWluZXIgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICBvcHRpb25zLm1heCA9IEluZmluaXR5O1xuICAgICAgdGhpcy5uYW1lc3BhY2UgPSBvcHRpb25zLnRhcmdldHMudG9TdHJpbmcoKSArICctJyArIG9wdGlvbnMuY2xhc3Nlcy50b1N0cmluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB4dGVuZCB1bmlxdWUgbW9kZVxuICAgICAgdGhpcy5tb2RlID0gJ3VuaXF1ZSc7XG4gICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMub2JqZWN0O1xuICAgICAgdGhpcy5uYW1lc3BhY2UgPSBYdFV0aWwuZ2V0VW5pcXVlSUQoKTtcbiAgICB9XG4gICAgLy8gZmluYWwgbmFtZXNwYWNlXG4gICAgdGhpcy5uYW1lc3BhY2UgPSB0aGlzLm5hbWVzcGFjZS5yZXBsYWNlKC9cXFcrL2csICcnKTtcbiAgICAvLyBjdXJyZW50cyBhcnJheSBiYXNlZCBvbiBuYW1lc3BhY2UgKHNvIHNoYXJlZCBiZXR3ZWVuIFh0IG9iamVjdHMpXG4gICAgaWYgKCF0aGlzLmdldEN1cnJlbnRzKCkpIHtcbiAgICAgIHRoaXMuc2V0Q3VycmVudHMoW10pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBpbml0IGVsZW1lbnRzLCB0YXJnZXRzIGFuZCBjdXJyZW50c1xuICAgKi9cbiAgaW5pdFNjb3BlKCkge1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBsZXQgb3B0aW9ucyA9IHNlbGYub3B0aW9ucztcbiAgICAvLyBlbGVtZW50c1xuICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcbiAgICBpZiAob3B0aW9ucy5lbGVtZW50cykge1xuICAgICAgdGhpcy5lbGVtZW50cyA9IFh0VXRpbC5hcnJTaW5nbGUodGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChvcHRpb25zLmVsZW1lbnRzKSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5lbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZWxlbWVudHMgPSBYdFV0aWwuYXJyU2luZ2xlKHRoaXMub2JqZWN0KTtcbiAgICAgIC8vIEBGSVggb24gbmV4dCBmcmFtZSBzZXQgYWxsIGVsZW1lbnRzIHF1ZXJ5aW5nIHRoZSBuYW1lc3BhY2VcbiAgICAgIFh0VXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuY2FsbCh3aW5kb3csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IG5hbWVzcGFjZVF1ZXJ5ID0gJ1tkYXRhLXh0LWlkPScgKyBzZWxmLm5hbWVzcGFjZSArICddJztcbiAgICAgICAgc2VsZi5lbGVtZW50cyA9IFh0VXRpbC5hcnJTaW5nbGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwobmFtZXNwYWNlUXVlcnkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyB0YXJnZXRzXG4gICAgaWYgKG9wdGlvbnMudGFyZ2V0cykge1xuICAgICAgbGV0IGFyciA9IEFycmF5LmZyb20odGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChvcHRpb25zLnRhcmdldHMpKTtcbiAgICAgIGFyciA9IGFyci5maWx0ZXIoeCA9PiAhWHRVdGlsLnBhcmVudHMoeCwgb3B0aW9ucy50YXJnZXRzKS5sZW5ndGgpOyAvLyBmaWx0ZXIgb3V0IHBhcmVudFxuICAgICAgdGhpcy50YXJnZXRzID0gYXJyO1xuICAgIH1cbiAgICAvLyBhcHBlbmRUb1xuICAgIGlmIChvcHRpb25zLmFwcGVuZFRvKSB7XG4gICAgICBsZXQgYXBwZW5kVG9UYXJnZXQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChvcHRpb25zLmFwcGVuZFRvKTtcbiAgICAgIGlmIChhcHBlbmRUb1RhcmdldC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy50YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgYXBwZW5kVG9UYXJnZXRbMF0uYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQEZJWCBzZXQgbmFtZXNwYWNlIGZvciBuZXh0IGZyYW1lXG4gICAgZm9yIChsZXQgZWwgb2YgdGhpcy5lbGVtZW50cykge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLXh0LWlkJywgc2VsZi5uYW1lc3BhY2UpO1xuICAgIH1cbiAgICAvLyBjdXJyZW50c1xuICAgIFh0VXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuY2FsbCh3aW5kb3csIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLmVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAvLyBhY3RpdmF0ZSBvcHRpb25zLmNsYXNzXG4gICAgICAgIGZvciAobGV0IGVsIG9mIHNlbGYuZWxlbWVudHMpIHtcbiAgICAgICAgICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKC4uLm9wdGlvbnMuY2xhc3NlcykpIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoLi4ub3B0aW9ucy5jbGFzc2VzKTsgLy8gcmVtb3ZlIHRvIGFjdGl2YXRlIGFsc28gdGFyZ2V0c1xuICAgICAgICAgICAgc2VsZi5ldmVudE9uKGVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgY3VycmVudHMgPCBtaW5cbiAgICAgICAgbGV0IHRvZG8gPSBvcHRpb25zLm1pbiAtIHNlbGYuZ2V0Q3VycmVudHMoKS5sZW5ndGg7XG4gICAgICAgIGlmICh0b2RvKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2RvOyBpKyspIHtcbiAgICAgICAgICAgIHNlbGYuZXZlbnRPbihzZWxmLmVsZW1lbnRzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpbml0IGFyaWFcbiAgICovXG4gIGluaXRBcmlhKCkge1xuICAgIGlmICh0aGlzLnRhcmdldHMpIHtcbiAgICAgIGZvciAobGV0IHRyIG9mIHRoaXMudGFyZ2V0cykge1xuICAgICAgICAvLyBhcmlhLWxhYmVsXG4gICAgICAgIGxldCBoZWFkZXJzID0gdHIucXVlcnlTZWxlY3RvckFsbCgnaDEsIGgyLCBoMywgaDQsIGg1LCBoNicpO1xuICAgICAgICBsZXQgbGFiZWwgPSBoZWFkZXJzLmxlbmd0aCA/IGhlYWRlcnMgOiB0aGlzLmdldEVsZW1lbnRzRnJvbVRhcmdldCh0cik7XG4gICAgICAgIGlmIChsYWJlbC5sZW5ndGgpIHtcbiAgICAgICAgICBsYWJlbCA9IGxhYmVsWzBdLmlubmVyVGV4dC5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpO1xuICAgICAgICAgIHRyLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBpbml0IGV2ZW50c1xuICAgKi9cbiAgaW5pdEV2ZW50cygpIHtcbiAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgbGV0IG9wdGlvbnMgPSBzZWxmLm9wdGlvbnM7XG4gICAgLy8gZXZlbnRzXG4gICAgZm9yIChsZXQgZWwgb2YgdGhpcy5lbGVtZW50cykge1xuICAgICAgaWYgKG9wdGlvbnMub24pIHtcbiAgICAgICAgLy8gaGFuZGxlclxuICAgICAgICBsZXQgeHRPbkhhbmRsZXIgPSBYdFV0aWwuZGF0YVN0b3JhZ2UucHV0KGVsLCAneHRPbkhhbmRsZXInLCBzZWxmLmV2ZW50T25IYW5kbGVyLmJpbmQoc2VsZikuYmluZChzZWxmLCBlbCkpO1xuICAgICAgICAvLyBldmVudFxuICAgICAgICBsZXQgZXZlbnRzID0gWy4uLm9wdGlvbnMub24uc3BsaXQoJyAnKV07XG4gICAgICAgIGZvciAobGV0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIHh0T25IYW5kbGVyKTtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB4dE9uSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbGlzdGVuZXJcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignb24udHJpZ2dlcicsIHh0T25IYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLm9mZikge1xuICAgICAgICAvLyBoYW5kbGVyXG4gICAgICAgIGxldCB4dE9mZkhhbmRsZXIgPSBYdFV0aWwuZGF0YVN0b3JhZ2UucHV0KGVsLCAneHRPZmZIYW5kbGVyJywgc2VsZi5ldmVudE9mZkhhbmRsZXIuYmluZChzZWxmKS5iaW5kKHNlbGYsIGVsKSk7XG4gICAgICAgIC8vIGV2ZW50XG4gICAgICAgIGxldCBldmVudHMgPSBbLi4ub3B0aW9ucy5vZmYuc3BsaXQoJyAnKV07XG4gICAgICAgIGZvciAobGV0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIHh0T2ZmSGFuZGxlcik7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgeHRPZmZIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsaXN0ZW5lclxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdvZmYudHJpZ2dlcicsIHh0T2ZmSGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGxpc3RlbmVyXG4gICAgZm9yIChsZXQgdHIgb2YgdGhpcy50YXJnZXRzKSB7XG4gICAgICBsZXQgZWwgPSB0aGlzLmdldEVsZW1lbnRzRnJvbVRhcmdldCh0cilbMF07XG4gICAgICBpZiAoZWwpIHtcbiAgICAgICAgLy8gaGFuZGxlclxuICAgICAgICBsZXQgeHRPbkhhbmRsZXIgPSBYdFV0aWwuZGF0YVN0b3JhZ2UucHV0KGVsLCAneHRPbkhhbmRsZXInLCBzZWxmLmV2ZW50T25IYW5kbGVyLmJpbmQoc2VsZikuYmluZChzZWxmLCBlbCkpO1xuICAgICAgICBsZXQgeHRPZmZIYW5kbGVyID0gWHRVdGlsLmRhdGFTdG9yYWdlLnB1dChlbCwgJ3h0T2ZmSGFuZGxlcicsIHNlbGYuZXZlbnRPZmZIYW5kbGVyLmJpbmQoc2VsZikuYmluZChzZWxmLCBlbCkpO1xuICAgICAgICAvLyBsaXN0ZW5lclxuICAgICAgICB0ci5hZGRFdmVudExpc3RlbmVyKCdvbi50cmlnZ2VyJywgeHRPbkhhbmRsZXIpO1xuICAgICAgICB0ci5hZGRFdmVudExpc3RlbmVyKCdvZmYudHJpZ2dlcicsIHh0T2ZmSGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGF1dG9cbiAgICBpZiAob3B0aW9ucy5hdXRvKSB7XG4gICAgICB0aGlzLmF1dG8oKTtcbiAgICAgIC8vIGZvY3VzIGFuZCBibHVyXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuYXV0bygpO1xuICAgICAgfSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5hdXRvU3RvcCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGVsZW1lbnQgb24gaGFuZGxlclxuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgZXZlbnRPbkhhbmRsZXIoZWxlbWVudCwgZSkge1xuICAgIGxldCBldmVudExpbWl0ID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnLmV2ZW50LWxpbWl0Jyk7XG4gICAgaWYgKGV2ZW50TGltaXQubGVuZ3RoKSB7XG4gICAgICBpZiAoWHRVdGlsLmNoZWNrT3V0c2lkZShlLCBldmVudExpbWl0KSkge1xuICAgICAgICB0aGlzLmV2ZW50T24oZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXZlbnRPbihlbGVtZW50KTtcbiAgICB9XG4gICAgLy8gYXV0b1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1BhdXNlKSB7XG4gICAgICB0aGlzLmF1dG9QYXVzZSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmF1dG8pIHtcbiAgICAgIHRoaXMuYXV0bygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBlbGVtZW50IG9mZiBoYW5kbGVyXG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqL1xuICBldmVudE9mZkhhbmRsZXIoZWxlbWVudCwgZSkge1xuICAgIGxldCBldmVudExpbWl0ID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnLmV2ZW50LWxpbWl0Jyk7XG4gICAgaWYgKGV2ZW50TGltaXQubGVuZ3RoKSB7XG4gICAgICBpZiAoWHRVdGlsLmNoZWNrT3V0c2lkZShlLCBldmVudExpbWl0KSkge1xuICAgICAgICB0aGlzLmV2ZW50T2ZmKGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV2ZW50T2ZmKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBzZXQgYXV0byBjaGFuZ2VcbiAgICogQHBhcmFtIHtCb29sZWFufSBpbnN0YW50XG4gICAqL1xuICBhdXRvKGluc3RhbnQgPSBmYWxzZSkge1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBsZXQgb3B0aW9ucyA9IHNlbGYub3B0aW9ucztcbiAgICAvLyBhdXRvXG4gICAgdGhpcy5hdXRvU3RvcCgpO1xuICAgIGxldCB0aW1lID0gIWluc3RhbnQgPyBvcHRpb25zLmF1dG8gOiAwO1xuICAgIHNlbGYuYXV0b0ludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFvcHRpb25zLmF1dG9BbHdheXMgJiYgc2VsZi5vYmplY3Qub2Zmc2V0UGFyZW50ID09PSBudWxsKSB7IC8vIGlmIG5vdCA6dmlzaWJsZSBkb24ndCBjaGFuZ2VcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgc2VsZi5hdXRvQ3VycmVudCA9IHNlbGYuYXV0b0N1cnJlbnQgIT09IHVuZGVmaW5lZCA/IHNlbGYuYXV0b0N1cnJlbnQgKyAxIDogMDtcbiAgICAgIHNlbGYuYXV0b0N1cnJlbnQgPSBzZWxmLmF1dG9DdXJyZW50ID49IHNlbGYuZWxlbWVudHMubGVuZ3RoID8gMCA6IHNlbGYuYXV0b0N1cnJlbnQ7XG4gICAgICBzZWxmLmV2ZW50T24oc2VsZi5lbGVtZW50c1tzZWxmLmF1dG9DdXJyZW50XSk7XG4gICAgfSwgdGltZSk7XG4gIH1cblxuICAvKipcbiAgICogc2V0IGF1dG9QYXVzZSBjaGFuZ2VcbiAgICogQHBhcmFtIHtCb29sZWFufSBpbnN0YW50XG4gICAqL1xuICBhdXRvUGF1c2UoaW5zdGFudCA9IGZhbHNlKSB7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBvcHRpb25zID0gc2VsZi5vcHRpb25zO1xuICAgIC8vIGF1dG9QYXVzZVxuICAgIHRoaXMuYXV0b1N0b3AoKTtcbiAgICBsZXQgdGltZSA9ICFpbnN0YW50ID8gb3B0aW9ucy5hdXRvUGF1c2UgOiAwO1xuICAgIGlmICh0aW1lICE9PSAnc3RvcCcpIHtcbiAgICAgIHNlbGYuYXV0b1BhdXNlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmF1dG8odHJ1ZSk7XG4gICAgICAgIHNlbGYuYXV0bygpO1xuICAgICAgfSwgdGltZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHN0b3AgYXV0byBjaGFuZ2VcbiAgICovXG4gIGF1dG9TdG9wKCkge1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5hdXRvSW50ZXJ2YWwpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmF1dG9QYXVzZVRpbWVvdXQpO1xuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyB1dGlsc1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgLyoqXG4gICAqIGNob29zZSB3aGljaCBlbGVtZW50cyB0byBhY3RpdmF0ZS9kZWFjdGl2YXRlIChiYXNlZCBvbiB4dGVuZCBtb2RlIGFuZCBjb250YWluZXJzKVxuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHRyaWdnZXJlZCBpbnRlcmFjdGlvblxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3QuYWxsIGFuZCBvYmplY3Quc2luZ2xlXG4gICAqL1xuICBnZXRFbGVtZW50cyhlbGVtZW50KSB7XG4gICAgaWYgKCF0aGlzLmVsZW1lbnRzIHx8ICF0aGlzLmVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHthbGw6IFtdLCBzaW5nbGU6IG51bGx9O1xuICAgIH1cbiAgICBpZiAodGhpcy5tb2RlID09PSAnYWxsJykge1xuICAgICAgLy8gY2hvb3NlIGFsbCBlbGVtZW50c1xuICAgICAgcmV0dXJuIHthbGw6IHRoaXMuZWxlbWVudHMsIHNpbmdsZTogdGhpcy5lbGVtZW50c1swXX07XG4gICAgfSBlbHNlIGlmICh0aGlzLm1vZGUgPT09ICd1bmlxdWUnKSB7XG4gICAgICAvLyBjaG9vc2UgZWxlbWVudCBieSBncm91cFxuICAgICAgbGV0IGdyb3VwID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZ3JvdXAnKTtcbiAgICAgIGlmIChncm91cCkge1xuICAgICAgICAvLyBhbGwgZ3JvdXAgZWxlbWVudHMgaWYgZ3JvdXBcbiAgICAgICAgbGV0IGdyb3VwRWxlbWVudHMgPSBBcnJheS5mcm9tKHRoaXMuZWxlbWVudHMpLmZpbHRlcih4ID0+IHguZ2V0QXR0cmlidXRlKCdkYXRhLWdyb3VwJykgPT09IGdyb3VwKTtcbiAgICAgICAgbGV0IGZpbmFsID0gWHRVdGlsLmFyclNpbmdsZShncm91cEVsZW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHthbGw6IGZpbmFsLCBzaW5nbGU6IGZpbmFsWzBdfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVsZW1lbnQgaWYgbm90IGdyb3VwXG4gICAgICAgIGxldCBmaW5hbCA9IGVsZW1lbnQ7XG4gICAgICAgIHJldHVybiB7YWxsOiBYdFV0aWwuYXJyU2luZ2xlKGZpbmFsKSwgc2luZ2xlOiBmaW5hbH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGNob29zZSB3aGljaCB0YXJnZXRzIHRvIGFjdGl2YXRlL2RlYWN0aXZhdGUgKGJhc2VkIG9uIHh0ZW5kIG1vZGUgYW5kIGNvbnRhaW5lcnMpXG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgdHJpZ2dlcmVkIGludGVyYWN0aW9uXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG4gIGdldFRhcmdldHMoZWxlbWVudCkge1xuICAgIGlmICghdGhpcy50YXJnZXRzIHx8ICF0aGlzLnRhcmdldHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmICh0aGlzLm1vZGUgPT09ICdhbGwnKSB7XG4gICAgICAvLyBjaG9vc2UgYWxsIHRhcmdldHNcbiAgICAgIHJldHVybiB0aGlzLnRhcmdldHM7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1vZGUgPT09ICd1bmlxdWUnKSB7XG4gICAgICAvLyBjaG9vc2Ugb25seSB0YXJnZXQgYnkgZ3JvdXBcbiAgICAgIGxldCBncm91cCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWdyb3VwJyk7XG4gICAgICBsZXQgZ3JvdXBFbGVtZW50cyA9IEFycmF5LmZyb20odGhpcy5lbGVtZW50cykuZmlsdGVyKHggPT4geC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZ3JvdXAnKSA9PT0gZ3JvdXApO1xuICAgICAgbGV0IGdyb3VwVGFyZ2V0cyA9IEFycmF5LmZyb20odGhpcy50YXJnZXRzKS5maWx0ZXIoeCA9PiB4LmdldEF0dHJpYnV0ZSgnZGF0YS1ncm91cCcpID09PSBncm91cCk7XG4gICAgICBsZXQgZmluYWw7XG4gICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgLy8gYWxsIGdyb3VwIHRhcmdldHMgaWYgZ3JvdXBcbiAgICAgICAgZmluYWwgPSBncm91cFRhcmdldHM7XG4gICAgICAgIHJldHVybiBYdFV0aWwuYXJyU2luZ2xlKGZpbmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdCBncm91cCB0YXJnZXRzIGJ5IGluZGV4IGlmIG5vdCBncm91cFxuICAgICAgICBsZXQgaW5kZXggPSBncm91cEVsZW1lbnRzLmZpbmRJbmRleCh4ID0+IHggPT09IGVsZW1lbnQpO1xuICAgICAgICBmaW5hbCA9IGdyb3VwVGFyZ2V0c1tpbmRleF07XG4gICAgICAgIHJldHVybiBYdFV0aWwuYXJyU2luZ2xlKGZpbmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogY2hvb3NlIHdoaWNoIGVsZW1lbnRzIHRvIGFjdGl2YXRlL2RlYWN0aXZhdGUgZnJvbSB0YXJnZXQgKGJhc2VkIG9uIHh0ZW5kIG1vZGUgYW5kIGNvbnRhaW5lcnMpXG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gZWxlbWVudCBUYXJnZXQgdG8gdHJpZ2dlciBpbnRlcmFjdGlvbiBvblxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuICBnZXRFbGVtZW50c0Zyb21UYXJnZXQodGFyZ2V0KSB7XG4gICAgaWYgKCF0aGlzLmVsZW1lbnRzIHx8ICF0aGlzLmVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvLyBjaG9vc2Ugb25seSB0YXJnZXQgYnkgZ3JvdXBcbiAgICBsZXQgZ3JvdXAgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWdyb3VwJyk7XG4gICAgbGV0IGdyb3VwRWxlbWVudHMgPSBBcnJheS5mcm9tKHRoaXMuZWxlbWVudHMpLmZpbHRlcih4ID0+IHguZ2V0QXR0cmlidXRlKCdkYXRhLWdyb3VwJykgPT09IGdyb3VwKTtcbiAgICBsZXQgZ3JvdXBUYXJnZXRzID0gQXJyYXkuZnJvbSh0aGlzLnRhcmdldHMpLmZpbHRlcih4ID0+IHguZ2V0QXR0cmlidXRlKCdkYXRhLWdyb3VwJykgPT09IGdyb3VwKTtcbiAgICBsZXQgZmluYWw7XG4gICAgaWYgKGdyb3VwKSB7XG4gICAgICAvLyBhbGwgZ3JvdXAgdGFyZ2V0cyBpZiBncm91cFxuICAgICAgZmluYWwgPSBncm91cEVsZW1lbnRzO1xuICAgICAgcmV0dXJuIFh0VXRpbC5hcnJTaW5nbGUoZmluYWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub3QgZ3JvdXAgdGFyZ2V0cyBieSBpbmRleCBpZiBub3QgZ3JvdXBcbiAgICAgIGxldCBpbmRleCA9IGdyb3VwVGFyZ2V0cy5maW5kSW5kZXgoeCA9PiB4ID09PSB0YXJnZXQpO1xuICAgICAgZmluYWwgPSBncm91cEVsZW1lbnRzW2luZGV4XTtcbiAgICAgIHJldHVybiBYdFV0aWwuYXJyU2luZ2xlKGZpbmFsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogYWRkaXRpb25hbCBlbGVtZW50cyB0byBhY3RpdmF0ZS9kZWFjdGl2YXRlXG4gICAqIEByZXR1cm5zIHtOb2RlTGlzdHxBcnJheX1cbiAgICovXG4gIGdldEFkZGl0aW9uYWwoKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuYWRkaXRpb25hbCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5vYmplY3QucXVlcnlTZWxlY3RvckFsbCh0aGlzLm9wdGlvbnMuYWRkaXRpb25hbCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGdldCBjdXJyZW50cyBiYXNlZCBvbiBuYW1lc3BhY2UgKHNvIHNoYXJlZCBiZXR3ZWVuIFh0IG9iamVjdHMpXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG4gIGdldEN1cnJlbnRzKCkge1xuICAgIHJldHVybiBYdFV0aWwuY3VycmVudHNbdGhpcy5uYW1lc3BhY2VdO1xuICB9XG5cbiAgLyoqXG4gICAqIHNldCBjdXJyZW50cyBiYXNlZCBvbiBuYW1lc3BhY2UgKHNvIHNoYXJlZCBiZXR3ZWVuIFh0IG9iamVjdHMpXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICAgKi9cbiAgc2V0Q3VycmVudHMoYXJyKSB7XG4gICAgWHRVdGlsLmN1cnJlbnRzW3RoaXMubmFtZXNwYWNlXSA9IGFycjtcbiAgfVxuXG4gIC8qKlxuICAgKiBhZGQgY3VycmVudCBiYXNlZCBvbiBuYW1lc3BhY2UgKHNvIHNoYXJlZCBiZXR3ZWVuIFh0IG9iamVjdHMpXG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gZWxlbWVudCBUbyBiZSBhZGRlZFxuICAgKi9cbiAgYWRkQ3VycmVudChlbGVtZW50KSB7XG4gICAgbGV0IGFyciA9IFh0VXRpbC5jdXJyZW50c1t0aGlzLm5hbWVzcGFjZV07XG4gICAgYXJyLnB1c2goZWxlbWVudCk7XG4gIH1cblxuICAvKipcbiAgICogcmVtb3ZlIGN1cnJlbnRzIGJhc2VkIG9uIG5hbWVzcGFjZSAoc28gc2hhcmVkIGJldHdlZW4gWHQgb2JqZWN0cylcbiAgICogQHBhcmFtIHtOb2RlfEhUTUxFbGVtZW50fSBlbGVtZW50IFRvIGJlIHJlbW92ZWRcbiAgICovXG4gIHJlbW92ZUN1cnJlbnQoZWxlbWVudCkge1xuICAgIFh0VXRpbC5jdXJyZW50c1t0aGlzLm5hbWVzcGFjZV0gPSBYdFV0aWwuY3VycmVudHNbdGhpcy5uYW1lc3BhY2VdLmZpbHRlcih4ID0+IHggIT09IGVsZW1lbnQpO1xuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBldmVudHNcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIC8qKlxuICAgKiBjaGVjayBlbGVtZW50IG9uXG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gZWxlbWVudCBUbyBiZSBhY3RpdmF0ZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIGV2ZW50T24gY2hhbmdlcyBhY3RpdmF0aW9uXG4gICAqL1xuICBjaGVja09uKGVsZW1lbnQpIHtcbiAgICBpZiAoKCFlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyguLi50aGlzLm9wdGlvbnMuY2xhc3NlcykgfHwgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ29mZi1ibG9jaycpKSAmJiAhZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ29uLWJsb2NrJykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGNoZWNrIGVsZW1lbnQgb2ZmXG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gZWxlbWVudCBUbyBiZSBhY3RpdmF0ZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IElmIGV2ZW50T2ZmIGNoYW5nZXMgYWN0aXZhdGlvblxuICAgKi9cbiAgY2hlY2tPZmYoZWxlbWVudCkge1xuICAgIC8vIGlmIGN1cnJlbnRzIDwgbWluXG4gICAgbGV0IHRvZG8gPSB0aGlzLm9wdGlvbnMubWluIC0gdGhpcy5nZXRDdXJyZW50cygpLmxlbmd0aDtcbiAgICBpZiAoIXRvZG8pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyguLi50aGlzLm9wdGlvbnMuY2xhc3NlcykgfHwgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ29uLWJsb2NrJykpICYmICFlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnb2ZmLWJsb2NrJykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGVsZW1lbnQgb25cbiAgICogQHBhcmFtIHtOb2RlfEhUTUxFbGVtZW50fSBlbGVtZW50IFRvIGJlIGFjdGl2YXRlZFxuICAgKi9cbiAgZXZlbnRPbihlbGVtZW50KSB7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBvcHRpb25zID0gc2VsZi5vcHRpb25zO1xuICAgIC8vIGFjdGl2YXRlIG9yIGRlYWN0aXZhdGVcbiAgICBpZiAodGhpcy5jaGVja09uKGVsZW1lbnQpKSB7XG4gICAgICBsZXQgZkVsZW1lbnRzID0gdGhpcy5nZXRFbGVtZW50cyhlbGVtZW50KTtcbiAgICAgIHRoaXMuYWRkQ3VycmVudChmRWxlbWVudHMuc2luZ2xlKTtcbiAgICAgIGxldCB0YXJnZXRzID0gdGhpcy5nZXRUYXJnZXRzKGVsZW1lbnQpO1xuICAgICAgbGV0IGFkZGl0aW9uYWwgPSB0aGlzLmdldEFkZGl0aW9uYWwoKTtcbiAgICAgIGxldCBhY3RpdmF0aW9uRGVsYXkgPSB7XG4gICAgICAgIGVsZW1lbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi5hY3RpdmF0aW9uT24oZkVsZW1lbnRzLmFsbCwgZkVsZW1lbnRzLCAnZWxlbWVudHMnKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGFyZ2V0czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYuYWN0aXZhdGlvbk9uKHRhcmdldHMsIGZFbGVtZW50cywgJ3RhcmdldHMnKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkaXRpb25hbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYuYWN0aXZhdGlvbk9uKGFkZGl0aW9uYWwsIGZFbGVtZW50cywgJ2FkZGl0aW9uYWwnKTtcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgICAvLyBzZXQgYXV0b0N1cnJlbnRcbiAgICAgIGlmIChvcHRpb25zLmF1dG8pIHtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgW2ksIGVsXSBvZiBzZWxmLmVsZW1lbnRzLmVudHJpZXMoKSkge1xuICAgICAgICAgIGlmIChlbCA9PT0gZWxlbWVudCkge1xuICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNlbGYuYXV0b0N1cnJlbnQgPSBpbmRleDtcbiAgICAgIH1cbiAgICAgIC8vIGlmIGN1cnJlbnRzID4gbWF4XG4gICAgICBsZXQgY3VycmVudHMgPSB0aGlzLmdldEN1cnJlbnRzKCk7XG4gICAgICBpZiAoY3VycmVudHMubGVuZ3RoID4gb3B0aW9ucy5tYXgpIHtcbiAgICAgICAgdGhpcy5ldmVudE9mZihjdXJyZW50c1swXSwgYWN0aXZhdGlvbkRlbGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2YXRpb25EZWxheS5lbGVtZW50cygpO1xuICAgICAgICBhY3RpdmF0aW9uRGVsYXkudGFyZ2V0cygpO1xuICAgICAgICBhY3RpdmF0aW9uRGVsYXkuYWRkaXRpb25hbCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy50b2dnbGUpIHtcbiAgICAgIC8vIHRvZ2dsZVxuICAgICAgdGhpcy5ldmVudE9mZihlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZWxlbWVudCBvZmZcbiAgICogQHBhcmFtIHtOb2RlfEhUTUxFbGVtZW50fSBlbGVtZW50IFRvIGJlIGRlYWN0aXZhdGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY3RpdmF0aW9uRGVsYXkgT2JqZWN0IHdpdGggZGVsYXllZCBhY3RpdmF0aW9uc1xuICAgKi9cbiAgZXZlbnRPZmYoZWxlbWVudCwgYWN0aXZhdGlvbkRlbGF5ID0gbnVsbCkge1xuICAgIC8vIGRlYWN0aXZhdGVcbiAgICBpZiAodGhpcy5jaGVja09mZihlbGVtZW50KSkge1xuICAgICAgbGV0IGZFbGVtZW50cyA9IHRoaXMuZ2V0RWxlbWVudHMoZWxlbWVudCk7XG4gICAgICB0aGlzLnJlbW92ZUN1cnJlbnQoZkVsZW1lbnRzLnNpbmdsZSk7XG4gICAgICB0aGlzLmFjdGl2YXRpb25PZmYoZkVsZW1lbnRzLmFsbCwgZkVsZW1lbnRzLCAnZWxlbWVudHMnLCBhY3RpdmF0aW9uRGVsYXkpO1xuICAgICAgbGV0IHRhcmdldHMgPSB0aGlzLmdldFRhcmdldHMoZWxlbWVudCk7XG4gICAgICB0aGlzLmFjdGl2YXRpb25PZmYodGFyZ2V0cywgZkVsZW1lbnRzLCAndGFyZ2V0cycsIGFjdGl2YXRpb25EZWxheSk7XG4gICAgICBsZXQgYWRkaXRpb25hbCA9IHRoaXMuZ2V0QWRkaXRpb25hbCgpO1xuICAgICAgdGhpcy5hY3RpdmF0aW9uT2ZmKGFkZGl0aW9uYWwsIGZFbGVtZW50cywgJ2FkZGl0aW9uYWwnLCBhY3RpdmF0aW9uRGVsYXkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBlbGVtZW50IG9uIGFjdGl2YXRpb25cbiAgICogQHBhcmFtIHtOb2RlTGlzdHxBcnJheX0gZWxzIEVsZW1lbnRzIHRvIGJlIGFjdGl2YXRlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gZkVsZW1lbnRzIEFkZGl0aW9uYWwgZWxlbWVudHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSBvZiBlbGVtZW50c1xuICAgKi9cbiAgYWN0aXZhdGlvbk9uKGVscywgZkVsZW1lbnRzLCB0eXBlKSB7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBvcHRpb25zID0gc2VsZi5vcHRpb25zO1xuICAgIC8vIGFjdGl2YXRlXG4gICAgbGV0IGFjdGl2YXRlID0gZnVuY3Rpb24gKHNlbGYsIGVsLCBmRWxlbWVudHMsIHR5cGUpIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoLi4ub3B0aW9ucy5jbGFzc2VzKTtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ291dCcpO1xuICAgICAgc2VsZi5hY3RpdmF0aW9uT25BbmltYXRlKGVsLCB0eXBlKTtcbiAgICAgIC8vIHNwZWNpYWxzXG4gICAgICBpZiAodHlwZSA9PT0gJ3RhcmdldHMnKSB7XG4gICAgICAgIHNlbGYuc3BlY2lhbENsYXNzSHRtbE9uKCk7XG4gICAgICAgIHNlbGYuc3BlY2lhbEJhY2tkcm9wKGVsKTtcbiAgICAgICAgc2VsZi5zcGVjaWFsQ2VudGVyT24oZWwpO1xuICAgICAgICBzZWxmLnNwZWNpYWxNaWRkbGVPbihlbCk7XG4gICAgICAgIHNlbGYuc3BlY2lhbENvbGxhcHNlT24oZWwpO1xuICAgICAgICBzZWxmLnNwZWNpYWxDbG9zZU9uKGVsLCBmRWxlbWVudHMuc2luZ2xlKTtcbiAgICAgICAgc2VsZi5zcGVjaWFsU2Nyb2xsYmFyT24oKTtcbiAgICAgIH1cbiAgICAgIC8vIGRpc3BhdGNoXG4gICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnb24nKSk7XG4gICAgfTtcbiAgICAvLyBkZWxheVxuICAgIGZvciAobGV0IGVsIG9mIGVscykge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnb2ZmLWJsb2NrJyk7XG4gICAgICBjbGVhclRpbWVvdXQoZWwuZGF0YXNldC54dERlbGF5VGltZW91dCk7XG4gICAgICBjbGVhclRpbWVvdXQoZWwuZGF0YXNldC54dEFuaW1UaW1lb3V0KTtcbiAgICAgIGxldCBkZWxheSA9IGVsLmRhdGFzZXQueHRPbkRlbGF5O1xuICAgICAgaWYgKGRlbGF5KSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ29uLWJsb2NrJyk7XG4gICAgICAgIGVsLmRhdGFzZXQueHREZWxheVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIChzZWxmLCBlbCwgZkVsZW1lbnRzLCB0eXBlKSB7XG4gICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnb24tYmxvY2snKTtcbiAgICAgICAgICBhY3RpdmF0ZShzZWxmLCBlbCwgZkVsZW1lbnRzLCB0eXBlKTtcbiAgICAgICAgfSwgcGFyc2VGbG9hdChkZWxheSksIHNlbGYsIGVsLCBmRWxlbWVudHMsIHR5cGUpLnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmF0ZShzZWxmLCBlbCwgZkVsZW1lbnRzLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZWxlbWVudCBvZmYgYWN0aXZhdGlvblxuICAgKiBAcGFyYW0ge05vZGVMaXN0fEFycmF5fSBlbHMgRWxlbWVudHMgdG8gYmUgZGVhY3RpdmF0ZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IGZFbGVtZW50cyBBZGRpdGlvbmFsIGVsZW1lbnRzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFR5cGUgb2YgZWxlbWVudHNcbiAgICogQHBhcmFtIHtPYmplY3R9IGFjdGl2YXRpb25EZWxheSBPYmplY3Qgd2l0aCBkZWxheWVkIGFjdGl2YXRpb25zXG4gICAqL1xuICBhY3RpdmF0aW9uT2ZmKGVscywgZkVsZW1lbnRzLCB0eXBlLCBhY3RpdmF0aW9uRGVsYXkpIHtcbiAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgbGV0IG9wdGlvbnMgPSBzZWxmLm9wdGlvbnM7XG4gICAgLy8gZGVhY3RpdmF0ZVxuICAgIGxldCBkZWFjdGl2YXRlID0gZnVuY3Rpb24gKHNlbGYsIGVsLCBmRWxlbWVudHMsIHR5cGUsIGFjdGl2YXRpb25EZWxheSkge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSguLi5vcHRpb25zLmNsYXNzZXMpO1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnb3V0Jyk7XG4gICAgICBzZWxmLmFjdGl2YXRpb25PZmZBbmltYXRlKGVsLCB0eXBlLCBhY3RpdmF0aW9uRGVsYXkpO1xuICAgICAgLy8gYWN0aXZhdGlvbkRlbGF5XG4gICAgICBpZiAoYWN0aXZhdGlvbkRlbGF5ICYmIGFjdGl2YXRpb25EZWxheVt0eXBlXSAmJiAhYWN0aXZhdGlvbkRlbGF5W3R5cGUgKyAnZG9uZSddKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmluc3RhbnQgJiYgb3B0aW9ucy5pbnN0YW50W3R5cGVdKSB7XG4gICAgICAgICAgYWN0aXZhdGlvbkRlbGF5W3R5cGVdKCk7XG4gICAgICAgICAgYWN0aXZhdGlvbkRlbGF5W3R5cGUgKyAnZG9uZSddID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gc3BlY2lhbHNcbiAgICAgIGlmICh0eXBlID09PSAndGFyZ2V0cycpIHtcbiAgICAgICAgc2VsZi5zcGVjaWFsQ2xhc3NIdG1sT2ZmKCk7XG4gICAgICAgIHNlbGYuc3BlY2lhbENvbGxhcHNlT2ZmKGVsKTtcbiAgICAgICAgc2VsZi5zcGVjaWFsQ2xvc2VPZmYoZWwpO1xuICAgICAgfVxuICAgICAgLy8gZGlzcGF0Y2hcbiAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdvZmYnKSk7XG4gICAgfTtcbiAgICAvLyBkZWxheVxuICAgIGZvciAobGV0IGVsIG9mIGVscykge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnb24tYmxvY2snKTtcbiAgICAgIGNsZWFyVGltZW91dChlbC5kYXRhc2V0Lnh0RGVsYXlUaW1lb3V0KTtcbiAgICAgIGNsZWFyVGltZW91dChlbC5kYXRhc2V0Lnh0QW5pbVRpbWVvdXQpO1xuICAgICAgbGV0IGRlbGF5ID0gZWwuZGF0YXNldC54dE9mZkRlbGF5O1xuICAgICAgaWYgKGRlbGF5KSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ29mZi1ibG9jaycpO1xuICAgICAgICBlbC5kYXRhc2V0Lnh0RGVsYXlUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoc2VsZiwgZWwsIGZFbGVtZW50cywgdHlwZSwgYWN0aXZhdGlvbkRlbGF5KSB7XG4gICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnb2ZmLWJsb2NrJyk7XG4gICAgICAgICAgZGVhY3RpdmF0ZShzZWxmLCBlbCwgZkVsZW1lbnRzLCB0eXBlLCBhY3RpdmF0aW9uRGVsYXkpO1xuICAgICAgICB9LCBwYXJzZUZsb2F0KGRlbGF5KSwgc2VsZiwgZWwsIGZFbGVtZW50cywgdHlwZSwgYWN0aXZhdGlvbkRlbGF5KS50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVhY3RpdmF0ZShzZWxmLCBlbCwgZkVsZW1lbnRzLCB0eXBlLCBhY3RpdmF0aW9uRGVsYXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBlbGVtZW50IG9uIGFuaW1hdGlvblxuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IGVsIEVsZW1lbnQgdG8gYmUgYW5pbWF0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSBvZiBlbGVtZW50XG4gICAqL1xuICBhY3RpdmF0aW9uT25BbmltYXRlKGVsLCB0eXBlKSB7XG4gICAgLy8gb25Eb25lXG4gICAgbGV0IG9uRG9uZSA9IGZ1bmN0aW9uIChlbCwgdHlwZSkge1xuICAgICAgLy8gY29sbGFwc2Utd2lkdGggYW5kIGNvbGxhcHNlLWhlaWdodFxuICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnY29sbGFwc2UtaGVpZ2h0JykpIHtcbiAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgfVxuICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnY29sbGFwc2Utd2lkdGgnKSkge1xuICAgICAgICBlbC5zdHlsZS53aWR0aCA9ICdhdXRvJztcbiAgICAgIH1cbiAgICB9O1xuICAgIC8vIGRlbGF5IG9uRG9uZVxuICAgIGxldCB0aW1pbmcgPSB0aGlzLmFjdGl2YXRpb25UaW1pbmcoZWwpO1xuICAgIGNsZWFyVGltZW91dChlbC5kYXRhc2V0Lnh0QW5pbVRpbWVvdXQpO1xuICAgIGlmICghdGltaW5nKSB7XG4gICAgICBvbkRvbmUoZWwsIHR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5kYXRhc2V0Lnh0QW5pbVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIChlbCwgdHlwZSkge1xuICAgICAgICBvbkRvbmUoZWwsIHR5cGUpO1xuICAgICAgfSwgdGltaW5nLCBlbCwgdHlwZSkudG9TdHJpbmcoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZWxlbWVudCBvZmYgYW5pbWF0aW9uXG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gZWwgRWxlbWVudCB0byBiZSBhbmltYXRlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIG9mIGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGFjdGl2YXRpb25EZWxheSBPYmplY3Qgd2l0aCBkZWxheWVkIGFjdGl2YXRpb25zXG4gICAqL1xuICBhY3RpdmF0aW9uT2ZmQW5pbWF0ZShlbCwgdHlwZSwgYWN0aXZhdGlvbkRlbGF5KSB7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBvcHRpb25zID0gc2VsZi5vcHRpb25zO1xuICAgIC8vIG9uRG9uZVxuICAgIGxldCBvbkRvbmUgPSBmdW5jdGlvbiAoZWwsIHR5cGUpIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ291dCcpO1xuICAgICAgLy8gc3BlY2lhbHNcbiAgICAgIGlmICh0eXBlID09PSAndGFyZ2V0cycpIHtcbiAgICAgICAgc2VsZi5zcGVjaWFsU2Nyb2xsYmFyT2ZmKCk7XG4gICAgICB9XG4gICAgICAvLyBhY3RpdmF0aW9uRGVsYXlcbiAgICAgIGlmIChhY3RpdmF0aW9uRGVsYXkgJiYgYWN0aXZhdGlvbkRlbGF5W3R5cGVdICYmICFhY3RpdmF0aW9uRGVsYXlbdHlwZSArICdkb25lJ10pIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmluc3RhbnQgfHwgIW9wdGlvbnMuaW5zdGFudFt0eXBlXSkge1xuICAgICAgICAgIGFjdGl2YXRpb25EZWxheVt0eXBlXSgpO1xuICAgICAgICAgIGFjdGl2YXRpb25EZWxheVt0eXBlICsgJ2RvbmUnXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIC8vIGRlbGF5IG9uRG9uZVxuICAgIGxldCB0aW1pbmcgPSB0aGlzLmFjdGl2YXRpb25UaW1pbmcoZWwpO1xuICAgIGNsZWFyVGltZW91dChlbC5kYXRhc2V0Lnh0QW5pbVRpbWVvdXQpO1xuICAgIGlmICghdGltaW5nKSB7XG4gICAgICBvbkRvbmUoZWwsIHR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5kYXRhc2V0Lnh0QW5pbVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIChlbCwgdHlwZSkge1xuICAgICAgICBvbkRvbmUoZWwsIHR5cGUpO1xuICAgICAgfSwgdGltaW5nLCBlbCwgdHlwZSkudG9TdHJpbmcoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRyYW5zaXRpb24gb3IgYW5pbWF0aW9uIHRpbWluZ1xuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IGVsIFRvIGJlIGFuaW1hdGVkXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRpbWUgaW4gbWlsbGlzZWNvbmRzXG4gICAqL1xuICBhY3RpdmF0aW9uVGltaW5nKGVsKSB7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBvcHRpb25zID0gc2VsZi5vcHRpb25zO1xuICAgIC8vIHRpbWluZ1xuICAgIGxldCB0aW1pbmcgPSBvcHRpb25zLnRpbWluZztcbiAgICBpZiAodGltaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aW1pbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgICAgbGV0IHRyYW5zaXRpb24gPSBwYXJzZUZsb2F0KHN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbikgKyBwYXJzZUZsb2F0KHN0eWxlLnRyYW5zaXRpb25EZWxheSk7XG4gICAgICBsZXQgYW5pbWF0aW9uID0gcGFyc2VGbG9hdChzdHlsZS5hbmltYXRpb25EdXJhdGlvbikgKyBwYXJzZUZsb2F0KHN0eWxlLmFuaW1hdGlvbkRlbGF5KTtcbiAgICAgIGlmICh0cmFuc2l0aW9uIHx8IGFuaW1hdGlvbikge1xuICAgICAgICB0aW1pbmcgPSBNYXRoLm1heCh0cmFuc2l0aW9uLCBhbmltYXRpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRpbWluZyAqIDEwMDA7XG4gICAgfVxuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBhY3RpdmF0aW9uIHNwZWNpYWxzXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAvKipcbiAgICogYWRkIGh0bWwgY2xhc3NcbiAgICovXG4gIHNwZWNpYWxDbGFzc0h0bWxPbigpIHtcbiAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgbGV0IG9wdGlvbnMgPSBzZWxmLm9wdGlvbnM7XG4gICAgLy9cbiAgICBpZiAob3B0aW9ucy5jbGFzc0h0bWwpIHtcbiAgICAgIGxldCBjb250YWluZXIgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCguLi5vcHRpb25zLmNsYXNzSHRtbC5zcGxpdCgnICcpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogcmVtb3ZlIGh0bWwgY2xhc3NcbiAgICovXG4gIHNwZWNpYWxDbGFzc0h0bWxPZmYoKSB7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBvcHRpb25zID0gc2VsZi5vcHRpb25zO1xuICAgIC8vXG4gICAgaWYgKG9wdGlvbnMuY2xhc3NIdG1sKSB7XG4gICAgICBsZXQgY29udGFpbmVyID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoLi4ub3B0aW9ucy5jbGFzc0h0bWwuc3BsaXQoJyAnKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGJhY2tkcm9wIGFwcGVuZCB0byBlbGVtZW50XG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gZWwgRWxlbWVudFxuICAgKi9cbiAgc3BlY2lhbEJhY2tkcm9wKGVsKSB7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBvcHRpb25zID0gc2VsZi5vcHRpb25zO1xuICAgIC8vXG4gICAgaWYgKG9wdGlvbnMuYmFja2Ryb3ApIHtcbiAgICAgIGxldCBlbGVtZW50cztcbiAgICAgIGlmIChvcHRpb25zLmJhY2tkcm9wID09PSAnb2JqZWN0Jykge1xuICAgICAgICBlbGVtZW50cyA9IFh0VXRpbC5hcnJTaW5nbGUodGhpcy5vYmplY3QpO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmJhY2tkcm9wID09PSAndGFyZ2V0cycpIHtcbiAgICAgICAgZWxlbWVudHMgPSBYdFV0aWwuYXJyU2luZ2xlKGVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnRzID0gZWwucXVlcnlTZWxlY3RvckFsbChvcHRpb25zLmJhY2tkcm9wKTtcbiAgICAgICAgaWYgKCFlbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBlbGVtZW50cyA9IHRoaXMub2JqZWN0LnF1ZXJ5U2VsZWN0b3JBbGwob3B0aW9ucy5iYWNrZHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgbGV0IGJhY2tkcm9wID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcueHQtYmFja2Ryb3AnKTtcbiAgICAgICAgaWYgKCFiYWNrZHJvcC5sZW5ndGgpIHtcbiAgICAgICAgICBiYWNrZHJvcCA9IFh0VXRpbC5jcmVhdGVFbGVtZW50KCc8ZGl2IGNsYXNzPVwieHQtYmFja2Ryb3BcIj48L2Rpdj4nKTtcbiAgICAgICAgICBlbGVtZW50LmFwcGVuZChiYWNrZHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogY2VudGVyIHBvc2l0aW9uIG9uIGFjdGl2YXRpb25cbiAgICogQHBhcmFtIHtOb2RlfEhUTUxFbGVtZW50fSBlbCBFbGVtZW50XG4gICAqL1xuICBzcGVjaWFsQ2VudGVyT24oZWwpIHtcbiAgICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdkcm9wLWNlbnRlcicpKSB7XG4gICAgICBsZXQgYWRkID0gdGhpcy5vYmplY3QuY2xpZW50V2lkdGg7XG4gICAgICBsZXQgcmVtb3ZlID0gZWwuY2xpZW50V2lkdGg7XG4gICAgICBlbC5zdHlsZS5sZWZ0ID0gKChhZGQgLSByZW1vdmUpIC8gMikgKyAncHgnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBtaWRkbGUgcG9zaXRpb24gb24gYWN0aXZhdGlvblxuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IGVsIEVsZW1lbnRcbiAgICovXG4gIHNwZWNpYWxNaWRkbGVPbihlbCkge1xuICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2Ryb3AtbWlkZGxlJykpIHtcbiAgICAgIGxldCBhZGQgPSB0aGlzLm9iamVjdC5jbGllbnRIZWlnaHQ7XG4gICAgICBsZXQgcmVtb3ZlID0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgZWwuc3R5bGUudG9wID0gKChhZGQgLSByZW1vdmUpIC8gMikgKyAncHgnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBvcGVuIGNvbGxhcHNlIG9uIGFjdGl2YXRpb25cbiAgICogQHBhcmFtIHtOb2RlfEhUTUxFbGVtZW50fSBlbCBFbGVtZW50XG4gICAqL1xuICBzcGVjaWFsQ29sbGFwc2VPbihlbCkge1xuICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2NvbGxhcHNlLWhlaWdodCcpKSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKCduby10cmFuc2l0aW9uJyk7XG4gICAgICBlbC5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgICBlbC5zdHlsZS5wYWRkaW5nVG9wID0gJyc7XG4gICAgICBlbC5zdHlsZS5wYWRkaW5nQm90dG9tID0gJyc7XG4gICAgICBsZXQgaCA9IGVsLmNsaWVudEhlaWdodCArICdweCc7XG4gICAgICBsZXQgcHQgPSBlbC5zdHlsZS5wYWRkaW5nVG9wO1xuICAgICAgbGV0IHBiID0gZWwuc3R5bGUucGFkZGluZ0JvdHRvbTtcbiAgICAgIFh0VXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuY2FsbCh3aW5kb3csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gJzAnO1xuICAgICAgICBlbC5zdHlsZS5wYWRkaW5nVG9wID0gJzAnO1xuICAgICAgICBlbC5zdHlsZS5wYWRkaW5nQm90dG9tID0gJzAnO1xuICAgICAgICBYdFV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmNhbGwod2luZG93LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnbm8tdHJhbnNpdGlvbicpO1xuICAgICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IGg7XG4gICAgICAgICAgZWwuc3R5bGUucGFkZGluZ1RvcCA9IHB0O1xuICAgICAgICAgIGVsLnN0eWxlLnBhZGRpbmdCb3R0b20gPSBwYjtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnY29sbGFwc2Utd2lkdGgnKSkge1xuICAgICAgZWwuc3R5bGUud2lkdGggPSAnYXV0byc7XG4gICAgICBlbC5zdHlsZS5wYWRkaW5nTGVmdCA9ICcnO1xuICAgICAgZWwuc3R5bGUucGFkZGluZ1JpZ2h0ID0gJyc7XG4gICAgICBsZXQgdyA9IGVsLmNsaWVudEhlaWdodCArICdweCc7XG4gICAgICBsZXQgcGwgPSBlbC5zdHlsZS5wYWRkaW5nTGVmdDtcbiAgICAgIGxldCBwciA9IGVsLnN0eWxlLnBhZGRpbmdSaWdodDtcbiAgICAgIFh0VXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuY2FsbCh3aW5kb3csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc3R5bGUud2lkdGggPSAnMCc7XG4gICAgICAgIGVsLnN0eWxlLnBhZGRpbmdMZWZ0ID0gJzAnO1xuICAgICAgICBlbC5zdHlsZS5wYWRkaW5nUmlnaHQgPSAnMCc7XG4gICAgICAgIFh0VXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuY2FsbCh3aW5kb3csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCduby10cmFuc2l0aW9uJyk7XG4gICAgICAgICAgZWwuc3R5bGUud2lkdGggPSB3O1xuICAgICAgICAgIGVsLnN0eWxlLnBhZGRpbmdMZWZ0ID0gcGw7XG4gICAgICAgICAgZWwuc3R5bGUucGFkZGluZ1JpZ2h0ID0gcHI7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGNsb3NlIGNvbGxhcHNlIG9uIGRlYWN0aXZhdGlvblxuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IGVsIEVsZW1lbnRcbiAgICovXG4gIHNwZWNpYWxDb2xsYXBzZU9mZihlbCkge1xuICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2NvbGxhcHNlLWhlaWdodCcpKSB7XG4gICAgICBsZXQgaCA9IGVsLmNsaWVudEhlaWdodCArICdweCc7XG4gICAgICBsZXQgcHQgPSBlbC5zdHlsZS5wYWRkaW5nVG9wO1xuICAgICAgbGV0IHBiID0gZWwuc3R5bGUucGFkZGluZ0JvdHRvbTtcbiAgICAgIFh0VXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuY2FsbCh3aW5kb3csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gaDtcbiAgICAgICAgZWwuc3R5bGUucGFkZGluZ1RvcCA9IHB0O1xuICAgICAgICBlbC5zdHlsZS5wYWRkaW5nQm90dG9tID0gcGI7XG4gICAgICAgIFh0VXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuY2FsbCh3aW5kb3csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSAnMCc7XG4gICAgICAgICAgZWwuc3R5bGUucGFkZGluZ1RvcCA9ICcwJztcbiAgICAgICAgICBlbC5zdHlsZS5wYWRkaW5nQm90dG9tID0gJzAnO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdjb2xsYXBzZS13aWR0aCcpKSB7XG4gICAgICBsZXQgdyA9IGVsLmNsaWVudFdpZHRoICsgJ3B4JztcbiAgICAgIGxldCBwbCA9IGVsLnN0eWxlLnBhZGRpbmdMZWZ0O1xuICAgICAgbGV0IHByID0gZWwuc3R5bGUucGFkZGluZ1JpZ2h0O1xuICAgICAgWHRVdGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZS5jYWxsKHdpbmRvdywgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS53aWR0aCA9IHc7XG4gICAgICAgIGVsLnN0eWxlLnBhZGRpbmdMZWZ0ID0gcGw7XG4gICAgICAgIGVsLnN0eWxlLnBhZGRpbmdSaWdodCA9IHByO1xuICAgICAgICBYdFV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmNhbGwod2luZG93LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUud2lkdGggPSAnMCc7XG4gICAgICAgICAgZWwuc3R5bGUucGFkZGluZ0xlZnQgPSAnMCc7XG4gICAgICAgICAgZWwuc3R5bGUucGFkZGluZ1JpZ2h0ID0gJzAnO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBhZGQgY2xvc2UgZXZlbnRzIG9uIGVsZW1lbnRcbiAgICogQHBhcmFtIHtOb2RlfEhUTUxFbGVtZW50fSBlbCBFbGVtZW50XG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gc2luZ2xlIEVsZW1lbnQgdG8gdG9nZ2xlXG4gICAqL1xuICBzcGVjaWFsQ2xvc2VPbihlbCwgc2luZ2xlKSB7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBvcHRpb25zID0gc2VsZi5vcHRpb25zO1xuICAgIC8vIGNsb3NlSW5zaWRlXG4gICAgaWYgKG9wdGlvbnMuY2xvc2VJbnNpZGUpIHtcbiAgICAgIGxldCBjbG9zZUVsZW1lbnRzID0gZWwucXVlcnlTZWxlY3RvckFsbChvcHRpb25zLmNsb3NlSW5zaWRlKTtcbiAgICAgIFh0VXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuY2FsbCh3aW5kb3csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yIChsZXQgY2xvc2VFbGVtZW50IG9mIGNsb3NlRWxlbWVudHMpIHtcbiAgICAgICAgICAvLyBoYW5kbGVyXG4gICAgICAgICAgbGV0IHNwZWNpYWxDbG9zZU9uSGFuZGxlciA9IFh0VXRpbC5kYXRhU3RvcmFnZS5wdXQoZWwsICdzcGVjaWFsQ2xvc2VPbkhhbmRsZXInLCBzZWxmLnNwZWNpYWxDbG9zZU9uSGFuZGxlci5iaW5kKHNlbGYpLmJpbmQoc2VsZiwgY2xvc2VFbGVtZW50LCBzaW5nbGUpKTtcbiAgICAgICAgICAvLyBldmVudFxuICAgICAgICAgIGNsb3NlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHNwZWNpYWxDbG9zZU9uSGFuZGxlcik7XG4gICAgICAgICAgY2xvc2VFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc3BlY2lhbENsb3NlT25IYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGNsb3NlT3V0c2lkZVxuICAgIGlmIChvcHRpb25zLmNsb3NlT3V0c2lkZSkge1xuICAgICAgbGV0IGNsb3NlRWxlbWVudHMgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChvcHRpb25zLmNsb3NlT3V0c2lkZSk7XG4gICAgICBYdFV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmNhbGwod2luZG93LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAobGV0IGNsb3NlRWxlbWVudCBvZiBjbG9zZUVsZW1lbnRzKSB7XG4gICAgICAgICAgLy8gaGFuZGxlclxuICAgICAgICAgIGxldCBzcGVjaWFsQ2xvc2VPZmZIYW5kbGVyID0gWHRVdGlsLmRhdGFTdG9yYWdlLnB1dChlbCwgJ3NwZWNpYWxDbG9zZU9mZkhhbmRsZXInLCBzZWxmLnNwZWNpYWxDbG9zZU9mZkhhbmRsZXIuYmluZChzZWxmKS5iaW5kKHNlbGYsIGVsLCBzaW5nbGUpKTtcbiAgICAgICAgICAvLyBldmVudFxuICAgICAgICAgIGNsb3NlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHNwZWNpYWxDbG9zZU9mZkhhbmRsZXIpO1xuICAgICAgICAgIGNsb3NlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHNwZWNpYWxDbG9zZU9mZkhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogcmVtb3ZlIGNsb3NlIGV2ZW50cyBvbiBlbGVtZW50XG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gZWwgRWxlbWVudFxuICAgKi9cbiAgc3BlY2lhbENsb3NlT2ZmKGVsKSB7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBvcHRpb25zID0gc2VsZi5vcHRpb25zO1xuICAgIC8vIGNsb3NlSW5zaWRlXG4gICAgaWYgKG9wdGlvbnMuY2xvc2VJbnNpZGUpIHtcbiAgICAgIGxldCBjbG9zZUVsZW1lbnRzID0gZWwucXVlcnlTZWxlY3RvckFsbChvcHRpb25zLmNsb3NlSW5zaWRlKTtcbiAgICAgIGZvciAobGV0IGNsb3NlRWxlbWVudCBvZiBjbG9zZUVsZW1lbnRzKSB7XG4gICAgICAgIC8vIGhhbmRsZXJcbiAgICAgICAgbGV0IHNwZWNpYWxDbG9zZU9uSGFuZGxlciA9IFh0VXRpbC5kYXRhU3RvcmFnZS5nZXQoZWwsICdzcGVjaWFsQ2xvc2VPbkhhbmRsZXInKTtcbiAgICAgICAgY2xvc2VFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc3BlY2lhbENsb3NlT25IYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gY2xvc2VPdXRzaWRlXG4gICAgaWYgKG9wdGlvbnMuY2xvc2VPdXRzaWRlKSB7XG4gICAgICBsZXQgY2xvc2VFbGVtZW50cyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKG9wdGlvbnMuY2xvc2VPdXRzaWRlKTtcbiAgICAgIGZvciAobGV0IGNsb3NlRWxlbWVudCBvZiBjbG9zZUVsZW1lbnRzKSB7XG4gICAgICAgIGxldCBzcGVjaWFsQ2xvc2VPZmZIYW5kbGVyID0gWHRVdGlsLmRhdGFTdG9yYWdlLmdldChlbCwgJ3NwZWNpYWxDbG9zZU9mZkhhbmRsZXInKTtcbiAgICAgICAgY2xvc2VFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc3BlY2lhbENsb3NlT2ZmSGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGVsZW1lbnQgb24gaGFuZGxlclxuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IGNoZWNrRWxcbiAgICogQHBhcmFtIHtOb2RlfEhUTUxFbGVtZW50fSBzaW5nbGVcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgc3BlY2lhbENsb3NlT25IYW5kbGVyKGNoZWNrRWwsIHNpbmdsZSwgZSkge1xuICAgIGlmIChYdFV0aWwuY2hlY2tJbnNpZGUoZSwgWHRVdGlsLmFyclNpbmdsZShjaGVja0VsKSkpIHtcbiAgICAgIHRoaXMuZXZlbnRPZmYoc2luZ2xlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZWxlbWVudCBvZmYgaGFuZGxlclxuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IGNoZWNrRWxcbiAgICogQHBhcmFtIHtOb2RlfEhUTUxFbGVtZW50fSBzaW5nbGVcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgc3BlY2lhbENsb3NlT2ZmSGFuZGxlcihjaGVja0VsLCBzaW5nbGUsIGUpIHtcbiAgICBpZiAoWHRVdGlsLmNoZWNrT3V0c2lkZShlLCBYdFV0aWwuYXJyU2luZ2xlKGNoZWNrRWwpKSkge1xuICAgICAgdGhpcy5ldmVudE9mZihzaW5nbGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBzY3JvbGxiYXIgYWN0aXZhdGlvblxuICAgKi9cbiAgc3BlY2lhbFNjcm9sbGJhck9uKCkge1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBsZXQgb3B0aW9ucyA9IHNlbGYub3B0aW9ucztcbiAgICAvL1xuICAgIGlmIChvcHRpb25zLnNjcm9sbGJhcikge1xuICAgICAgbGV0IGVsZW1lbnRzO1xuICAgICAgbGV0IHdpZHRoID0gWHRVdGlsLnNjcm9sbGJhcldpZHRoKCk7XG4gICAgICAvLyBjaGVjayBmaXhlZFxuICAgICAgZWxlbWVudHMgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnh0LWNoZWNrLWZpeGVkID4gKicpO1xuICAgICAgZm9yIChsZXQgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBsZXQgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoc3R5bGUucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3h0LWZpeGVkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCd4dC1maXhlZCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBmaXhlZFxuICAgICAgZWxlbWVudHMgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnh0LWZpeGVkJyk7XG4gICAgICBmb3IgKGxldCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gJyc7XG4gICAgICAgIGlmIChzZWxmLm5vcm1hbGl6ZVdpZHRoKGVsZW1lbnQuY2xpZW50V2lkdGgpID09PSAnJykge1xuICAgICAgICAgIGxldCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgICAgICAgbGV0IHBhZGRpbmcgPSBzdHlsZS5wYWRkaW5nUmlnaHQ7XG4gICAgICAgICAgbGV0IHN0ciA9ICdjYWxjKCcgKyBwYWRkaW5nICsgJyArICcgKyB3aWR0aCArICdweCknO1xuICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbm8tdHJhbnNpdGlvbicpO1xuICAgICAgICAgIFh0VXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuY2FsbCh3aW5kb3csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gc3RyO1xuICAgICAgICAgICAgWHRVdGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZS5jYWxsKHdpbmRvdywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ25vLXRyYW5zaXRpb24nKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBiYWNrZHJvcFxuICAgICAgZWxlbWVudHMgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnh0LWJhY2tkcm9wJyk7XG4gICAgICBmb3IgKGxldCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUucmlnaHQgPSB3aWR0aCArICdweCc7XG4gICAgICB9XG4gICAgICAvLyBzY3JvbGxcbiAgICAgIGxldCBjb250YWluZXIgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICBjb250YWluZXIuc3R5bGUucGFkZGluZ1JpZ2h0ID0gd2lkdGggKyAncHgnO1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3h0LXNjcm9sbGJhcicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBzY3JvbGxiYXIgZGVhY3RpdmF0aW9uXG4gICAqL1xuICBzcGVjaWFsU2Nyb2xsYmFyT2ZmKCkge1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBsZXQgb3B0aW9ucyA9IHNlbGYub3B0aW9ucztcbiAgICAvL1xuICAgIGlmIChvcHRpb25zLnNjcm9sbGJhcikge1xuICAgICAgbGV0IGVsZW1lbnRzO1xuICAgICAgLy8gc2Nyb2xsXG4gICAgICBsZXQgY29udGFpbmVyID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgY29udGFpbmVyLnN0eWxlLnBhZGRpbmdSaWdodCA9ICcnO1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ3h0LXNjcm9sbGJhcicpO1xuICAgICAgLy8gZml4ZWRcbiAgICAgIGVsZW1lbnRzID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy54dC1maXhlZCcpO1xuICAgICAgZm9yIChsZXQgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ25vLXRyYW5zaXRpb24nKTtcbiAgICAgICAgWHRVdGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZS5jYWxsKHdpbmRvdywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gJyc7XG4gICAgICAgICAgWHRVdGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZS5jYWxsKHdpbmRvdywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCduby10cmFuc2l0aW9uJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gYmFja2Ryb3BcbiAgICAgIGVsZW1lbnRzID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy54dC1iYWNrZHJvcCcpO1xuICAgICAgZm9yIChsZXQgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBlbGVtZW50LnN0eWxlLnJpZ2h0ID0gJyc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGlmIGZ1bGwgd2lkdGggcmV0dXJuICcnIGVsc2UgcmV0dXJuIHZhbHVlIGluIHB4XG4gICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gd2lkdGhcbiAgICogQHJldHVybnMge1N0cmluZ30gVmFsdWUgaW4gcHhcbiAgICovXG4gIG5vcm1hbGl6ZVdpZHRoKHdpZHRoKSB7XG4gICAgd2lkdGggPSBwYXJzZUZsb2F0KHdpZHRoKTtcbiAgICBpZiAod2lkdGggKyBYdFV0aWwuc2Nyb2xsYmFyV2lkdGgoKSA+PSB3aW5kb3cuaW5uZXJXaWR0aCkge1xuICAgICAgd2lkdGggPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgd2lkdGggKz0gJ3B4JztcbiAgICB9XG4gICAgcmV0dXJuIHdpZHRoO1xuICB9XG5cbn1cblxuLy8gZGVmYXVsdFxuXG5YdC5kZWZhdWx0cyA9IHtcbiAgXCJhdXRvXCI6IGZhbHNlLFxuICBcImF1dG9QYXVzZVwiOiBmYWxzZSxcbiAgXCJhdXRvQWx3YXlzXCI6IGZhbHNlXG59O1xuXG4vLyBleHBvcnRcblxud2luZG93Llh0ID0gWHQ7XG5leHBvcnQge1h0fTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gWHRUb2dnbGVcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuY2xhc3MgWHRUb2dnbGUgZXh0ZW5kcyBYdCB7XG5cbiAgLyoqXG4gICAqIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gb2JqZWN0IEJhc2Ugbm9kZVxuICAgKiBAcGFyYW0ge09iamVjdH0ganNPcHRpb25zIFVzZXIgb3B0aW9uc1xuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9iamVjdCwganNPcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihvYmplY3QsIGpzT3B0aW9ucywgJ2RhdGEteHQtdG9nZ2xlJyk7XG4gIH1cblxufVxuXG4vLyBkZWZhdWx0XG5cblh0VG9nZ2xlLmRlZmF1bHRzID0ge1xuICBcImVsZW1lbnRzXCI6IFwiOnNjb3BlID4gYSwgOnNjb3BlID4gYnV0dG9uXCIsXG4gIFwidGFyZ2V0c1wiOiBcIjpzY29wZSA+IFtjbGFzc149XFxcInRvZ2dsZS1cXFwiXSwgOnNjb3BlID4gW2NsYXNzKj1cXFwiIHRvZ2dsZS1cXFwiXVwiLFxuICBcImNsYXNzXCI6IFwiYWN0aXZlXCIsXG4gIFwiaW5zdGFudFwiOiB7XCJlbGVtZW50c1wiOiB0cnVlfSxcbiAgXCJvblwiOiBcImNsaWNrXCIsXG4gIFwidG9nZ2xlXCI6IHRydWUsXG4gIFwibWluXCI6IDAsXG4gIFwibWF4XCI6IDFcbn07XG5cbi8vIGV4cG9ydFxuXG53aW5kb3cuWHRUb2dnbGUgPSBYdFRvZ2dsZTtcbmV4cG9ydCB7WHRUb2dnbGV9O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBYdERyb3Bcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuY2xhc3MgWHREcm9wIGV4dGVuZHMgWHQge1xuXG4gIC8qKlxuICAgKiBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IG9iamVjdCBCYXNlIG5vZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGpzT3B0aW9ucyBVc2VyIG9wdGlvbnNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvYmplY3QsIGpzT3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob2JqZWN0LCBqc09wdGlvbnMsICdkYXRhLXh0LWRyb3AnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpbml0IGFyaWFcbiAgICovXG4gIGluaXRBcmlhKCkge1xuICAgIGlmICh0aGlzLnRhcmdldHMpIHtcbiAgICAgIGZvciAobGV0IHRyIG9mIHRoaXMudGFyZ2V0cykge1xuICAgICAgICAvLyBhcmlhLWxhYmVsXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWRkaXRpb25hbCkge1xuICAgICAgICAgIGxldCBsYWJlbCA9IHRoaXMuZ2V0QWRkaXRpb25hbCgpO1xuICAgICAgICAgIGlmIChsYWJlbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxhYmVsID0gbGFiZWxbMF0uaW5uZXJUZXh0LnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKCk7XG4gICAgICAgICAgICB0ci5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBsYWJlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cblxuLy8gZGVmYXVsdFxuXG5YdERyb3AuZGVmYXVsdHMgPSB7XG4gIFwiZWxlbWVudHNcIjogXCI6c2NvcGVcIixcbiAgXCJ0YXJnZXRzXCI6IFwiOnNjb3BlID4gLmRyb3BcIixcbiAgXCJhZGRpdGlvbmFsXCI6IFwiOnNjb3BlID4gYSwgOnNjb3BlID4gYnV0dG9uXCIsXG4gIFwiY2xhc3NcIjogXCJhY3RpdmVcIixcbiAgXCJpbnN0YW50XCI6IHtcImVsZW1lbnRzXCI6IHRydWV9LFxuICBcIm9uXCI6IFwiY2xpY2tcIixcbiAgXCJ0b2dnbGVcIjogdHJ1ZSxcbiAgXCJtaW5cIjogMCxcbiAgXCJtYXhcIjogMSxcbiAgXCJjbG9zZU91dHNpZGVcIjogXCJib2R5XCJcbn07XG5cbi8vIGV4cG9ydFxuXG53aW5kb3cuWHREcm9wID0gWHREcm9wO1xuZXhwb3J0IHtYdERyb3B9O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBYdE92ZXJsYXlcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuY2xhc3MgWHRPdmVybGF5IGV4dGVuZHMgWHQge1xuXG4gIC8qKlxuICAgKiBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IG9iamVjdCBCYXNlIG5vZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGpzT3B0aW9ucyBVc2VyIG9wdGlvbnNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvYmplY3QsIGpzT3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob2JqZWN0LCBqc09wdGlvbnMsICdkYXRhLXh0LW92ZXJsYXknKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpbml0IGFyaWFcbiAgICovXG4gIGluaXRBcmlhKCkge1xuICAgIHN1cGVyLmluaXRBcmlhKCk7XG4gICAgaWYgKHRoaXMudGFyZ2V0cykge1xuICAgICAgZm9yIChsZXQgdHIgb2YgdGhpcy50YXJnZXRzKSB7XG4gICAgICAgIC8vIHJvbGVcbiAgICAgICAgdHIuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2RpYWxvZycpO1xuICAgICAgICB0ci5zZXRBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnLCAndHJ1ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG5cbi8vIGRlZmF1bHRcblxuWHRPdmVybGF5LmRlZmF1bHRzID0ge1xuICBcImVsZW1lbnRzXCI6IFwiOnNjb3BlID4gYSwgOnNjb3BlID4gYnV0dG9uXCIsXG4gIFwidGFyZ2V0c1wiOiBcIjpzY29wZSA+IC5vdmVybGF5LW91dGVyXCIsXG4gIFwiY2xhc3NcIjogXCJhY3RpdmVcIixcbiAgXCJpbnN0YW50XCI6IHtcImVsZW1lbnRzXCI6IHRydWV9LFxuICBcIm9uXCI6IFwiY2xpY2tcIixcbiAgXCJ0b2dnbGVcIjogdHJ1ZSxcbiAgXCJtaW5cIjogMCxcbiAgXCJtYXhcIjogMSxcbiAgXCJhcHBlbmRUb1wiOiBcImJvZHlcIixcbiAgXCJiYWNrZHJvcFwiOiBcInRhcmdldHNcIixcbiAgXCJjbGFzc0h0bWxcIjogXCJ4dC1vdmVybGF5XCIsXG4gIFwiY2xvc2VJbnNpZGVcIjogXCIub3ZlcmxheS1kaXNtaXNzLCA6c2NvcGUgPiAueHQtYmFja2Ryb3AsIDpzY29wZSAub3ZlcmxheS1pbm5lciA+IC5idG4tY2xvc2VcIixcbiAgXCJzY3JvbGxiYXJcIjogdHJ1ZVxufTtcblxuLy8gZXhwb3J0XG5cbndpbmRvdy5YdE92ZXJsYXkgPSBYdE92ZXJsYXk7XG5leHBvcnQge1h0T3ZlcmxheX07XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFh0U3RpY2t5XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmNsYXNzIFh0U3RpY2t5IGV4dGVuZHMgWHQge1xuXG4gIC8qKlxuICAgKiBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IG9iamVjdCBCYXNlIG5vZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGpzT3B0aW9ucyBVc2VyIG9wdGlvbnNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvYmplY3QsIGpzT3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob2JqZWN0LCBqc09wdGlvbnMsICdkYXRhLXh0LXN0aWNreScpO1xuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBpbml0XG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAvKipcbiAgICogaW5pdCBlbGVtZW50cywgdGFyZ2V0cyBhbmQgY3VycmVudHNcbiAgICovXG4gIGluaXRTY29wZSgpIHtcbiAgICBzdXBlci5pbml0U2NvcGUoKTtcbiAgICAvLyBtb2RlXG4gICAgdGhpcy5tb2RlID0gJ2FsbCc7XG4gICAgLy8gY29udGFpbmVyXG4gICAgdGhpcy5jb250YWluZXIgPSBYdFV0aWwucGFyZW50cyh0aGlzLm9iamVjdCwgJy54dC1jb250YWluZXInKTtcbiAgICBpZiAoIXRoaXMuY29udGFpbmVyLmxlbmd0aCkge1xuICAgICAgdGhpcy5jb250YWluZXIgPSBYdFV0aWwuY3JlYXRlRWxlbWVudCgnPGRpdiBjbGFzcz1cInh0LWNvbnRhaW5lciB4dC1jaGVjay1maXhlZFwiPjwvZGl2PicpO1xuICAgICAgdGhpcy5vYmplY3QuYmVmb3JlKHRoaXMuY29udGFpbmVyKTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZCh0aGlzLm9iamVjdCk7XG4gICAgICB0aGlzLmNvbnRhaW5lciA9IFh0VXRpbC5wYXJlbnRzKHRoaXMub2JqZWN0LCAnLnh0LWNvbnRhaW5lcicpO1xuICAgIH1cbiAgICAvLyB0YXJnZXRzXG4gICAgdGhpcy50YXJnZXRzID0gdGhpcy5jb250YWluZXJbMF0ucXVlcnlTZWxlY3RvckFsbCgnLnh0LWNsb25lJyk7XG4gICAgaWYgKCF0aGlzLnRhcmdldHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnRhcmdldHMgPSB0aGlzLm9iamVjdC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICB0aGlzLnRhcmdldHMuY2xhc3NMaXN0LmFkZCgneHQtY2xvbmUnKTtcbiAgICAgIHRoaXMudGFyZ2V0cy5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgIGZvciAobGV0IGVsSWQgb2YgdGhpcy50YXJnZXRzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpZF0nKSkge1xuICAgICAgICBlbElkLnNldEF0dHJpYnV0ZSgnaWQnLCBlbElkLmdldEF0dHJpYnV0ZSgnaWQnKSArICctY2xvbmUnKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGVsTmFtZSBvZiB0aGlzLnRhcmdldHMucXVlcnlTZWxlY3RvckFsbCgnW25hbWVdJykpIHtcbiAgICAgICAgZWxOYW1lLnNldEF0dHJpYnV0ZSgnbmFtZScsIGVsTmFtZS5nZXRBdHRyaWJ1dGUoJ25hbWUnKSArICctY2xvbmUnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGFpbmVyWzBdLmFwcGVuZCh0aGlzLnRhcmdldHMpO1xuICAgIH1cbiAgICB0aGlzLnRhcmdldHMgPSBYdFV0aWwuYXJyU2luZ2xlKHRoaXMudGFyZ2V0cyk7XG4gICAgLy8geHQtZml4ZWRcbiAgICB0aGlzLm9iamVjdC5jbGFzc0xpc3QuYWRkKCd4dC1maXhlZCcpO1xuICAgIC8vIGhpZGVcbiAgICBpZiAodGhpcy5vcHRpb25zLmhpZGUgPT09ICdkb3duJykge1xuICAgICAgdGhpcy5vYmplY3QuY2xhc3NMaXN0LmFkZCgnc3RpY2t5LWhpZGUtZG93bicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9iamVjdC5jbGFzc0xpc3QucmVtb3ZlKCdzdGlja3ktaGlkZS1kb3duJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuaGlkZSA9PT0gJ3VwJykge1xuICAgICAgdGhpcy5vYmplY3QuY2xhc3NMaXN0LmFkZCgnc3RpY2t5LWhpZGUtdXAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vYmplY3QuY2xhc3NMaXN0LnJlbW92ZSgnc3RpY2t5LWhpZGUtdXAnKTtcbiAgICB9XG4gICAgLy8gei1pbmRleFxuICAgIHRoaXMudW5pcXVlID0gWHRVdGlsLmdldFVuaXF1ZU51bSgpO1xuICAgIHRoaXMub2JqZWN0LnN0eWxlLnpJbmRleCA9ICcnICsgKDEwMCAtIHRoaXMudW5pcXVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpbml0IGV2ZW50c1xuICAgKi9cbiAgaW5pdEV2ZW50cygpIHtcbiAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgbGV0IG9wdGlvbnMgPSBzZWxmLm9wdGlvbnM7XG4gICAgLy8gZXZlbnRzXG4gICAgaWYgKG9wdGlvbnMub24pIHtcbiAgICAgIC8vIGhhbmRsZXJcbiAgICAgIGxldCBzdGlja3lIYW5kbGVyID0gWHRVdGlsLmRhdGFTdG9yYWdlLnB1dCh3aW5kb3csICdzdGlja3lIYW5kbGVyJywgc2VsZi5ldmVudE9uSGFuZGxlci5iaW5kKHNlbGYpKTtcbiAgICAgIC8vIGV2ZW50XG4gICAgICBsZXQgZXZlbnRzID0gWy4uLm9wdGlvbnMub24uc3BsaXQoJyAnKV07XG4gICAgICBmb3IgKGxldCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIHN0aWNreUhhbmRsZXIpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgc3RpY2t5SGFuZGxlcik7XG4gICAgICB9XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb24uc3RpY2t5Jywgc3RpY2t5SGFuZGxlcik7XG4gICAgfVxuICAgIC8vIHRyaWdnZXIgaW5pdGlhbFxuICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnb24uc3RpY2t5JykpO1xuICB9XG5cbiAgLyoqXG4gICAqIGVsZW1lbnQgb24gaGFuZGxlclxuICAgKiBAcGFyYW0ge05vZGV8SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgZXZlbnRPbkhhbmRsZXIoZWxlbWVudCwgZSkge1xuICAgIHRoaXMuZXZlbnRTY3JvbGwodGhpcy5vYmplY3QpO1xuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBldmVudHNcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIC8qKlxuICAgKiB3aW5kb3cgc2Nyb2xsXG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gZWxlbWVudCBUbyBiZSBhY3RpdmF0ZWQgb3IgZGVhY3RpdmF0ZWRcbiAgICovXG4gIGV2ZW50U2Nyb2xsKGVsZW1lbnQpIHtcbiAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgbGV0IG9wdGlvbnMgPSBzZWxmLm9wdGlvbnM7XG4gICAgLy8gdmFyc1xuICAgIGxldCBhbmltID0gdHJ1ZTtcbiAgICBsZXQgaGlkZSA9IGZhbHNlO1xuICAgIGxldCBzY3JvbGxJbnZlcnNlID0gZmFsc2U7XG4gICAgbGV0IGFkZCA9IDA7XG4gICAgbGV0IGFkZEhpZGUgPSAwO1xuICAgIGxldCB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgbGV0IGVsID0gc2VsZi5vYmplY3Q7XG4gICAgbGV0IHJlY3RFbFRvcCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICBsZXQgaGVpZ2h0RWwgPSBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUoZWwpLmhlaWdodCk7XG4gICAgbGV0IGhlaWdodFRhcmdldCA9IHBhcnNlRmxvYXQoZ2V0Q29tcHV0ZWRTdHlsZShzZWxmLnRhcmdldHNbMF0pLmhlaWdodCk7XG4gICAgbGV0IHJlY3RDb250YWluZXJUb3AgPSBzZWxmLmNvbnRhaW5lclswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgbGV0IHNjcm9sbGluZ0VsZW1lbnQgPSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50O1xuICAgIGxldCBzY3JvbGxIZWlnaHQgPSBzY3JvbGxpbmdFbGVtZW50LnNjcm9sbEhlaWdodDtcbiAgICBsZXQgc2Nyb2xsVG9wID0gc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3A7XG4gICAgbGV0IHNjcm9sbFRvcE9sZCA9IHNlbGYuc2Nyb2xsVG9wT2xkO1xuICAgIC8vIGRpcmVjdGlvblxuICAgIGlmIChzY3JvbGxUb3AgPCBzY3JvbGxUb3BPbGQpIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ3N0aWNreS1kb3duJyk7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKCdzdGlja3ktdXAnKTtcbiAgICAgIHNjcm9sbEludmVyc2UgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKCdzdGlja3ktZG93bicpO1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnc3RpY2t5LXVwJyk7XG4gICAgfVxuICAgIC8vIGhpZGVcbiAgICBpZiAob3B0aW9ucy5oaWRlID09PSAnZG93bicpIHtcbiAgICAgIGlmICghc2Nyb2xsSW52ZXJzZSkge1xuICAgICAgICBhZGRIaWRlID0gaGVpZ2h0VGFyZ2V0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5oaWRlID09PSAndXAnKSB7XG4gICAgICBpZiAoc2Nyb2xsSW52ZXJzZSkge1xuICAgICAgICBhZGRIaWRlID0gaGVpZ2h0VGFyZ2V0O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBzY3JvbGxcbiAgICBsZXQgdG9wID0gc2VsZi5ldmVudFNjcm9sbFBvcyhvcHRpb25zLmxpbWl0Wyd0b3AnXSB8fCBzZWxmLnRhcmdldHMsIHNjcm9sbFRvcCwgcmVjdENvbnRhaW5lclRvcCk7XG4gICAgbGV0IGJvdHRvbSA9IHNlbGYuZXZlbnRTY3JvbGxQb3Mob3B0aW9ucy5saW1pdFsnYm90dG9tJ10sIHNjcm9sbFRvcCwgSW5maW5pdHkpO1xuICAgIGlmIChvcHRpb25zLnBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgYm90dG9tIC09IGhlaWdodFRhcmdldDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICB0b3AgLT0gd2luZG93SGVpZ2h0IC0gaGVpZ2h0VGFyZ2V0O1xuICAgICAgYm90dG9tID0gTWF0aC5hYnMoc2Nyb2xsSGVpZ2h0IC0gd2luZG93SGVpZ2h0IC0gYm90dG9tKTtcbiAgICB9XG4gICAgLy8gY29udGFpbiBhbmQgYWRkXG4gICAgbGV0IGFkZFRvcCA9IDA7XG4gICAgbGV0IGFkZEJvdHRvbSA9IDA7XG4gICAgaWYgKG9wdGlvbnMuY29udGFpbikge1xuICAgICAgaWYgKG9wdGlvbnMuY29udGFpblsndG9wJ10pIHtcbiAgICAgICAgbGV0IGFkZFRvcE9iaiA9IHNlbGYuZXZlbnRTY3JvbGxIZWlnaHQob3B0aW9ucy5jb250YWluWyd0b3AnXSwgc2Nyb2xsSW52ZXJzZSk7XG4gICAgICAgIGFkZFRvcCA9IGFkZFRvcE9iai52YWw7XG4gICAgICAgIGlmIChhZGRUb3AgIT09IG51bGwgJiYgYWRkVG9wID4gcmVjdENvbnRhaW5lclRvcCkge1xuICAgICAgICAgIGFkZCA9IGFkZFRvcDtcbiAgICAgICAgICBpZiAoIWFkZFRvcE9iai5mb3VuZEhpZGUpIHtcbiAgICAgICAgICAgIGFuaW0gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkVG9wID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuY29udGFpblsnYm90dG9tJ10pIHtcbiAgICAgICAgYWRkQm90dG9tID0gc2VsZi5ldmVudFNjcm9sbFBvcyhvcHRpb25zLmNvbnRhaW5bJ2JvdHRvbSddKTtcbiAgICAgICAgaWYgKGFkZEJvdHRvbSAhPT0gbnVsbCAmJiBhZGRCb3R0b20gPCBoZWlnaHRFbCArIGFkZFRvcCkge1xuICAgICAgICAgIGFkZCA9IGFkZEJvdHRvbSAtIGhlaWdodEVsO1xuICAgICAgICAgIGFuaW0gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRCb3R0b20gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHNhdmUgcmVhbCBhZGQgZm9yIGNhbGN1bGF0aW9uXG4gICAgZWwuZGF0YXNldC54dEFkZFN0aWNreSA9IGFkZC50b1N0cmluZygpO1xuICAgIC8vIGFjdGl2YXRpb25cbiAgICBsZXQgY2hlY2tUb3AgPSBzY3JvbGxUb3AgPj0gdG9wIC0gYWRkICsgYWRkSGlkZTtcbiAgICBsZXQgY2hlY2tCb3R0b20gPSBzY3JvbGxUb3AgPCBib3R0b20gKyBhZGQgLSBhZGRIaWRlO1xuICAgIGlmIChjaGVja1RvcCAmJiBjaGVja0JvdHRvbSkge1xuICAgICAgLy8gaW5zaWRlXG4gICAgICBzZWxmLmV2ZW50T24oZWxlbWVudCk7XG4gICAgICAvLyBoaWRlXG4gICAgICBpZiAoYWRkSGlkZSkge1xuICAgICAgICBoaWRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3V0c2lkZVxuICAgICAgc2VsZi5ldmVudE9mZihlbGVtZW50KTtcbiAgICB9XG4gICAgLy8gYWZ0ZXIgYWN0aXZlXG4gICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykpIHtcbiAgICAgIC8vIGhpZGVcbiAgICAgIGlmIChoaWRlKSB7XG4gICAgICAgIGFkZCA9IC1oZWlnaHRFbDtcbiAgICAgICAgaWYgKCFlbC5jbGFzc0xpc3QuY29udGFpbnMoJ3N0aWNreS1oaWRlJykpIHtcbiAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdzdGlja3ktaGlkZScpO1xuICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdzdGlja3kuaGlkZScpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnc3RpY2t5LWhpZGUnKSkge1xuICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ3N0aWNreS1oaWRlJyk7XG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3N0aWNreS5zaG93JykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlc2V0XG4gICAgICBhZGQgPSAwO1xuICAgICAgYW5pbSA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBhbmltXG4gICAgaWYgKGFuaW0gJiYgc2Nyb2xsVG9wT2xkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdzdGlja3ktYW5pbScpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ3N0aWNreS1hbmltJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ3N0aWNreS1hbmltJykpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnc3RpY2t5LWFuaW0nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdG9wIGFuZCBib3R0b21cbiAgICBpZiAoIWNoZWNrVG9wKSB7XG4gICAgICBpZiAoIWVsLmNsYXNzTGlzdC5jb250YWlucygnc3RpY2t5LXRvcCcpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ3N0aWNreS10b3AnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnc3RpY2t5LXRvcCcpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ3N0aWNreS10b3AnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjaGVja0JvdHRvbSkge1xuICAgICAgaWYgKCFlbC5jbGFzc0xpc3QuY29udGFpbnMoJ3N0aWNreS1ib3R0b20nKSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdzdGlja3ktYm90dG9tJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ3N0aWNreS1ib3R0b20nKSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdzdGlja3ktYm90dG9tJyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHNldCBhZGRcbiAgICBpZiAoYWRkICE9PSBzZWxmLmFkZE9sZCkge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnbm8tdHJhbnNpdGlvbicpO1xuICAgICAgaWYgKHNlbGYuYWRkT2xkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWwuc3R5bGVbb3B0aW9ucy5wb3NpdGlvbl0gPSByZWN0RWxUb3AgKyAncHgnO1xuICAgICAgfVxuICAgICAgWHRVdGlsLmNhbmNlbEFuaW1hdGlvbkZyYW1lLmNhbGwod2luZG93LCBzZWxmLmV2ZW50RnJhbWUpO1xuICAgICAgc2VsZi5ldmVudEZyYW1lID0gWHRVdGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZS5jYWxsKHdpbmRvdywgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCduby10cmFuc2l0aW9uJyk7XG4gICAgICAgIGVsLnN0eWxlW29wdGlvbnMucG9zaXRpb25dID0gYWRkICsgJ3B4JztcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBmaXggcG9zaXRpb24gZml4ZWQgd2lkdGggMTAwJSBvZiBwYXJlbnRcbiAgICBsZXQgd2lkdGggPSBzZWxmLm5vcm1hbGl6ZVdpZHRoKHNlbGYuY29udGFpbmVyWzBdLmNsaWVudFdpZHRoKTtcbiAgICBpZiAoZWwuc3R5bGUud2lkdGggIT09IHdpZHRoKSB7XG4gICAgICBlbC5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgIH1cbiAgICAvLyBzYXZlIGZvciBkaXJlY3Rpb25cbiAgICBzZWxmLmFkZE9sZCA9IGFkZDtcbiAgICBzZWxmLnNjcm9sbFRvcE9sZCA9IHNjcm9sbFRvcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgcG9zaXRpb24gb2Ygb3B0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxFbGVtZW50fSBvcHRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbCBEZWZhdWx0IHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY3JvbGxUb3AgV2luZG93J3Mgc2Nyb2xsVG9wXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHZhbHVlIE9wdGlvbidzIHBvc2l0aW9uIChweClcbiAgICovXG4gIGV2ZW50U2Nyb2xsUG9zKG9wdGlvbiwgc2Nyb2xsVG9wID0gMCwgdmFsID0gbnVsbCkge1xuICAgIGlmICghaXNOYU4ocGFyc2VGbG9hdChvcHRpb24pKSkge1xuICAgICAgdmFsID0gb3B0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZWxlbWVudHMgPSBBcnJheS5pc0FycmF5KG9wdGlvbikgPyBvcHRpb24gOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChvcHRpb24pO1xuICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgdmFsID0gMDtcbiAgICAgICAgZm9yIChsZXQgZWwgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICBsZXQgYWRkU3RpY2t5ID0gcGFyc2VGbG9hdChlbC5kYXRhc2V0Lnh0QWRkU3RpY2t5KTtcbiAgICAgICAgICBpZiAoYWRkU3RpY2t5KSB7IC8vIGlmIHN0aWNreS1oaWRlIGdldCByZWFsIGFkZFxuICAgICAgICAgICAgbGV0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgICAgICAgICBpZiAoc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgIHZhbCArPSBhZGRTdGlja3k7XG4gICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHZhbCArPSByZWN0LnRvcDtcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgdmFsICs9IHNjcm9sbFRvcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IGhlaWdodCBvZiBvcHRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEVsZW1lbnR9IG9wdGlvblxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNjcm9sbEludmVyc2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbCBEZWZhdWx0IHZhbHVlXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IG9iaiBPcHRpb24ncyBoZWlnaHQgKHB4KSBhbmQgaWYgZm91bmQgaGlkZSBlbGVtZW50XG4gICAqL1xuICBldmVudFNjcm9sbEhlaWdodChvcHRpb24sIHNjcm9sbEludmVyc2UsIHZhbCA9IG51bGwpIHtcbiAgICBsZXQgZm91bmRIaWRlID0gZmFsc2U7XG4gICAgaWYgKCFpc05hTihwYXJzZUZsb2F0KG9wdGlvbikpKSB7XG4gICAgICB2YWwgPSBvcHRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBlbGVtZW50cyA9IEFycmF5LmlzQXJyYXkob3B0aW9uKSA/IG9wdGlvbiA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKG9wdGlvbik7XG4gICAgICBpZiAoZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGVsIG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnc3RpY2t5LWhpZGUtZG93bicpICYmIGVsLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykpIHtcbiAgICAgICAgICAgIGlmIChzY3JvbGxJbnZlcnNlKSB7XG4gICAgICAgICAgICAgIHZhbCArPSBlbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgIGZvdW5kSGlkZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ3N0aWNreS1oaWRlLXVwJykgJiYgZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSkge1xuICAgICAgICAgICAgaWYgKCFzY3JvbGxJbnZlcnNlKSB7XG4gICAgICAgICAgICAgIHZhbCArPSBlbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgIGZvdW5kSGlkZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbCArPSBlbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7dmFsOiB2YWwsIGZvdW5kSGlkZTogZm91bmRIaWRlfTtcbiAgfVxuXG59XG5cbi8vIGRlZmF1bHRcblxuWHRTdGlja3kuZGVmYXVsdHMgPSB7XG4gIFwiY2xhc3NcIjogXCJhY3RpdmVcIixcbiAgXCJvblwiOiBcInNjcm9sbCByZXNpemVcIixcbiAgXCJtaW5cIjogMCxcbiAgXCJtYXhcIjogSW5maW5pdHksXG4gIFwicG9zaXRpb25cIjogXCJ0b3BcIixcbiAgXCJsaW1pdFwiOiB7XCJib3R0b21cIjogSW5maW5pdHl9LFxuICBcImNvbnRhaW5cIjogZmFsc2UsXG4gIFwiaGlkZVwiOiBmYWxzZVxufTtcblxuLy8gZXhwb3J0XG5cbndpbmRvdy5YdFN0aWNreSA9IFh0U3RpY2t5O1xuZXhwb3J0IHtYdFN0aWNreX07XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFh0RmFkZVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5jbGFzcyBYdEZhZGUgZXh0ZW5kcyBYdCB7XG5cbiAgLyoqXG4gICAqIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gb2JqZWN0IEJhc2Ugbm9kZVxuICAgKiBAcGFyYW0ge09iamVjdH0ganNPcHRpb25zIFVzZXIgb3B0aW9uc1xuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9iamVjdCwganNPcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihvYmplY3QsIGpzT3B0aW9ucywgJ2RhdGEteHQtZmFkZScpO1xuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBpbml0XG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAvKipcbiAgICogaW5pdCBldmVudHNcbiAgICovXG4gIGluaXRFdmVudHMoKSB7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBvcHRpb25zID0gc2VsZi5vcHRpb25zO1xuICAgIC8vIGV2ZW50c1xuICAgIGlmIChvcHRpb25zLm9uKSB7XG4gICAgICAvLyBoYW5kbGVyXG4gICAgICBsZXQgZmFkZUhhbmRsZXIgPSBYdFV0aWwuZGF0YVN0b3JhZ2UucHV0KHdpbmRvdywgJ2ZhZGVIYW5kbGVyJywgc2VsZi5ldmVudE9uSGFuZGxlci5iaW5kKHNlbGYpKTtcbiAgICAgIC8vIGV2ZW50XG4gICAgICBsZXQgZXZlbnRzID0gWy4uLm9wdGlvbnMub24uc3BsaXQoJyAnKV07XG4gICAgICBmb3IgKGxldCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGZhZGVIYW5kbGVyKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZhZGVIYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvbi5mYWRlJywgZmFkZUhhbmRsZXIpO1xuICAgIH1cbiAgICAvLyB0cmlnZ2VyIGluaXRpYWxcbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ29uLmZhZGUnKSk7XG4gIH1cblxuICAvKipcbiAgICogZWxlbWVudCBvbiBoYW5kbGVyXG4gICAqIEBwYXJhbSB7Tm9kZXxIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqL1xuICBldmVudE9uSGFuZGxlcihlbGVtZW50LCBlKSB7XG4gICAgdGhpcy5ldmVudFNjcm9sbCh0aGlzLm9iamVjdCk7XG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIGV2ZW50c1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgLyoqXG4gICAqIHdpbmRvdyBzY3JvbGxcbiAgICovXG4gIGV2ZW50U2Nyb2xsKCkge1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBsZXQgb3B0aW9ucyA9IHNlbGYub3B0aW9ucztcbiAgICAvLyB2YXJzXG4gICAgbGV0IGN1cnJlbnQgPSAwO1xuICAgIGxldCBjdXJyZW50cyA9IFtdO1xuICAgIGxldCBzY3JvbGxJbnZlcnNlID0gZmFsc2U7XG4gICAgbGV0IHdpbmRvd0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICBsZXQgc2Nyb2xsaW5nRWxlbWVudCA9IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQ7XG4gICAgbGV0IHNjcm9sbFRvcCA9IHNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsVG9wO1xuICAgIGxldCBzY3JvbGxUb3BPbGQgPSBzZWxmLnNjcm9sbFRvcE9sZDtcbiAgICAvLyBkaXJlY3Rpb25cbiAgICBpZiAoc2Nyb2xsVG9wIDwgc2Nyb2xsVG9wT2xkKSB7XG4gICAgICBzY3JvbGxJbnZlcnNlID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gY29yZVxuICAgIGZvciAobGV0IGVsIG9mIHNlbGYuZWxlbWVudHMpIHtcbiAgICAgIGlmIChlbC5vZmZzZXRQYXJlbnQgJiYgIWVsLmNsYXNzTGlzdC5jb250YWlucygnZmFkZS1ibG9jaycpKSB7XG4gICAgICAgIC8vIHZhcnNcbiAgICAgICAgbGV0IHJlY3RFbFRvcCA9IGVsLm9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyBlbC5vZmZzZXRUb3A7IC8vIHdlIHVzZSBwYXJlbnRzIHRvIG5vdCBpbmNsdWRlIHRyYW5zZm9ybXMgYW5pbWF0aW9uc1xuICAgICAgICBsZXQgaGVpZ2h0RWwgPSBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUoZWwpLmhlaWdodCk7XG4gICAgICAgIC8vIHNjcm9sbFxuICAgICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgdG9wID0gcmVjdEVsVG9wICsgc2Nyb2xsVG9wO1xuICAgICAgICBsZXQgYm90dG9tID0gdG9wICsgaGVpZ2h0RWw7XG4gICAgICAgIGxldCBkaXN0ID0gd2luZG93SGVpZ2h0ICogb3B0aW9ucy5kaXN0YW5jZTtcbiAgICAgICAgLy8gYWN0aXZhdGlvblxuICAgICAgICBsZXQgY2hlY2tUb3AgPSBzY3JvbGxUb3AgKyB3aW5kb3dIZWlnaHQgPj0gdG9wICsgZGlzdDtcbiAgICAgICAgbGV0IGNoZWNrQm90dG9tID0gc2Nyb2xsVG9wIDwgYm90dG9tIC0gZGlzdDtcbiAgICAgICAgaWYgKGNoZWNrVG9wICYmIGNoZWNrQm90dG9tKSB7XG4gICAgICAgICAgLy8gaW5zaWRlXG4gICAgICAgICAgY2hhbmdlZCA9IHNlbGYuY2hlY2tPbihlbCk7XG4gICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRzLnB1c2goZWwpO1xuICAgICAgICAgICAgWHRVdGlsLmNhbmNlbEFuaW1hdGlvbkZyYW1lLmNhbGwod2luZG93LCBlbC5kYXRhc2V0LmV2ZW50RnJhbWUpO1xuICAgICAgICAgICAgZWwuZGF0YXNldC5ldmVudEZyYW1lID0gWHRVdGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZS5jYWxsKHdpbmRvdywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWxheU9uKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZ1bmMgPSBuZXcgRnVuY3Rpb24oJ2N1cnJlbnQnLCAndG90YWwnLCBvcHRpb25zLmRlbGF5T24pO1xuICAgICAgICAgICAgICAgIGVsLmRhdGFzZXQueHRPbkRlbGF5ID0gZnVuYyhjdXJyZW50LCBjdXJyZW50cy5sZW5ndGgpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNlbGYuZXZlbnRPbihlbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb3V0c2lkZVxuICAgICAgICAgIGNoYW5nZWQgPSBzZWxmLmNoZWNrT2ZmKGVsKTtcbiAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdmYWRlLXZpc2libGUnKTtcbiAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnZmFkZS1zY3JvbGwnKTtcbiAgICAgICAgICAgIGN1cnJlbnRzLnB1c2goZWwpO1xuICAgICAgICAgICAgWHRVdGlsLmNhbmNlbEFuaW1hdGlvbkZyYW1lLmNhbGwod2luZG93LCBlbC5kYXRhc2V0LmV2ZW50RnJhbWUpO1xuICAgICAgICAgICAgZWwuZGF0YXNldC5ldmVudEZyYW1lID0gWHRVdGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZS5jYWxsKHdpbmRvdywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWxheU9mZikge1xuICAgICAgICAgICAgICAgIGxldCBmdW5jID0gbmV3IEZ1bmN0aW9uKCdjdXJyZW50JywgJ3RvdGFsJywgb3B0aW9ucy5kZWxheU9mZik7XG4gICAgICAgICAgICAgICAgZWwuZGF0YXNldC54dE9mZkRlbGF5ID0gZnVuYyhjdXJyZW50LCBjdXJyZW50cy5sZW5ndGgpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoYW5nZWQgPSBzZWxmLmV2ZW50T2ZmKGVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBkaXJlY3Rpb25cbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICBpZiAoc2Nyb2xsSW52ZXJzZSkge1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnZmFkZS1kb3duJyk7XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdmYWRlLXVwJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2ZhZGUtZG93bicpO1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnZmFkZS11cCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBzYXZlIGZvciBkaXJlY3Rpb25cbiAgICBzZWxmLnNjcm9sbFRvcE9sZCA9IHNjcm9sbFRvcDtcbiAgfVxuXG59XG5cbi8vIGRlZmF1bHRcblxuWHRGYWRlLmRlZmF1bHRzID0ge1xuICBcImVsZW1lbnRzXCI6IFwiLmZhZGVcIixcbiAgXCJjbGFzc1wiOiBcImluXCIsXG4gIFwib25cIjogXCJzY3JvbGwgcmVzaXplXCIsXG4gIFwibWluXCI6IDAsXG4gIFwibWF4XCI6IEluZmluaXR5LFxuICBcImRpc3RhbmNlXCI6IDAuMixcbiAgXCJkZWxheU9uXCI6IGZhbHNlLFxuICBcImRlbGF5T2ZmXCI6IGZhbHNlXG59O1xuXG4vLyBleHBvcnRcblxud2luZG93Llh0RmFkZSA9IFh0RmFkZTtcbmV4cG9ydCB7WHRGYWRlfTtcbiJdfQ=="}